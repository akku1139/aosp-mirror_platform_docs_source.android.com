page.title=Debugging the Android platform
@jd:body

<!--
    Copyright 2015 The Android Open Source Project

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<div id="qv-wrapper">
  <div id="qv">
    <h2>In this document</h2>
    <ol id="auto-toc"></ol>
  </div>
</div>

<p>This page contains a summary of useful tools and related commands for
debugging, tracing, and profiling Android. The pages within this section
contain detailed information on other debugging tools for use during
development of platform-level features.</p>

<h2 id=debuggerd>debuggerd</h2>

<p>When a dynamically-linked executable starts, several signal handlers are
registered that connect to debuggerd (or debuggerd64) in the event that signal
is sent to the process. The debuggerd process dumps registers and unwinds the
stack. For example: </p>

<pre>
08-24 22:42:14.424   238   238 F DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
08-24 22:42:14.424   238   238 F DEBUG   : Build fingerprint: 'Android/aosp_flounder/flounder:5.1.51/AOSP/enh08201009:eng/test-keys'
08-24 22:42:14.424   238   238 F DEBUG   : Revision: '0'
08-24 22:42:14.424   238   238 F DEBUG   : ABI: 'arm'
08-24 22:42:14.425   238   238 F DEBUG   : pid: 1656, tid: 1656, name: crasher  &gt;&gt;&gt; crasher &lt;&lt;&lt;
08-24 22:42:14.425   238   238 F DEBUG   : signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------
08-24 22:42:14.438   238   238 F DEBUG   : Abort message: 'some_file.c:123: some_function: assertion "false" failed'
08-24 22:42:14.438   238   238 F DEBUG   :     r0 00000000  r1 00000678  r2 00000006  r3 f70b6dc8
08-24 22:42:14.438   238   238 F DEBUG   :     r4 f70b6dd0  r5 f70b6d80  r6 00000002  r7 0000010c
08-24 22:42:14.438   238   238 F DEBUG   :     r8 ffffffed  r9 00000000  sl 00000000  fp ff96ae1c
08-24 22:42:14.439   238   238 F DEBUG   :     ip 00000006  sp ff96ad18  lr f700ced5  pc f700dc98  cpsr 400b0010
08-24 22:42:14.454   238   238 F DEBUG   : 
08-24 22:42:14.454   238   238 F DEBUG   : backtrace:
08-24 22:42:14.455   238   238 F DEBUG   :     #00 pc 00042c98  /system/lib/libc.so (tgkill+12)
08-24 22:42:14.455   238   238 F DEBUG   :     #01 pc 00041ed1  /system/lib/libc.so (pthread_kill+32)
08-24 22:42:14.455   238   238 F DEBUG   :     #02 pc 0001bb87  /system/lib/libc.so (raise+10)
08-24 22:42:14.455   238   238 F DEBUG   :     #03 pc 00018cad  /system/lib/libc.so (__libc_android_abort+34)
08-24 22:42:14.455   238   238 F DEBUG   :     #04 pc 000168e8  /system/lib/libc.so (abort+4)
08-24 22:42:14.455   238   238 F DEBUG   :     #05 pc 0001a78f  /system/lib/libc.so (__libc_fatal+16)
08-24 22:42:14.455   238   238 F DEBUG   :     #06 pc 00018d35  /system/lib/libc.so (__assert2+20)
08-24 22:42:14.455   238   238 F DEBUG   :     #07 pc 00000f21  /system/xbin/crasher
08-24 22:42:14.455   238   238 F DEBUG   :     #08 pc 00016795  /system/lib/libc.so (__libc_init+44)
08-24 22:42:14.456   238   238 F DEBUG   :     #09 pc 00000abc  /system/xbin/crasher
08-24 22:42:14.513   238   238 F DEBUG   : 
08-24 22:42:14.513   238   238 F DEBUG   : Tombstone written to: /data/tombstones/tombstone_06
</pre>

<p>This can be pasted into development/scripts/stack to get a more detailed unwind
with line number information (assuming the unstripped binaries can be found).</p>

<p>Some libraries on the system are built with “LOCAL_STRIP_MODULE :=
keep_symbols” to provide usable backtraces directly from debuggerd. This makes
your library/executable slightly larger, but not nearly as large as an
unstripped version.</p>

<p>Note also the last line of debuggerd output --- in addition to dumping a
summary to the log, debuggerd writes a full “tombstone” to disk. This contains
a lot of extra information that can be helpful in debugging a crash, in
particular the stack traces for all the threads in the crashing process (not
just the thread that caught the signal) and a full memory map.</p>

<h2 id=native>Native Debugging with GDB</h2>

<h3 id=running>Debugging a running app</h3>

<p>To connect to an already-running app or native daemon, use <em>gdbclient</em>.</p>

<p>Current versions of gdbclient just require the pid. So to debug a process with
pid 1234, just run <code>$ gdbclient 1234</code>. The script will set up port forwarding,
start the appropriate <code>gdbserver</code> on the device, start the appropriate <code>gdb</code> on
the host, configure gdb to find symbols, and connect gdb to the remote
gdbserver.</p>

<h3 id=starts>Debugging a native process as it starts</h3>

<p>If you want to debug a process as it starts, you’ll need to use gdbserver
manually, but that’s easy too:</p>

<pre>$ adb shell gdbserver :5039 /system/bin/<em>my_test_app</em></pre>

<p># Get the app’s pid using ps.</p>

<pre>$ gdbserver <em>&lt;app pid&gt;</em></pre>

<p>Then enter "continue" at the gdb prompt.</p>

<h3 id=crash>Debugging processes that crash</h3>

<p>If you want debuggerd to suspend crashed processes so you can attach gdb, set
the appropriate property:</p>

<pre>
adb shell setprop debug.db.uid 999999                 # &lt;= M
adb shell setprop debug.debuggerd.wait_for_gdb true   # &gt; M
</pre>

<p>At the end of the usual crash output, debuggerd will give you instructions on
how to connect gdb (which is just <code>gdbclient &lt;pid&gt;</code> as usual).</p>

<h3 id=symbols>Debugging without symbols</h3>

<p>If you don’t have symbols, sometimes gdb will get confused about the
instruction set it is disassembling (ARM or Thumb). The instruction set that is
chosen as the default when symbol information is missing can be changed to ARM
by:</p>

<pre>set arm fallback-mode arm   # or 'thumb'</pre>

<h2 id=symbols>Other tools</h2>

<h3 id=systrace>Systrace</h3>

<p>See <a href="https://developer.android.com/tools/help/systrace.html">Systrace on developer.android.com</a>.</p>

<h3 id=java>Java debugging</h3>

<p>This should work without any configuration.</p>

<h3 id=gltrace>GLTrace</h3>

<p>This should work without any configuration.</p>

<h3 id=valgrind>Valgrind</h3>

<p>The following steps show you how to use Valgrind:</p>

<ol>
  <li> To install Valgrind, run:<br>
    $ mmm -j6 external/valgrind
  <li> Push Valgrind to the device:
    <br>
<code>
$ adb remount<br>
$ adb sync</code>
  <li> Set up the temp directory:<br>
    <code>$ adb shell mkdir /data/local/tmp<br>
$ adb shell chmod 777 /data/local/tmp
    </code>
  <li> Running the system server with valgrind:<br>
    <code>$ adb root <br>
  $ adb shell setprop wrap.system_server "logwrapper valgrind"<br> 
  $ adb shell stop && adb shell start
    </code>
  <li> For debug symbols, you will need to push unstripped libraries to <code>/data/local/symbols</code>:<br>
    <code>$ adb shell mkdir /data/local/symbols<br>
$ adb push $OUT/symbols /data/local/symbols
    </code>
  <li> To use valgrind during boot-up, edit <code>out/target/product/XXXX/root/init.rc</code> and
change the <code>service example /system/bin/foo --arg1 --arg2</code> to <code>service example
/system/bin/logwrapper /system/bin/valgrind /system/bin/foo --arg1 --arg2</code> . To
see the effects, you need to create a <code>boot.img</code> and reflash the device.
</ol>
