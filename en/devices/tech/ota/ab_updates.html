<html devsite>
  <head>
    <title>A/B (Seamless) System Updates</title>
    <meta name="project_path" value="/_project.yaml" />
    <meta name="book_path" value="/_book.yaml" />
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->



<p>
  A/B system updates, also known as seamless updates, ensure a workable booting
  system remains on the disk during an <a href="/devices/tech/ota/index.html"
  >over-the-air (OTA) update</a>. This reduces the likelihood of an inactive
  device afterward, which means fewer device replacements and device reflashes at
  repair and warranty centers. This approach is already explored successfully by
  other commercial-grade operating systems, such as <a
  href="https://www.chromium.org/chromium-os">ChromeOS</a>, and Android 8.0
  comes with the necessary platform changes to conduct streaming updates. Android
  7.0 and later support streaming updates with the correct version of <a
    href="https://www.android.com/gms/">Google Mobile Services (GMS)</a>
  installed.</p>

<p>
  Users don't always have enough space on <code>/data</code> to download the
  update package, and neither OEMs nor users want to waste space on a
  <code>/cache</code> partition; so some users go without updates because
  they have nowhere to store the update package. A/B updates have the option of
  streaming the update to address this issue: streaming writes blocks
  straight to the B partition as they are downloaded, without having to store
  them on <code>/data</code>. Therefore, streaming A/B updates need almost no
  temporary storage and need just enough for roughly 100 KiB of metadata.</p>

<p>Customers can continue to use their devices during an OTA. The only downtime
  during an update is when the device reboots into the updated disk partition. If
  the OTA fails, the device is still useable since it will boot into the pre-OTA
  disk partition. The download of the OTA can be attempted again. A/B system
  updates implemented through OTA are recommended for new devices only. </p>

<p>
  A/B system updates affect:
</p>

<ul>
  <li>Interactions with the bootloader</li>
  <li>Partition selection</li>
  <li>The build process</li>
  <li>OTA update package generation</li>
</ul>

<p>
  The existing <a href="/security/verifiedboot/dm-verity.html">dm-verity</a>
  feature guarantees the device will boot an uncorrupted image. If
  a device doesn't boot, because of a bad OTA or dm-verity issue, the device can
  reboot into an old image.
</p>

<p class="note"><strong>Note:</strong> Android <a
  href="/security/verifiedboot/">Verified Boot</a> does not require A/B
  updates.</p>

<h2 id="overview">Overview</h2>

<p>
  The A/B system is robust because any errors (such as I/O errors) affect only
  the <strong>unused</strong> partition set and can be retried. Such errors also
  become less likely because the I/O load is deliberately low to avoid degrading
  the user experience.
</p>

<p>
  OTA updates can occur while the system is running, without interrupting the
  user. This includes the app optimizations that occur after a reboot.
  Additionally, the cache partition is no longer used to store OTA update
  packages; there is no need for sizing the cache partition.
</p>

<p>
  A/B system updates use a background daemon called <code>update_engine</code>
  and two sets of partitions. The two sets of partitions are referred to as
  <em>slots</em>, normally as slot A and slot B. The system runs from one slot,
  the <em>current</em> slot, while the partitions in the <em>unused</em> slot are
  not accessed by the running system (for normal operation).
</p>

<p>
  The goal of this feature is to make updates fault resistant by keeping the
  unused slot as a fallback. If there is an error during an update or immediately
  after an update, the system can rollback to the old slot and continue to have a
  working system. To achieve this goal, none of the partitions used by the
  <em>current</em> slot should be updated as part of the OTA update (including
  partitions for which there is only one copy).
</p>

<p>
  Each slot has a <em>bootable</em> attribute, which states whether the slot
  contains a correct system from which the device can boot. The current slot is
  clearly bootable when the system is running, but the other slot may have an old
  (still correct) version of the system, a newer version, or invalid data.
  Regardless of what the <em>current</em> slot is, there is one slot which is the
  <em>active</em> or preferred slot. The active slot is the one the bootloader
  will boot from on the next boot. Finally, each slot has a <em>successful</em>
  attribute set by the user space, which is only relevant if the slot is also
  bootable.
</p>

<p>
  A successful slot should be able to boot, run, and update itself. A bootable
  slot that was not marked as successful (after several attempts were made to
  boot from it) should be marked as unbootable by the bootloader, including
  changing the active slot to another bootable slot (normally to the slot running
  right before the attempt to boot into the new, active one). The specific
  details of the interface are defined in
  <code><a class="external-link" target="_blank"
           href="https://android.googlesource.com/platform/hardware/libhardware/+/master/include/hardware/boot_control.h" >boot_control.h</a></code>.
</p>

<h3 id="bootloader-state-examples">Bootloader state examples</h3>

<p>
  The <code>boot_control</code> HAL is used by <code>update_engine</code> (and
  possibly other daemons) to instruct the bootloader what to boot from. These
  are common example scenarios and their associated states:
</p>

<ul>
  <li>
    <strong>Normal case</strong>: The system is running from its current slot,
    either slot A or B. No updates have been applied so far. The system's current
    slot is bootable, successful, and the active slot.
  </li>
  <li>
    <strong>Update in progress</strong>: The system is running from slot B, so
    slot B is the bootable, successful, and active slot. Slot A was marked as
    unbootable since the contents of slot A are being updated but not yet
    completed. A reboot in this state should continue booting from slot B.
  </li>
  <li>
    <strong>Update applied, reboot pending</strong>: The system is running from
    slot B, slot B is bootable and successful, but slot A was marked as active
    (and therefore is marked as bootable). Slot A is not yet marked as successful
    and some number of attempts to boot from slot A should be made by the
    bootloader.
  </li>
  <li>
    <strong>System rebooted into new update</strong>: The system is running from
    slot A for the first time, slot B is still bootable and successful while slot
    A is only bootable, and still active but not successful. A user space daemon
    should mark slot A as successful after some checks are made.
  </li>
</ul>

<h3 id="update-engine-features">Update Engine features</h3>

<p>
  The <code>update_engine</code> daemon runs in the background and prepares the
  system to boot into a new, updated version. The <code>update_engine</code>
  daemon is not involved in the boot process itself and is limited in what it can
  do during an update. The <code>update_engine</code> daemon can do the
  following:
</p>

<ul>
  <li>
    Read from the current slot A/B partitions and write any data to the unused
    slot A/B partitions as instructed by the OTA package
  </li>
  <li>
    Call the <code>boot_control</code> interface in a pre-defined workflow
  </li>
  <li>
    Run a <em>post-install</em> program from the <em>new</em> partition after
    writing all the unused slot partitions, as instructed by the OTA package
  </li>
</ul>

<p>
  The post-install step is described in detail below. Note that the
  <code>update_engine</code> daemon is limited by the
  <a href="/security/selinux/">SELinux</a> policies and features in the
  <em>current</em> slot; those policies and features can't be updated until the
  system boots into a new version. To achieve a robustness goal, the update
  process should not:
</p>

<ul>
  <li>Modify the partition table</li>
  <li>Modify the contents of partitions in the current slot</li>
  <li>
    Modify the contents of non-A/B partitions that can't be wiped with a
    factory reset
  </li>
  </ul>
  
<h3 id="update-engine-source">Update Engine source</h3>

<p>The source to update_engine is in system/update_engine. The A/B OTA dexopt
files are split between installd and package manager:</p>
<ul>
  <li>frameworks/native/cmd/installd/ota* --- the postinstall script, the
    binary for chroot, the installd clone that calls dex2oat, the post-OTA
    move-artifacts script, the rc file for the move script.</li>
  <li>frameworks/base/service/core/java/com/android/server/pm/OtaDexoptService.java
    (plus OtaDexoptShellCommand) is the package manager side that will prepare
    all the dex2oat commands for the apps</li>
</ul>

<p>A working example can be found in <a href="https://android.googlesource.com/device/google/marlin/+/nougat-dr1-release/device-common.mk">/device/google/marlin/device-common.mk</a>.</p>

<h2 id="life-of-an-a-b-update">Life of an A/B update</h2>

<p>
  The update process starts when an OTA package, referred to in code as a
  <em>payload</em>, is available for downloading. Policies in the device may
  defer the payload download and application based on battery level, user
  activity, whether it is connected to a charger, or other policies. But since
  the update runs in the background, the user might not know that an update is
  in progress and the process can be interrupted at any point due to policies or
  unexpected reboots.
</p>

<p>
   Optionally, metadata in the OTA package itself indicates the update can be
   streamed. The same package can be used for non-streaming installation, as
   well. The server may use the metadata to tell the client it's streaming
   so the client will hand off the OTA to <code>update_engine</code> correctly.
   To enable streaming updates, manufacturers with their own server and client
   would need to:
   <ol>
     <li>on the server, identify the update is streaming (or just assume all are)</li>
     <li>on the client, make the correct call to update_engine for streaming</li>
   </ol>

<p>
  Device manufacturers should use the fact that the package is of the streaming
  variant to send a flag to the client to trigger hand off to the framework
  side as streaming.
</p>

<p>
  The steps in the update process after a payload is available are as follows:
</p>

<p>
  <strong>Step 1:</strong> The current slot (or "source slot") is marked as
  successful (if not already marked) with <code>markBootSuccessful()</code>.
</p>

<p>
  <strong>Step 2:</strong> The unused slot (or "target slot") is marked as
  unbootable by calling the function <code>setSlotAsUnbootable()</code>.
</p>

<p>
  The current slot is always marked as successful at the beginning of the update
  to prevent the bootloader from falling back to the unused slot, which will soon
  have invalid data. If the system has reached the point where it can start
  applying an update, the current slot is marked as successful even if other
  major components are broken (such as the UI in a crash loop) since it's
  possible to push new software to fix these major problems.
</p>

<p>
  The update payload is an opaque blob with the instructions to update to the
  new version. The update payload consists of basically two parts: the metadata
  and the extra data associated with the instructions. The metadata is
  relatively small and contains a list of operations to produce and verify the
  new version on the target slot. For example, an operation could decompress a
  certain blob and write it to certain blocks in a target partition, or read from
  a source partition, apply a binary patch, and write to certain blocks in a
  target partition. The extra data associated to the operations, not included in
  the metadata, is the bulk of the update payload and would consist of the
  compressed blob or binary patch in these examples.
</p>

<p>
  <strong>Step 3:</strong> The payload metadata is downloaded.
</p>

<p>
  <strong>Step 4:</strong> For each operation defined in the metadata, in order,
  the associated data (if any) is downloaded to memory, the operation is applied,
  and the associated memory is discarded.
</p>

<p>
  These two steps take most of the update time, as they involve writing and
  downloading large amounts of data, and are likely to be interrupted for reasons
  of policy or reboot.
</p>

<p>
  <strong>Step 5:</strong> The whole partitions are re-read and verified against
  the expected hash.
</p>

<p>
  <strong>Step 6:</strong> The post-install step (if any) is run.
</p>

<p>
  In the case of an error during the execution of any step, the update fails and
  is re-attempted with possibly a different payload. If all the steps so far have
  succeeded, the update succeeds and the last step is executed.
</p>

<p>
  <strong>Step 7:</strong> The <em>unused slot</em> is marked as active by
  calling <code>setActiveBootSlot()</code>.
</p>

<p>
  Marking the unused slot as active doesn't mean it will finish booting. The
  bootloader—or system itself—can switch the active slot back if it doesn't
  read a successful state.
</p>

<h3 id="post-install-step">Post-install step</h3>

<p>
  The post-install step consists of running a program from the "new update"
  version while still running in the old version. If defined in the OTA package,
  this step is mandatory and the program must return with exit code
  <code>0</code>; otherwise, the update fails.
</p>

<p>
  For every partition where a post-install step is defined,
  <code>update_engine</code> mounts the new partition into a specific location
  and executes the program specified in the OTA relative to the mounted
  partition. For example, if the post-install program is defined as
  <code>usr/bin/postinstall</code> in the system partition, this partition from
  the unused slot will be mounted in a fixed location (for example, in
  <code>/postinstall_mount</code>) and the
  <code>/postinstall_mount/usr/bin/postinstall</code> command will be executed.
  Note that for this step to work, the following are required:
</p>

<ul>
  <li>
    The old kernel needs to be able to mount the new filesystem format. The
    filesystem type cannot change unless there's support for it in the old
    kernel (which includes details such as the compression algorithm used if
    using a compressed filesystem like SquashFS).
  </li>
  <li>
    The old kernel needs to understand the new partition's post-install program
    format. If using an ELF binary, it should be compatible with the old
    kernel (e.g. a 64-bit new program running on an old 32-bit kernel if the
    architecture switched from 32- to 64-bit builds). Also, the libraries
    will be loaded from the old system image, not the new one, unless the loader
    (<code>ld</code>) is instructed to use other paths or build a static binary.
  </li>
  <li>
    The new post-install program will be limited by the SELinux policies defined
    in the old system.
  </li>
</ul>

<p>
  An example case is to use a shell script as a post-install program (interpreted
  by the old system's shell binary with a <code>#!</code> marker at the top) and
  then set up library paths from the new environment for executing a more complex
  binary post-install program.
</p>

<p>
  Another example case is to run the post-install step from a dedicated smaller
  partition, so the filesystem format in the main system partition can be updated
  without incurring backward compatibility issues or stepping-stone updates,
  allowing users to update straight to the latest version from a factory image.
</p>

<p>
  Due to the SELinux policies, the post-install step is suitable for
  performing tasks required by design on a given device or other best-effort
  tasks: update the A/B-capable firmware or bootloader, prepare copies of some
  databases for the new version, etc. This step is not suitable for one-off bug
  fixes before reboot that require unforeseen permissions.
</p>

<p>
  The selected post-install program runs in the <code>postinstall</code> SELinux
  context. All the files in the new mounted partition will be tagged with
  <code>postinstall_file</code>, regardless of what their attributes are after
  rebooting into that new system. Changes to the SELinux attributes in the new
  system won't impact the post-install step. If the post-install program needs
  extra permissions, those must be added to the post-install context.
</p>

<h2 id="implementation">Implementation</h2>

<p>
  OEMs and SoC vendors who wish to implement the feature must add the following
  support to their bootloaders:
</p>

<ul>
  <li>
    Pass the <a href="#kernel-command-line-arguments">correct parameters</a>
    to the kernel
  </li>
  <li>
    Implement the <code>boot_control</code> HAL
    (<a class="external-link nowrap" target="_blank"
        href="https://android.googlesource.com/platform/hardware/libhardware/+/master/include/hardware/boot_control.h"
    >/platform/hardware/libhardware/include/hardware/boot_control.h</a>)
  </li>
  <li>Implement the state machine as shown in Figure 1:</li>
</ul>

<img src="/devices/tech/ota/images/ab-updates-state-machine.png">

<p class="img-caption"><strong>Figure 1.</strong> Bootloader state machine</p>

<p>
  The boot control HAL can be tested using the
  <a class="external-link" target="_blank"
     href="https://android.googlesource.com/platform/system/extras/+/master/bootctl/"
  ><code>/platform/system/extras/bootctl</code></a> utility.
</p>

<p>Some tests have been implemented for Brillo:</p>

<ul>
  <li>
    <a class="external-link nowrap" target="_blank"
       href="https://android.googlesource.com/platform/system/extras/+/refs/heads/master/tests/bootloader/"
    >/platform/system/extras/tests/bootloader/</a>
  </li>
  <li>
    <a class="external-link nowrap" target="_blank"
       href="https://chromium.googlesource.com/chromiumos/third_party/autotest/+/master/server/site_tests/brillo_BootLoader/brillo_BootLoader.py"
    >chromium.googlesource.com/chromiumos/third_party/autotest/+/master/server/site_tests/brillo_BootLoader/brillo_BootLoader.py</a>
  </li>
</ul>

<h3 id="kernel-patches">Kernel patches</h3>

<ul>
  <li>
    <a class="external-link nowrap" target="_blank"
       href="https://android-review.googlesource.com/#/c/158491/"
    >android-review.googlesource.com/#/c/158491/</a>
  </li>
  <li>
    <a class="external-link nowrap" target="_blank"
       href="https://android-review.googlesource.com/#/q/status:merged+project:kernel/common+branch:android-3.18+topic:A_B_Changes_3.18"
    >android-review.googlesource.com/#/q/status:merged+project:kernel/common+branch:android-3.18+topic:A_B_Changes_3.18</a>
  </li>
</ul>

<h3 id="kernel-command-line-arguments">Kernel command line arguments</h3>

<p>
  The kernel command line arguments <strong>must</strong> contain the following
  extra arguments:
</p>

<pre class="devsite-click-to-copy">
<code class="devsite-terminal">skip_initramfs rootwait ro init=/init root="/dev/dm-0 dm=system none ro,0 1 \
  android-verity &lt;public-key-id&gt; &lt;path-to-system-partition&gt;"</code>
</pre>

<p>
  The <code>&lt;public-key-id&gt;</code> value is the ID of the public key used
  to verify the verity table signature (see
  <a href="/security/verifiedboot/dm-verity.html">dm-verity</a>).
</p>

<h4>
  To add the .X509 certificate containing the public key to the system keyring:
</h4>

<ol>
  <li>
    Copy the .X509 certificate formatted in the <code>.der</code>
    format to the root of the <code>kernel</code> directory. Use the following
    <code>openssl</code> command to convert from <code>.pem</code> to
    <code>.der</code> format (if the .X509 certificate is formatted in
    <code>.pem</code> format):
<pre class="devsite-terminal devsite-click-to-copy">
openssl x509 -in &lt;x509-pem-certificate&gt; -outform der -out &lt;x509-der-certificate&gt;
</pre>
  </li>
  <li>
    Once copied to the kernel build root, build the <code>zImage</code> to
    include the certificate as part of the system keyring. This can be verified
    from the following <code>procfs</code> entry (requires
    <code>KEYS_CONFIG_DEBUG_PROC_KEYS</code> to be enabled):
<pre class="devsite-click-to-copy">
angler:/# cat /proc/keys

1c8a217e I------     1 perm 1f010000     0     0 asymmetri
Android: 7e4333f9bba00adfe0ede979e28ed1920492b40f: X509.RSA 0492b40f []
2d454e3e I------     1 perm 1f030000     0     0 keyring
.system_keyring: 1/4
</pre>
  </li>
</ol>

<p>
  Successful inclusion of the .X509 certificate indicates the presence of the
  public key in the system keyring. The highlighted portion denotes the public
  key ID.
</p>

<p>
  As the next step, replace the space with ‘#’ and pass it as
  <code>&lt;public-key-id&gt;</code> in the kernel command line. For example, in the
  above case, the following is passed in the place of
  <code>&lt;public-key-id&gt;</code>:
  <code>Android:#7e4333f9bba00adfe0ede979e28ed1920492b40f</code>
</p>

<h3 id="recovery">Recovery</h3>

<p>
  The recovery RAM disk is now contained in the <code>boot.img</code> file. When
  going into recovery, the bootloader <strong>cannot</strong> put the
  <code>skip_initramfs</code> option on the kernel command line.
</p>
<p>
  For non-A/B updates, the recovery partition contains the code used to apply
  updates. A/B updates are applied by update_engine running in the regular
  booted system image. There is still a recovery mode used to implement factory
  data reset and sideloading of update packages, which is where the name
  "recovery" came from. The code and data for recovery mode is stored in the
  regular boot partition now, in a ramdisk. So to boot into the system image,
  the bootloader tells the kernel to skip the ramdisk; otherwise we'll boot
  into recovery mode. Recovery mode is small (and much of it was already on the
  boot partition), so the boot partition doesn't increase in size.</p>

<h3 id="build-variables">Build variables</h3>

<p>To implement A/B updates, you need a new A/B-capable bootloader and have
`AB_OTA_UPDATER := true` in your board configuration and list the
partitions to which A/B applies.</p>
<h5>Must define for the A/B target:</h5>

<ul>
  <li><code>AB_OTA_UPDATER := true</code></li>
  <li>
    <code>AB_OTA_PARTITIONS := \</code><br/>
    <code>&nbsp; boot \</code><br/>
    <code>&nbsp; system \</code><br/>
    <code>&nbsp; vendor</code><br/>
    and other partitions updated through <code>update_engine</code> (radio,
    bootloader, etc.)
  </li>
  <li>
    <code>BOARD_BUILD_SYSTEM_ROOT_IMAGE := true</code>
  </li>
  <li><code>TARGET_NO_RECOVERY := true</code></li>
  <li>
    <code>BOARD_USES_RECOVERY_AS_BOOT := true</code>
  </li>
  <li>
    <code>PRODUCT_PACKAGES += \</code><br/>
    <code>&nbsp; update_engine \</code><br/>
    <code>&nbsp; update_verifier</code>
  </li>
  </ul>
<p>For an example, see:<br>
  <a href="https://android.googlesource.com/device/google/marlin/+/android-7.1.0_r1/device-common.mk">/device/google/marlin/+/android-7.1.0_r1/device-common.mk</a></p>

<p>Optionally, conduct the post-install (but pre-reboot) dex2oat step described
within the <a href="#compilation">Compilation</a> section.</p>

<h5>Optionally define for debug builds:</h5>

<ul>
  <li>
    <code>PRODUCT_PACKAGES_DEBUG += update_engine_client</code>
  </li>
</ul>

<h5>Cannot define for the A/B target:</h5>

<ul>
  <li><code>BOARD_RECOVERYIMAGE_PARTITION_SIZE</code></li>
  <li><code>BOARD_CACHEIMAGE_PARTITION_SIZE</code></li>
  <li><code>BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE</code></li>
</ul>

<h3 id="partitions">Partitions</h3>
<p>
    A/B devices do not need a recovery partition or cache partition because
    Android no longer uses these partitions. The data partition is now used for
    the downloaded OTA package, and the recovery image code is on the boot
    partition.
    All partitions that are A/B-ed should be named as follows (slots are always
    named <code>a</code>, <code>b</code>, etc.): <code>boot_a</code>,
    <code>boot_b</code>, <code>system_a</code>, <code>system_b</code>,
    <code>vendor_a</code>, <code>vendor_b</code>.
</p>

<p>For non-A/B updates, the cache partition was used to store downloaded OTA
packages and to stash blocks temporarily while applying updates. There was
never a good way to size the cache partition: how large it needed to be
depended on what updates you wanted to apply. The worst case would be a cache
partition as large as the system image. With A/B updates there's no need to
stash blocks (because you're always writing to a partition that isn't currently
used) and with streaming A/B there's no need to download the whole OTA package
before applying it (see "How do streaming A/B updates work?").</p>

<h3 id="fstab">Fstab</h3>

<p>
  The <code>slotselect</code> argument <strong>must</strong> be on the line for
  the A/B-ed partitions. For example:
</p>

<pre class="devsite-click-to-copy">
&lt;path-to-block-device&gt;/vendor  /vendor  ext4  ro
wait,verify=&lt;path-to-block-device&gt;/metadata,slotselect
</pre>

<p>
  Please note that there should be no partition named <code>vendor</code> but
  instead the partition <code>vendor_a</code> or <code>vendor_b</code> will be
  selected and mounted on the <code>/vendor</code> mount point.
</p>

<h3 id="kernel-slot-arguments">Kernel slot arguments</h3>

<p>
  The current slot suffix should be passed either through a specific DT node
  (<code>/firmware/android/slot_suffix</code>) or through the
  <code>androidboot.slot_suffix</code> command line argument.
</p>

<p>By default, fastboot will flash just slot 'a' on an A/B device, and set the
current slot to 'a'. An update package can contain images for slot 'b' too, in
which case they will also be flashed. A new '--slot' option lets you ask
fastboot to use slot 'b' instead of slot 'a', and the '--set-active' option
lets you set that slot as active too. There's also a new 'fastboot set_active'
command. See 'fastboot --help' for more details.</p>

<p>
  Optionally, if the bootloader implements fastboot, the following commands and
  variables should be supported:
</p>

<h4>Commands</h4>
<ul>
  <li>
    <code>set_active &lt;slot&gt;</code> —Sets the current active slot to
    the given slot. This must also clear the unbootable flag for that slot, and
    reset the retry count to default values.
  </li>
</ul>

<h4>Variables</h4>
<ul>
  <li>
    <code>has-slot:&lt;partition-base-name-without-suffix&gt;</code>
      —Returns “yes” if the given partition supports slots, “no” otherwise.
  </li>
  <li>
    <code>current-slot</code> —Returns the slot suffix that will be booted from
    next.
  </li>
  <li>
    <code>slot-count</code> —Returns an integer representing the number of
    available slots. Currently, two slots are supported so this value is
    <code>2</code>.
  </li>
  <li>
    <code>slot-successful:&lt;slot-suffix&gt;</code> —Returns "yes" if the given
    slot has been marked as successfully booting, "no" otherwise.
  </li>
  <li>
    <code>slot-unbootable:&lt;slot-suffix&gt;</code> —Returns “yes” if the given
    slot is marked as unbootable, "no" otherwise.
  </li>
  <li>
    <code>slot-retry-count:<slot suffix></code> —Number of retries remaining to
    attempt to boot the given slot.
  </li>
  <li>
    These variables should all appear under the following:
    <code>fastboot getvar all</code>
  </li>
</ul>

<h3 id="ota-package-generation">OTA package generation</h3>

<p>
  The <a href="/devices/tech/ota/tools.html">OTA package tools</a>
  follow the same commands as the commands for non-A/B devices. The
  <code>target_files.zip</code> file must be generated by defining the build
  variables for the A/B target. The OTA package tools automatically identify and
  generate packages in the format for the A/B updater.
</p>

<p>
  For example, use the following to generate a full OTA:
</p>

<pre class="devsite-terminal devsite-click-to-copy">
./build/tools/releasetools/ota_from_target_files \
  dist_output/tardis-target_files.zip ota_update.zip
</pre>

<p>
  Or, generate an incremental OTA:
</p>

<pre class="devsite-terminal devsite-click-to-copy">
./build/tools/releasetools/ota_from_target_files \
  -i PREVIOUS-tardis-target_files.zip \
  dist_output/tardis-target_files.zip incremental_ota_update.zip
</pre>

<h2 id="configuration">Configuration</h2>

<h3 id="config-partitions">Partitions</h3>

<p>
  The Update Engine can update any pair of A/B partitions defined in the same
  disk.
</p>

<p>
  A pair of partitions has a common prefix (such as <code>system</code> or
  <code>boot</code>) and per-slot suffix (such as <code>_a</code>). The list of
  partitions for which the payload generator defines an update is configured by
  the <code>AB_OTA_PARTITIONS</code> make variable. For example, if a pair of
  partitions <code>bootloader_a</code> and <code>booloader_b</code> are included
  (<code>_a</code> and <code>_b</code> are the slot suffixes), these partitions
  can be updated by specifying the following on the product or board
  configuration:
</p>

<pre class="devsite-click-to-copy">
AB_OTA_PARTITIONS := \
  boot \
  system \
  bootloader
</pre>

<p>
  All the partitions updated by the Update Engine must not be modified by the
  rest of the system. During incremental or <em>delta</em> updates, the binary
  data from the current slot is used to generate the data in the new slot. Any
  modification may cause the new slot data to fail verification during the
  update process, and therefore fail the update.
</p>

<h3 id="post-install">Post-install</h3>

<p>
  The post-install step can be configured differently for each updated partition
  using a set of key-value pairs.
</p>

<p>
  To run a program located at <code>/system/usr/bin/postinst</code> in a
  new image, specify the path relative to the root of the filesystem in the
  system partition. For example, <code>usr/bin/postinst</code> is
  <code>system/usr/bin/postinst</code> (if not using a RAM disk). Additionally,
  specify the filesystem type to pass to the <code>mount(2)</code> system call.
  Add the following to the product or device <code>.mk</code> files (if
  applicable):
</p>

<pre class="devsite-click-to-copy">
AB_OTA_POSTINSTALL_CONFIG += \
  RUN_POSTINSTALL_system=true \
  POSTINSTALL_PATH_system=usr/bin/postinst \
  FILESYSTEM_TYPE_system=ext4
</pre>

<h3 id="compilation">Compilation</h3>
<p>Minimally, you must compile ahead of time odex files for system_server and
its dependencies (because system_server isn't allowed to JIT for security
reasons); but anything else is optional.</p>

<p>Compiling apps in the background for A/B updates requires the following two
  additions to the product's device configuration (in the product's device.mk):</p>

<ol>
  <li>Include the native components in the build. This ensures the compilation
  script and binaries are compiled and included in the system image.
<pre class="devsite-click-to-copy">
  # A/B OTA dexopt package
  PRODUCT_PACKAGES += otapreopt_script
</pre>
  </li>
  <li>Connect the compilation script to <code>update_engine</code> such that it
  is run as a post-install step.
<pre class="devsite-click-to-copy">
  # A/B OTA dexopt update_engine hookup
  AB_OTA_POSTINSTALL_CONFIG += \
    RUN_POSTINSTALL_system=true \
    POSTINSTALL_PATH_system=system/bin/otapreopt_script \
    FILESYSTEM_TYPE_system=ext4 \
    POSTINSTALL_OPTIONAL_system=true
  </pre>
  </li>
</ol>

<p>See <a href="/devices/tech/dalvik/configure.html#other_odex">First
boot installation of DEX_PREOPT files</a> to install the preopted files in the
unused second system partition.</p>

<h2>Frequently asked questions </h2>

<h3>Has Google used A/B OTAs on any devices?</h3>

<p>Yes. The marketing name for this feature is <em>seamless updates</em>. The
Pixel and Pixel XL phones from October 2016 shipped with A/B. Additionally, all
Chromebooks use the same <code>update_engine</code> implementation of A/B. The
necessary platform code implementation is public in Android 7.1 and later.</p>

<h3>Why are A/B OTAs better?</h3>

<p>As the name of seamless updates implies, A/B OTAs provide a
better user experience when taking updates. Measurements from monthly
security updates show this feature has already proven a success: As of May
2017, 95% of Pixel owners are running the latest security update after a month
compared to 87% of Nexus users, and the Pixel users update sooner than Nexus
users would. Failures to update blocks during an OTA no longer result in a
device that won't boot; until the new system image has successfully booted,
Android retains the ability to fall back to the previous working system image.</p>

<h3>How did A/B affect the 2016 Pixel partition sizes?</h3>

<p>See the following table for the shipping A/B configuration versus the internally-tested non-A/B configuration:</p>

<table>
  <tbody>
    <tr>
      <th>Pixel partition sizes</th>
      <th>A/B</th>
      <th>Non-A/B</th>
    </tr>
    <tr>
      <td>Bootloader</td>
      <td>50*2</td>
      <td>50</td>
    </tr>
    <tr>
      <td>Boot</td>
      <td>32*2</td>
      <td>32</td>
    </tr>
    <tr>
      <td>Recovery</td>
      <td>0</td>
      <td>32</td>
    </tr>
    <tr>
      <td>Cache</td>
      <td>0</td>
      <td>100</td>
    </tr>
    <tr>
      <td>Radio</td>
      <td>70*2</td>
      <td>70</td>
    </tr>
    <tr>
      <td>Vendor</td>
      <td>300*2</td>
      <td>300</td>
    </tr>
    <tr>
      <td>System</td>
      <td>2048*2</td>
      <td>4096</td>
    </tr>
    <tr>
      <td><strong>Total</strong></td>
      <td><strong>5000</strong></td>
      <td><strong>4680</strong></td>
    </tr>
  </tbody>
</table>

<p>Therefore, A/B updates require an increase of only 320 MiB in flash.
Savings of 32MiB come from removing the recovery partition, while another
100MiB is preserved by removing the cache partition.</p>

<p>This roughly balanced out the cost of the B partitions for the bootloader, the
boot partition, and the radio partition. The vendor partition doubled in size.
(This was the vast majority of the size increase.) Pixel's A/B system image is
half the size of the original non-A/B system image.</p>

<p>So for Pixel, the A/B and non-A/B variants tested internally (only A/B
shipped), the space used differed by only 320MiB. On a 32GiB device, this is
just under 1%. For a 16GiB device this would be less than 2%, and for an 8GiB
device almost 4% (assuming all three devices had the same system image).</p>

<h3>Why didn't you use SquashFS?</h3>

<p>Android did experiment with SquashFS but wasn't able to achieve the
performance desired for a high-end device. Android doesn't use or recommend
SquashFS for handheld devices.</p>

<p>
  SquashFS provided about 50% size savings on the system partition, but the
  overwhelming majority of the files that compressed well were the precompiled
  .odex files. Those files had very high compression ratios (approaching 80%),
  but the compression ratio for the rest of the system partition was much
  lower.</p>

<p>And there were serious concerns about performance with SquashFS in N:</p>

<ul>
  <li>Pixel has very fast flash compared to earlier devices but not a huge
    number of spare CPU cycles, so reading fewer bytes from flash but needing
    more CPU for I/O was a potential bottleneck.</li>
  <li>I/O changes that perform well on an artificial benchmark run on an
    unloaded system sometimes don't work well on real-world use cases under
    real-world load (such as crypto on Nexus 6).</li>
  <li>Benchmarking showed 85% regressions in some places. As SquashFS matures
    and adds features to reduce CPU impact (such as a whitelist of
    commonly-accessed files that shouldn't be compressed), the Android team
    will continue to evaluate SquashFS and then offer recommendations to
    device manufacturers.</li>
</ul>

<h3>How did you halve the size of the system partition without SquashFS?</h3>

<p>Applications are stored in .apk files, which are actually ZIP archives. Each
.apk file has inside it one or more .dex files containing portable Dalvik
bytecode. An .odex file (optimized .dex) lives separately from the apk file
and can contain machine code specific to the device. If an odex file is
available, Android can run applications at ahead-of-time compiled speeds
without having to wait for the code to be compiled each time the application is
launched. An odex file isn't strictly necessary: Android can actually run the
.dex code directly via interpretation or Just-In-Time (JIT) compilation, but an
odex file provides the best combination of launch speed and run-time speed if
space is available.</p>

<p>If you look at the installed-files.txt from a Nexus 6P N MR1 build, where
the total system image size is 2628MiB (2755792836 bytes), the breakdown of the
largest contributors to overall system image size by file type looks like
this:</p>

<table class="style0">
<tbody>
<tr>
<td>.odex</td>
<td>1391770312 bytes</td>
<td>50.5%</td>
</tr>
<tr>
<td>.apk</td>
<td>846878259 bytes</td>
<td>30.7%</td>
</tr>
<tr>
<td>.so (native C/C++ code)</td>
<td>202162479 bytes</td>
<td>7.3%</td>
</tr>
<tr>
<td>.oat files/.art images</td>
<td>163892188 bytes</td>
<td>5.9%</td>
</tr>
<tr>
<td>Fonts</td>
<td>38952361 bytes</td>
<td>1.4%</td>
</tr>
<tr>
<td>icu locale data</td>
<td>27468687 bytes</td>
<td>0.9%</td>
</tr>
</tbody>
</table>

<p>These figures are similar for other devices too, so on Nexus/Pixel
devices, odex files take up roughly half of the system partition. This meant
that we could continue to use ext4 but write the odex files to the B partition
at the factory and then copy them to <code>/data</code> on first boot. The
actual storage used on Marlin/Sailfish with ext4 A/B is identical to SquashFS
A/B, because if we'd used SquashFS we would have shipped the preopted odex
files on system_a instead of system_b.</p>

<h3>Doesn't copying odex files to /data mean that the space saved on system
  is lost on data?</h3>

<p>Not exactly. On Pixel, most of the space taken by odex files are for apps.
These typically exist on <code>/data</code> anyway. Since apps take Google
Play updates, the apk and odex files on the system image are unused for
most of the life of the device. So these files can be excluded entirely and
replaced by small profile-driven odex files when the user actually uses each
app and requiring no space for apps the user doesn't use. (This was discussed
       at Google I/O 2016 in <a
  href="https://www.youtube.com/watch?v=fwMM6g7wpQ8">The Evolution of Art</a>.</p>

<p>These are the key reasons why comparison is difficult:</p>
<ul>
  <li>Apps updated by Google Play have always had their odex files on <code>/data</code> as soon as they receive their first update.</li>
<li>Apps that the user doesn't run don't need an odex file at all.</li>
<li>Profile-driven compilation generates smaller odex files than ahead-of-time
  compilation (because the former optimizes only performance-critical
  code).</li>
</ul>

<p>The <a href="/devices/tech/dalvik/configure.html">Configuring ART</a>
documentation explains the tuning options available to the OEM.</p>

<h3>Aren't there two copies of the odex files on /data?</h3>

<p>It's a little more complicated than that...<br>
After the new system image has been written, the new version of dex2oat is run
against the new dex files to generate the new odex files. This happens while
the old system is still running, and so the old and new odex files are both on
<code>/data</code> at the same time.</p>

<p>The code in OtaDexoptService (<a
  href="https://android.googlesource.com/platform/frameworks/base/+/nougat-mr1-release/services/core/java/com/android/server/pm/OtaDexoptService.java#200">/platform/frameworks/base/+/nougat-mr1-release/services/core/java/com/android/server/pm/OtaDexoptService.java#200</a>)
calls <code>getAvailableSpace</code> before optimizing each package to avoid
over-filling <code>/data</code>. Note that <em>available</em> here is still
conservative: it's the amount of space left <em>before</em> hitting the usual
system low space threshold (measured as both a percentage and a byte count). So
if <code>/data</code> is full, there won't be two copies of every odex file.<br>
The same code also has a BULK_DELETE_THRESHOLD: if the device gets that close
to filling the available space (as just described), the odex files belonging to
apps that aren't used are removed. That's another case without two copies of
every odex file.</p>

<p>In the worst case where <code>/data</code> is completely full, the update waits
until the device has rebooted into the new system and no longer need the old
system's odex files.</p>

<p>The PackageManager handles this: (<a
  href="https://android.googlesource.com/platform/frameworks/base/+/nougat-mr1-release/services/core/java/com/android/server/pm/PackageManagerService.java#7215">/platform/frameworks/base/+/nougat-mr1-release/services/core/java/com/android/server/pm/PackageManagerService.java#7215</a>).</p>

<p>Once the new system has successfully booted, <code>installd</code> (<a
  href="https://android.googlesource.com/platform/frameworks/native/+/nougat-mr1-release/cmds/installd/commands.cpp#2192">/platform/frameworks/native/+/nougat-mr1-release/cmds/installd/commands.cpp#2192</a>)
can remove the odex files that were used by the old system, returning the
device back to the steady state where there's only one copy.</p>

<p>So to return to the original question: it is possible that
<code>/data</code> contains two copies of all the odex files, but (a) only
temporarily and (b) only if you had plenty of free space on <code>/data</code>
anyway. Except during an update, there's only one copy. And as part of ART's
general robustness features, it will never fill <code>/data</code> with odex
files anyway (because that would be a problem on a non-A/B system too).</p>

<h3>Doesn't all this writing/copying increase flash wear?</h3>

<p>Only a small portion of flash is rewritten: a full Pixel system update
writes about 2.3GiB. (Apps are also recompiled, but that's true of non-A/B
too.) Traditionally, block-based full OTAs wrote a similar amount of data, so
flash wear rates should be similar.</p>

<h3>Does flashing two system partitions increase factory flashing time?</h3>

<p>Pixel didn't increase in system image size (it merely divided the space
across two partitions). So no, factory flashing time did not grow.</p>

<h3>Doesn't keeping odex files on B make rebooting after factory data reset slow?</h3>

<p>Yes. If you've actually used a device and taken an OTA and then perform a
factory data reset, the first reboot will be slower than it would otherwise be
(taking 1m40s vs 40s on a Pixel XL just tested) because the odex files will
have been lost from B after the first OTA and so can't be copied to
<code>/data</code>. That's the trade-off.</p>

<p>Factory data reset should be a rare operation - certainly
compared to regular boot - so the time taken is less important. (This doesn't
affect users or reviewers who get their device from the factory, because in
that case the B partition is available.) Thanks to the JIT compiler, we also
don't need to recompile <em>everything</em>, so it's not as bad as you might
think. It's also possible to mark apps as requiring ahead-of-time compilation
using <code>coreApp="true"</code> in the manifest: (<a
  href="https://android.googlesource.com/platform/frameworks/base/+/nougat-mr1-release/packages/SystemUI/AndroidManifest.xml#23">/platform/frameworks/base/+/nougat-mr1-release/packages/SystemUI/AndroidManifest.xml#23</a>)</p>

<p>This is currently used by system_server because it's not allowed to JIT for
security reasons.</p>

<h3>Doesn't keeping odex files on /data rather than /system make rebooting
  after an OTA slow?</h3>

<p>No. As explained above, the new dex2oat is run while the old system image is
still running to generate the files that will be needed by the new system. The
update isn't considered available until that work has been done.</p>

<h3>Can (should) we ship a 32GiB A/B device? 16GiB? 8GiB?</h3>

<p>32GiB works well as it was proven on Pixel, and 320MiB out of 16GiB means a
reduction of 2%. Similarly, 320MiB out of 8GiB a reduction of 4%. Obviously
A/B, would not be the recommended choice on devices with 4GiB, as the 320MiB
overhead is almost 10% of the total available space.</p>

<h3>Does AVB2.0 require A/B OTAs?</h3>

<p>No. Android <a href="/security/verifiedboot/">Verified Boot</a> has always required block-based
updates, but not necessarily A/B updates.</p>

<h3>Do A/B OTAs require AVB2.0?</h3>

<p>No.</p>

<h3>Do A/B OTAs break AVB2.0's rollback protection?</h3>

<p>No. There's some confusion here because if an A/B system fails to boot into
the new system image it will (after some number of retries determined by your
bootloader) automatically revert to the "previous" system image. The key point
here though is that "previous" in the A/B sense is actually still the "current"
system image. As soon as the device successfully boots a new image, rollback
protection kicks in and ensures that you can't go back. But until you've
actually successfully booted the new image, rollback protection doesn't
consider it to be the current system image.</p>

<h3>If you're installing an update while the system is running, isn't that
  slow?</h3>

<p>With non-A/B updates, the aim is to install the update as quickly as
possible because the user is waiting and unable to use their device while the
update is applied. With A/B updates, the opposite is true; because the user is
still using their device, as little impact as possible is the goal, so the update
is deliberately slow. Android also (via logic in the Java system update client, in
Google’s case GmsCore, the core package provided by GMS) try to choose a time
when the users aren't using their devices at all. The platform supports
pausing/resuming the update, and the client can use that to pause the update if
the user starts to use the device and resume it when the device is idle
again.</p>

<p>There are two phases while taking an OTA, shown clearly in the UI as
<em>Step 1 of 2</em> and <em>Step 2 of 2</em> under the progress bar. Step 1
corresponds with writing the data blocks, while step 2 is pre-compiling the
.dex files. These two phases are quite different in terms of performance
impact. The first phase is simple I/O. This requires little in the way of
resources (RAM, CPU, I/O) because it's just slowly copying blocks around.</p>

<p>The second phase runs dex2oat to precompile the new system image. This
obviously has less clear bounds on its requirements because it compiles actual
apps. And there's obviously much more work involved in compiling a large and
complex app than a small and simple app; whereas in phase 1 there are no disk
blocks that are larger or more complex than others.</p>

<p>The process is similar to when Google Play installs an app update in the
background before showing the <em>5 apps updated</em> notification, as has been
done for years.</p>

<h3>What if a user is actually waiting for the update?</h3>

<p>The current implementation in GmsCore doesn't distinguish between background
updates and user-initiated updates but may do so in the future. In the case
where the user explicitly asked for the update to be installed or is watching
the update progress screen, we'll prioritize the update work on the assumption
that they're actively waiting for it to finish.</p>

<h3>What happens if there's a failure to apply an update?</h3>

<p>With non-A/B updates, if an update failed to apply, the user was usually
left with an unusable device. The only exception was if the failure occurred
before an application had even started (because the package failed to verify,
say). With A/B updates, a failure to apply an update does not affect the
currently running system. The update can simply be retried later.</p>

<h3>What does GmsCore do?</h3>

<p>In Google's A/B implementation, the platform APIs and
<code>update_engine</code> provide the mechanism while GmsCore provides the
policy. That is, the platform knows <em>how</em> to apply an A/B update, and
all that code is in AOSP (as mentioned above); but it's GmsCore that decides
<em>what</em> and <em>when</em> to apply.</p>

<p>If you’re not using GmsCore, you can write your own replacement using the same
platform APIs. The platform Java API for controlling update_engine is <code>android.os.UpdateEngine</code>:</p>
<a
  href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/os/UpdateEngine.java">/platform/frameworks/base/core/java/android/os/UpdateEngine.java</a>

<p>Callers can provide an <code>UpdateEngineCallback</code> to be notified of
status updates:</p>
<a
  href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/os/UpdateEngineCallback.java">/platform/frameworks/base/+/master/core/java/android/os/UpdateEngineCallback.java</a>

<p>See the reference files for the core classes to use the interface.</p>

<h3>Which systems on a chip (SoCs) support A/B?</h3>

<p>As of 2017-03-15, we have the following information:</p>
<table class="style0">
<tbody>
<tr>
<td></td>
<td><strong>N Release</strong></td>
<td><strong>OC Release</strong></td>
</tr>
<tr>
<td><strong>Qualcomm</strong></td>
<td>Depending on OEM requests </td>
<td>All chipsets will get support</td>
</tr>
<tr>
<td><strong>Mediatek</strong></td>
<td>Depending on OEM requests</td>
<td>All chipsets will get support</td>
</tr>
</tbody>
</table>

<p>Please check with your SoC contacts for more details on their schedules. If
there are SoCs not listed here, please reach out your SoC directly. </p>

  </body>
</html>
