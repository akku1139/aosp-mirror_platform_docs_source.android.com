tallBegin()</code></dt>
<dd>Called after files to be patched have been verified as having the expected
<i>before</i> state but before any changes have been made. You can emit
commands for device-specific updates that must run before anything else on the
device has been changed.</dd>
<dt><code>IncrementalOTA_InstallEnd()</code></dt>
<dd>Similar to its full OTA package counterpart, this is called at the end of
the script generation, after the script commands to update the boot and system
partitions have been emitted. You can also emit additional commands for
device-specific updates.</dd>
</dl>

<p class="note"><strong>Note:</strong> If the device loses power, OTA
installation may restart from the beginning. Be prepared to cope with devices
on which these commands have already been run, fully or partially.</p>

<h4 id="pass-functions-to-info">Pass functions to info objects</h4>
<p>Pass functions to a single info object that contains various useful items:
</p>
<ul>
<li><b>info.input_zip</b>. (Full OTAs only) The <code>zipfile.ZipFile</code>
object for the input target-files .zip.</li>
<li><b>info.source_zip</b>. (Incremental OTAs only) The <code>zipfile.ZipFile
</code> object for the source target-files .zip (the build already on the
device when the incremental package is being installed).</li>
<li><b>info.target_zip</b>. (Incremental OTAs only) The <code>zipfile.ZipFile
</code> object for the target target-files .zip (the build the incremental
package puts on the device).</li>
<li><b>info.output_zip</b>. Package being created; a <code>zipfile.ZipFile
</code> object opened for writing. Use common.ZipWriteStr(info.output_zip,
<i>filename</i>, <i>data</i>) to add a file to the package.</li>
<li><b>info.script</b>. Script object to which you can append commands. Call
<code>info.script.AppendExtra(<i>script_text</i>)</code> to output text into
the script. Make sure output text ends with a semicolon so it does not run
into commands emitted afterwards.</li>
</ul>

<p>For details on the info object, refer to the
<a href="http://docs.python.org/library/zipfile.html">Python Software Foundation
documentation for ZIP archives</a>.</p>

<h4 id="specify-module-location">Specify module location</h4>
<p>Specify the location of your device's releasetools.py script in your
BoardConfig.mk file:</p>

<p><code>device/yoyodyne/tardis/BoardConfig.mk</code></p>

<pre>
 [...]

TARGET_RELEASETOOLS_EXTENSIONS := device/yoyodyne/tardis
</pre>

<p>If TARGET_RELEASETOOLS_EXTENSIONS is not set, it defaults to the <code>
$(TARGET_DEVICE_DIR)/../common</code> directory (<code>device/yoyodyne/common
</code> in this example). It's best to explicitly define the location of the
releasetools.py script. When building the tardis device, the releasetools.py
script is included in the target-files .zip file (<code>META/releasetools.py
</code>).</p>
<p>When you run the release tools (either <code>img_from_target_files</code>
or <code>ota_from_target_files</code>), the releasetools.py script in the
target-files .zip, if present, is preferred over the one from the Android
source tree. You can also explicitly specify the path to the device-specific
extensions with the <code>-s</code> (or <code>--device_specific</code>)
option, which takes the top priority. This enables you to correct errors and
make changes in the releasetools extensions and apply those changes to old
target-files.</p>
<p>Now, when you run <code>ota_from_target_files</code>, it automatically
picks up the device-specific module from the target_files .zip file and uses
it when generating OTA packages:</p>

<pre>
% <b>./build/tools/releasetools/ota_from_target_files \
    -i PREVIOUS-tardis-target_files.zip \
    dist_output/tardis-target_files.zip incremental_ota_update.zip</b>
unzipping target target-files...
<b>using device-specific extensions from target_files</b>
unzipping source target-files...
   [...]
done.
</pre>

<p>Alternatively, you can specify device-specific extensions when you run
<code>ota_from_target_files</code>.</p>

<pre>
% <b>./build/tools/releasetools/ota_from_target_files \
    -s device/yoyodyne/tardis \  # specify the path to device-specific extensions
    -i PREVIOUS-tardis-target_files.zip \
    dist_output/tardis-target_files.zip incremental_ota_update.zip</b>
unzipping target target-files...
<b>loaded device-specific extensions from device/yoyodyne/tardis</b>
unzipping source target-files...
   [...]
done.
</pre>

<p class="note"><strong>Note:</strong> For a complete list of options, refer
to the <code>ota_from_target_files</code> comments in <code>
build/tools/releasetools/ota_from_target_files</code>.</p>


<h2 id="sideloading">Sideloading</h2>
<p>Recovery has a <b>sideloading</b> mechanism for manually installing an
update package without downloading it over-the-air by the main system.
Sideloading is useful for debugging or making changes on devices where the
main system can't be booted.</p>
<p>Historically, sideloading has been done through loading packages off the
device's SD card; in the case of a non-booting device, the package can be put
onto the SD card using some other computer and then the SD card inserted into
the device. To accommodate Android devices without removable external storage,
recovery supports two additional mechanisms for sideloading: loading packages
from the cache partition, and loading them over USB using adb.</p>
<p>To invoke each sideload mechanism, your device's <code>
Device::InvokeMenuItem()</code> method can return the following values of
BuiltinAction:</p>

<ul>
<li><b>APPLY_EXT</b>. Sideload an update package from external storage (<code>
/sdcard</code> directory). Your recovery.fstab must define the <code>/sdcard
</code> mount point. This is not usable on devices that emulate an SD card
with a symlink to <code>/data</code> (or some similar mechanism). <code>/data
</code> is typically not available to recovery because it may be encrypted.
The recovery UI displays a menu of .zip files in <code>/sdcard</code> and
allows the user to select one.</li>
<li><b>APPLY_CACHE</b>. Similar to loading a package from <code>/sdcard</code>
except that the <code>/cache</code> directory (which <i>is</i> always
available to recovery) is used instead. From the regular system, <code>/cache
</code> is only writable by privileged users, and if the device isn't bootable
then the <code>/cache</code> directory can't be written to at all (which makes
this mechanism of limited utility).</li>
<li><b>APPLY_ADB_SIDELOAD</b>. Allows user to send a package to the device via
a USB cable and the adb development tool. When this mechanism is invoked,
recovery starts up its own mini version of the adbd daemon to let adb on a
connected host computer talk to it. This mini version supports only a single
command: <code>adb sideload <i>filename</i></code>. The named file is sent
from the host machine to the device, which then verifies and installs it just
as if it had been on local storage.</li>
</ul>

<p>A few caveats:</p>
<ul>
<li>Only USB transport is supported.</li>
<li>If your recovery runs adbd normally (usually true for userdebug and eng
builds), that will be shut down while the device is in adb sideload mode and
will be restarted when adb sideload has finished receiving a package. While in
adb sideload mode, no adb commands other than <code>sideload</code> work (
<code>logcat</code>, <code>reboot</code>, <code>push</code>, <code>pull</code>
, <code>shell</code>, etc. all fail).</li>
<li>You cannot exit adb sideload mode on the device. To abort, you can send
<code>/dev/null</code> (or anything else that's not a valid package) as the
package, and then the device will fail to verify it and stop the installation
procedure. The RecoveryUI implementation's <code>CheckKey()</code> method
will continue to be called for keypresses, so you can provide a key sequence
that reboots the device and works in adb sideload mode.</li>
</ul>
  </body>
</html>
