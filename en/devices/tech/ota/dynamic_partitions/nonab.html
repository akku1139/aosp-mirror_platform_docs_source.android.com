<html devsite>
  <head>
    <title>OTA for non-A/B Devices without Dynamic Partitions</title>
    <meta name="project_path" value="/_project.yaml" />
    <meta name="book_path" value="/_book.yaml" />
  </head>
  <body>
  <!--
      Copyright 2019 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

  {% include "_versions.html" %}

    <p>
      Android {{ androidQVersionNumber }} supports dynamic partitions, a
      userspace partitioning system that can create, resize, and destroy
      partitions during an OTA update. This document describes how OTA clients
      resize dynamic partitions during an update for non-A/B devices.
    </p>

    <p>
      For non-A/B devices, the OTA update for dynamic partitions is applied
      using the <code>updater</code> inside the update package.
    </p>

    <h2 id="updating-launch-devices">Updating launch devices</h2>

      <p>
        This section applies to non-A/B devices that launch with dynamic
        partitions support; these devices upgrade from Android
        {{ androidQVersionNumber }} to later releases.
      </p>

      <h3 id="generating-update-packages">Generating update packages</h3>

        <p>
          OTA update packages are generated by the
          <code>ota_from_target_files</code> script, located under
          <code>build/make/tools/releasetools</code>. By default, the script
          generates a package that updates <code>system</code> and
          <code>vendor</code> partitions. If there are additional dynamic
          partitions, such as <code>product</code>,
          <code>product_services</code>, or <code>odm</code>, their
          updates must be generated in
          <a href="/devices/tech/ota/nonab/device_code#ota-package-generation">device-specific
          code</a>.
        </p>

        <p>
          To generate updates, in the extended Python module, implement
          <code>FullOTA_GetBlockDifferences()</code> and
          <code>IncrementalOTA_GetBlockDifferences()</code>. These two
          functions return a list of <code>BlockDifference</code> objects,
          each describing the update patch that would be applied on a
          partition. Partitions returned by these two functions should not be
          modified manually or verified elsewhere, for example in
          <code>*_InstallBegin()</code> or <code>*_InstallEnd()</code>.
        </p>

        <p>
          Example of an update generation:
        </p>

<pre class="prettyprint">
# device/yoyodyne/tardis/releasetools.py

import os
from common import BlockDifference, EmptyImage, GetUserImage

# The joined list of user image partitions of source and target builds.
# - Items should be added to the list if new dynamic partitions are added.
# - Items should not be removed from the list even if dynamic partitions are
#   deleted. When generating an incremental OTA package, this script needs to
#   know that an image is present in source build but not in target build.
USERIMAGE_PARTITIONS = [
    "product",
    "odm",
]

def GetUserImages(input_tmp, input_zip):
  return {partition: GetUserImage(partition, input_tmp, input_zip)
          for partition in USERIMAGE_PARTITIONS
          if os.path.exists(os.path.join(input_tmp,
                                         "IMAGES", partition + ".img"))}

def FullOTA_GetBlockDifferences(info):
  images = GetUserImages(info.input_tmp, info.input_zip)
  return [BlockDifference(partition, image)
          for partition, image in images.items()]

def IncrementalOTA_GetBlockDifferences(info):
  source_images = GetUserImages(info.source_tmp, info.source_zip)
  target_images = GetUserImages(info.target_tmp, info.target_zip)

  # Use EmptyImage() as a placeholder for partitions that will be deleted.
  for partition in source_images:
    target_images.setdefault(partition, EmptyImage())

  # Use source_images.get() because new partitions are not in source_images.
  return [BlockDifference(partition, target_image, source_images.get(partition))
          for partition, target_image in target_images.items()]
</pre>

      <h3 id="update-flow">Update flow</h3>

        <p>
          Behind the scenes, the following functions are added to the edify
          script:
        </p>

        <ul>
          <li><code>unmap_partition(name)</code>
            <ul>
              <li>Unmap the partition if mapped, otherwise do nothing.</li>
              <li>Return the string <code>t</code> on success, or an empty
                string on failure.</li>
            </ul>
          </li>
          <li><code>map_partition(name)</code>
            <ul>
              <li>Map the partition if not already mapped.</li>
              <li>
                Return the absolute path of the mapped block device on success,
                or an empty string on failure.
              </li>
            </ul>
          </li>
          <li><code>update_dynamic_partitions(op_list)</code>
            <ul>
              <li>
                Apply the given operation list on dynamic partition metadata,
                unmapping partitions if necessary.
              </li>
              <li>
                Return <code>t</code> on success, or an empty string on failure.
              </li>
            </ul>
          </li>
        </ul>

        <p>
          The <code>op_list</code> argument to
          <code>update_dynamic_partitions</code> points to a file in the
          update package. Each line in the file specifies an operation. If any
          operation fails, <code>update_dynamic_partitions</code> immediately
          returns an empty string. The operations are:
        </p>

        <ul>
          <li><code>resize <var>partition-name</var> <var>size</var></code>
            <ul>
              <li>Unmap the partition, then resize it to <var>size</var>.</li>
            </ul>
          </li>
          <li><code>remove <var>partition_name</var></code>
            <ul>
              <li>Unmap the partition, then remove it.</li>
            </ul>
          </li>
          <li><code>add <var>partition-name</var> <var>group-name</var></code>
            <ul>
              <li>Add a new partition to the specified group.</li>
              <li>
                Abort if the group doesn't exist or if the partition already
                exists.
              </li>
            </ul>
          </li>
          <li><code>move <var>partition-name</var> <var>group-name</var></code>
            <ul>
              <li>Move the partition to the specified group.</li>
              <li>
                Abort if the group does not exist or partition does not exist.
              </li>
            </ul>
          </li>
          <li>
            <code>add_group <var>group-name</var> <var>maximum-size</var></code>
            <ul>
              <li>Add a group with the given name and maximum size.</li>
              <li>Abort if the group already exists.</li>
              <li>
                A <var>maximum_size</var> of 0 means there are no size limits
                on partitions in the group. Additional testing is required to
                ensure that partitions in the group don't exceed the
                available space on the device.
              </li>
            </ul>
          </li>
          <li>
            <code>resize_group <var>group-name</var> <var>maximum-size</var></code>
            <ul>
              <li>Resize the group to the given maximum size.</li>
              <li>Abort if group doesn't exist.</li>
              <li>
                A <var>maximum_size</var> of 0 means there are no size limits
                on partitions in the group. Additional testing is required to
                ensure that partitions in the group don't exceed the
                available space on the device.
              </li>
            </ul>
          </li>
          <li><code>remove_group <var>group-name</var></code>
            <ul>
              <li>Remove a group.</li>
              <li>Abort if there are partitions in the group.</li>
            </ul>
          </li>
          <li><code>remove_all_groups</code>
            <ul>
              <li>Unmap all partitions from the device mapper.</li>
              <li>Remove all partitions and groups.</li>
            </ul>
          </li>
        </ul>

        <h4 id="incremental-ota">Incremental OTA</h4>

          <p>
            Incremental OTA updates use the following logic:
          </p>

          <ol>
            <li>
              Shrink partitions / delete partitions / move partitions out of
              group (so that there is enough space to shrink groups)
            </li>
            <li>
              Shrink groups (so that we have enough space to grow groups)
            </li>
            <li>
              Grow groups (so that we have enough space to grow / add
              partitions)
            </li>
            <li>
              Grow partitions / add partitions / move partitions to new group
            </li>
          </ol>

          <p>
            In detail, <code>update-script</code> is generated with this
            logic:
          </p>


<pre class="prettyprint">
for each shrinking partition:
    block_image_update(map_partition(name), …)

update_dynamic_partitions(op_list)

for each growing / adding partition:
    block_image_update(map_partition(name), …)
</pre>

          <p>
            The <code>op_list</code> file for
            <code>update_dynamic_partitions</code> is generated with this
            logic:
          </p>

<pre class="prettyprint">
for each deleting partition:
    remove
for each partition that changes groups:
    move to "default"
for each shrinking partition:
    resize
for each shrinking / removing group:
    resize_group / remove_group
for each growing / adding group:
    resize_group / add_group
for each adding partition:
    add
for each growing / adding partition:
    resize
for each partition that changes groups:
    move to target group
</pre>

        <h4 id="full-ota">Full OTA</h4>

          <p>
            Full OTA updates use the following logic:
          </p>

          <ol>
            <li>Delete all existing groups and partitions</li>
            <li>Add groups</li>
            <li>Add partitions</li>
          </ol>

          <p>
            In detail, <code>update-script</code> is generated with this
            logic:
          </p>

<pre class="prettyprint">
update_dynamic_partitions(op_list)

for each adding partition:
    block_image_update(map_partition(name), …)
</pre>

          <p>
            The <code>op_list</code> file for
            <code>update_dynamic_partitions</code> is generated with this
            logic:
          </p>

<pre class="prettyprint">
remove_all_groups
for each adding group:
    add_group
for each adding partition:
    add
for each adding partition:
    resize
</pre>

  </body>
</html>
