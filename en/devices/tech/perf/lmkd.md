Project: /_project.yaml
Book: /_book.yaml

{% include "_versions.html" %}

<!--
  Copyright 2018 The Android Open Source Project

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

# lmkd in Userspace

This document describes the userspace lowmemorykiller daemon (`lmkd`) features
added in Android {{ androidPVersionNumber }} and how to configure them.

Historically, Android used in-kernel lowmemorykiller driver to handle memory
pressure situations by killing non-essential processes. This mechanism is rigid
and depends on hard-coded values. In addition, starting with kernel 4.12, the
lowmemorykiller driver is excluded from the upstream kernel.

The userspace `lmkd` process implements the same functionality but with already
existing kernel mechanisms to detect and estimate memory pressure. It uses
vmpressure events generated by the kernel to get notifications about memory
pressure levels.  It also can use memory cgroup features to limit memory resources
allocated to each process based on its importance.


## How to switch to userspace lmkd

Starting in Android {{ androidPVersionNumber }}, userspace `lmkd` activates if an
in-kernel lowmemorykiller driver is not detected. Note that userspace `lmkd`
requires kernel support for memory cgroups. Therefore, to switch to userspace
`lmkd` the kernel should be compiled with the following configuration  settings:

```
CONFIG_ANDROID_LOW_MEMORY_KILLER=n
CONFIG_MEMCG=y
CONFIG_MEMCG_SWAP=y
```

## lmkd kill strategies

`lmkd` supports new kill strategies based on vmpressure events, their severity,
and other hints like swap utilization, as well as legacy mode in which `lmkd`
makes kill decisions just as the kernel lowmemorykiller driver did.

New kill strategies differ for low-memory vs high-performance devices. In cases
of low-memory devices, the system should tolerate higher memory pressure as a
normal mode of operation; on high-performance devices, memory pressure should be
viewed as an abnormal situation that should be fixed before it affects overall
performance. The `ro.config.low_ram` property allows for choosing one mode over
the other. See [Low RAM Configuration](/devices/tech/perf/low-ram) for
instructions on setting this property.

In legacy mode, `lmkd` kill decisions are made based on free memory and file cache
thresholds. This mode is enabled by setting the `ro.lmk.use_minfree_levels`
property to `true`.


## Configuring lmkd for specific device

Configure `lmkd` with the following properties:

<table>
  <tr>
   <th>Property</th>
   <th>Use</th>
   <th>Default Value</th>
  </tr>
  <tr>
   <td><code>ro.config.low_ram</code>
   </td>
   <td>Choose between low-memory vs. high-performance device.
   </td>
   <td><code>false</code>
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.use_minfree_levels</code>
   </td>
   <td>Use free memory and file cache thresholds for making decisions when to
   kill. This mode works the same way kernel lowmemorykiller driver used to
   work.
   </td>
   <td><code>false</code>
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.low</code>
   </td>
   <td>The minimum oom_adj score for processes eligible to be killed at low
   vmpressure level.
   </td>
   <td><code>1001</code><br>
(disabled)
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.medium</code>
   </td>
   <td>The minimum oom_adj score for processes eligible to be killed at medium
   vmpressure level.
   </td>
   <td><code>800</code><br>
(cached or non-essential services)
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.critical</code>
   </td>
   <td>The minimum oom_adj score for processes eligible to be killed at critical
   vmpressure level.
   </td>
   <td><code>0</code><br>
(any process)
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.critical_upgrade</code>
   </td>
   <td>Enables upgrade to critical level.
   </td>
   <td><code>false</code>
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.upgrade_pressure</code>
   </td>
   <td>The maximum mem_pressure at which level will be upgraded because system
   is swapping too much.
   </td>
   <td><code>100</code><br>
(disabled)
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.downgrade_pressure</code>
   </td>
   <td>The minimum mem_pressure* at which vmpressure event will be ignored
   because enough free memory is still available.
   </td>
   <td><code>100</code><br>
(disabled)
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.kill_heaviest_task</code>
   </td>
   <td>Kill heaviest eligible task (best decision) vs. any eligible task (fast
   decision).</td>
   <td><code>true</code>
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.kill_timeout_ms</code>
   </td>
   <td>Duration in ms after a kill when no additional kill will be done.
   </td>
   <td><code>0</code><br>
(disabled)
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.debug</code>
   </td>
   <td>Enable <code>lmkd</code> debug logs.
   </td>
   <td><code>false</code>
   </td>
  </tr>
</table>

*Note: *mem_pressure = RAM usage / RAM_and_swap usage in %

Here is a device configuration example:

```
PRODUCT_PROPERTY_OVERRIDES += \
    ro.lmk.low=1001 \
    ro.lmk.medium=800 \
    ro.lmk.critical=0 \
    ro.lmk.critical_upgrade=false \
    ro.lmk.upgrade_pressure=100 \
    ro.lmk.downgrade_pressure=100 \
    ro.lmk.kill_heaviest_task=true
```
