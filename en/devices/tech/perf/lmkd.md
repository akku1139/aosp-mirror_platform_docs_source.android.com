Project: /_project.yaml
Book: /_book.yaml

{% include "_versions.html" %}

<!--
  Copyright 2018 The Android Open Source Project

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

# Low Memory Killer Daemon (lmkd)

The Android low memory killer daemon (`lmkd`) process monitors the memory
state of a running Android system and reacts to high memory pressure by killing
the least essential processes to keep system performing at acceptable levels.

## About memory pressure

An Android system running multiple processes in parallel may encounter
situations when system memory is exhausted and processes that require more
memory experience noticeable delays. *Memory pressure*, a state in which the
system is running short on memory, requires Android to free memory (to alleviate
the pressure) by throttling or killing unimportant processes, requesting
processes to free non-critical cached resources, and so on.

Historically, Android monitored system memory pressure using an in-kernel
lowmemorykiller driver, a rigid mechanism that depends on hard-coded values. As
of kernel 4.12, the lowmemorykiller driver has been removed from the upstream
kernel and a userspace `lmkd` performs memory monitoring and process killing
tasks.

## Userspace lmkd

The userspace `lmkd` implements the same functionality as the in-kernel driver
but uses existing kernel mechanisms to detect and estimate memory pressure. Such
mechanisms include using kernel-generated `vmpressure` events or pressure stall
information (PSI) monitors to get notifications about memory pressure levels,
and using memory cgroup features to limit the memory resources allocated to each
process based on process importance.

### Kill strategies

Userspace `lmkd` supports kill strategies based on `vmpressure` events or PSI
monitors, their severity, and other hints such as swap utilization. Kill
strategies differ between low-memory and high-performance devices:

* On low-memory devices, the system should tolerate higher memory pressure as a
  normal mode of operation.
* On high-performance devices, memory pressure should be viewed as an abnormal
  situation and fixed before it affects overall performance.

You can configure the kill strategy using the `ro.config.low_ram` property
(for details, see [Low RAM Configuration](/devices/tech/perf/low-ram)).

Userspace `lmkd` also supports a legacy mode in which it makes kill decisions
using the same strategies as the in-kernel lowmemorykiller driver (that is, free
memory and file cache thresholds). To enable legacy mode, set the
`ro.lmk.use_minfree_levels` property to `true`.

### Using userspace lmkd

In Android {{ androidPVersionNumber }} and higher, userspace `lmkd` activates if
an in-kernel lowmemorykiller driver is not detected. Because userspace `lmkd`
requires kernel support for memory cgroups, the kernel must be compiled with the
following configuration settings:

```
CONFIG_ANDROID_LOW_MEMORY_KILLER=n
CONFIG_MEMCG=y
CONFIG_MEMCG_SWAP=y
```
## Pressure stall information (PSI)

Android {{ androidQVersionNumber }} and higher support a new `lmkd` mode that
uses kernel pressure stall information (PSI) monitors for memory pressure
detection. The PSI patchset in the upstream kernel (backported to 4.9 and 4.14
kernels) measures the amount of time tasks are delayed as a result of memory
shortages. As these delays directly affect user experience, they represent a
convenient metric for determining memory pressure severity. The upstream kernel
also includes PSI monitors that allow privileged userspace processes (such as
`lmkd`) to specify thresholds for these delays and to subscribe to events from
the kernel when a threshold is breached.

### PSI monitors versus vmpressure signals

Because the `vmpressure` signals (generated by the kernel for memory
pressure detection and used by `lmkd`) often include numerous false positives,
`lmkd` must perform filtering to determine if the memory is under real pressure.
This results in unnecessary `lmkd` wakeups and use of additional computational
resources. Using PSI monitors results in a more accurate memory pressure
detection and minimizes filtering overhead.

### Using PSI monitors

To use PSI monitors instead of `vmpressure` events, configure the
`ro.lmk.use_psi` property. The default is `true`, making PSI monitors the
default mechanism of memory pressure detection for `lmkd`. Because PSI monitors
require kernel support, the kernel must include the PSI backport patches and be
compiled with PSI support enabled (`CONFIG_PSI=y`).


## Configuring lmkd

Configure `lmkd` for a specific device using the following properties.

<table>
  <tr>
   <th>Property</th>
   <th>Use</th>
   <th>Default</th>
  </tr>
  <tr>
   <td><code>ro.config.low_ram</code>
   </td>
   <td>Choose between low-memory versus high-performance device.
   </td>
   <td><code>false</code>
   </td>
  </tr>
  <tr>
    <td><code>ro.lmk.use_psi<code></td>
    <td>Use PSI monitors (instead of <code>vmpressure</code> events).</td>
    <td><code>true</code></td>
  </tr>
  <tr>
   <td><code>ro.lmk.use_minfree_levels</code>
   </td>
   <td>Use free memory and file cache thresholds for making process kill
       decisions (that is, match the functionality of the in-kernel
       lowmemorykiller driver.
   </td>
   <td><code>false</code>
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.low</code>
   </td>
   <td>The minimum <code>oom_adj</code> score for processes eligible to be
       killed at low <code>vmpressure</code> level.
   </td>
   <td><code>1001</code><br>(disabled)
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.medium</code>
   </td>
   <td>The minimum <code>oom_adj</code> score for processes eligible to be
       killed at medium <code>vmpressure</code> level.
   </td>
   <td><code>800</code><br>(cached or non-essential services)
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.critical</code>
   </td>
   <td>The minimum <code>oom_adj</code> score for processes eligible to be
      killed at critical <code>vmpressure</code> level.
   </td>
   <td><code>0</code><br>(any process)
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.critical_upgrade</code>
   </td>
   <td>Enable upgrade to critical level.
   </td>
   <td><code>false</code>
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.upgrade_pressure</code>
   </td>
   <td>The maximum <code>mem_pressure</code> at which the level is upgraded
       because the system is swapping too much.
   </td>
   <td><code>100</code><br>(disabled)
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.downgrade_pressure</code>
   </td>
   <td>The minimum <code>mem_pressure</code> at which a <code>vmpressure</code>
       event is ignored because enough free memory is still available.
   </td>
   <td><code>100</code><br>(disabled)
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.kill_heaviest_task</code>
   </td>
   <td>Kill heaviest eligible task (best decision) versus any eligible task
       (fast decision).</td>
   <td><code>true</code>
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.kill_timeout_ms</code>
   </td>
   <td>Duration in ms after a kill when no additional kill will be done.
   </td>
   <td><code>0</code><br>(disabled)
   </td>
  </tr>
  <tr>
   <td><code>ro.lmk.debug</code>
   </td>
   <td>Enable <code>lmkd</code> debug logs.
   </td>
   <td><code>false</code>
   </td>
  </tr>
</table>

Note: <code>mem_pressure</code> = RAM usage/RAM_and_swap usage in %.

Example device configuration:

```
PRODUCT_PROPERTY_OVERRIDES += \
    ro.lmk.low=1001 \
    ro.lmk.medium=800 \
    ro.lmk.critical=0 \
    ro.lmk.critical_upgrade=false \
    ro.lmk.upgrade_pressure=100 \
    ro.lmk.downgrade_pressure=100 \
    ro.lmk.kill_heaviest_task=true
```
