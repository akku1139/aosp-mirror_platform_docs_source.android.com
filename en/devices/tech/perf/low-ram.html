<html devsite>
  <head>
    <title>Low RAM Configuration</title>
    <meta name="project_path" value="/_project.yaml" />
    <meta name="book_path" value="/_book.yaml" />
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<p>Android supports devices with 512&nbsp;MB of RAM. This documentation is intended
to help OEMs optimize and configure Android kernel 4.4 for low-memory devices. Several
of these optimizations are generic enough that they can be applied to previous
releases as well.</p>

<h2 id="optimizations">Android kernel 4.4 platform optimizations</h2>

<h3 id="opt-mgmt">Improved memory management</h3>
<ul>
<li>Validated memory-saving kernel configurations: Swap to zram.</li>
<li>Kill cached processes if about to be uncached and too large.</li>
<li>Don't allow large services to put themselves back into the A Services classification (so they
can't cause the launcher to be killed).</li>
<li>Kill processes (even ordinarily unkillable ones such as the current IME)
that get too large in idle maintenance.</li>
<li>Serialize the launch of background services.</li>
<li>Tune memory use of low-RAM devices: tighter out-of-memory (OOM) adjustment
levels, smaller graphics caches.</li>
</ul>

<h3 id="opt-mem">Reduced system memory</h3>
<ul>
  <li>Trimmed <code>system_server</code> and System UI processes (saved several megabytes).</li>
  <li>Preload dex caches in Dalvik (saved several megabytes).</li>
  <li>Validated JIT-off option (saves up to 1.5&nbsp;MB per process).</li>
  <li>Reduced per-process font cache overhead.</li>
  <li>Introduced <code><a href="https://developer.android.com/reference/android/util/ArrayMap?hl"
  class="external">ArrayMap</a></code>/<code><a
  href="https://developer.android.com/reference/android/util/ArraySet?hl"
  class="external">ArraySet</a></code> and used extensively in framework as a lighter-footprint
  replacement for <code><a href="https://developer.android.com/reference/java/util/HashMap.html"
  class="external">HashMap</a></code>/<code><a
  href="https://developer.android.com/reference/java/util/HashSet"
  class="external">HashSet</a></code>.</li>
</ul>

<h3 id="opt-proc">Procstats</h3>
<p>
Added a developer option to show memory state and app memory usage
ranked by how often they run and the amount of memory consumed.
</p>

<h3 id="opt-api">API</h3>
<p>
Added <code>ActivityManager.isLowRamDevice()</code> to allow apps to detect
when running on low-memory devices and choose to disable large-RAM features.
</p>

<h3 id="opt-track">Memory tracking</h3>
<p>
Added memtrack HAL to track graphics memory allocations, additional information
in <code>dumpsys</code> meminfo, clarified summaries in meminfo (for example, reported free
RAM includes RAM of cached processes, so that OEMs don't try to optimize the
wrong thing).
</p>

<h2 id="build-time">Build-time configuration</h2>
<h3 id="flag">Low RAM Device flag</h3>
<p>The
<code>ActivityManager.isLowRamDevice()</code> flag determines if apps should turn off
specific memory-intensive features that work poorly on low-memory devices.</p>
<p>For 512&nbsp;MB devices, this flag is expected to return <code>true</code>. It can be enabled by
the following system property in the device makefile.</p>
<pre class="devsite-click-to-copy">
PRODUCT_PROPERTY_OVERRIDES += ro.config.low_ram=true
</pre>

<h3 id="launcher">Launcher Configs</h3>


  <p>The default wallpaper setup on launcher <strong>shouldn't</strong>
use live wallpaper. Low-memory devices shouldn't pre-install any live wallpapers. </p>


<h2 id="kernel">Kernel configuration</h2>
<h3 id="kernel-tuning">Tuning kernel/ActivityManager to reduce direct reclaim </h3>


  <p>Direct reclaim happens when a process or the kernel tries to allocate a page
  of memory (either directly or due to faulting in a new page) and the kernel
  has used all available free memory. This requires the kernel to block the
  allocation while it frees up a page. This in turn often requires disk I/O to
  flush out a dirty file-backed page or wait for <code>lowmemorykiller</code> to kill a
  process. This can result in extra I/O in any thread, including a UI thread.</p>

  <p>To avoid direct reclaim, the kernel has watermarks that trigger <code>kswapd</code> or
  background reclaim. This is a thread that tries to free up pages so the next
  time a real thread allocates, it can succeed quickly.</p>

  <p>The default threshold to trigger background reclaim is fairly low, around 2&nbsp;MB
  on a 2&nbsp;GB device and 636&nbsp;KB on a 512&nbsp;MB device. The kernel reclaims only a
  few megabytes of memory in background reclaim. This means any process that quickly
  allocates more than a few megabytes is going to quickly hit direct reclaim.</p>

<p>Support for a kernel tunable is added in the Android-3.4 kernel branch as
  patch 92189d47f66c67e5fd92eafaa287e153197a454f ("add extra free kbytes
  tunable"). Cherry-picking this patch to a device's kernel allows
  <code>ActivityManager</code> to tell the kernel to try to keep three full-screen 32&nbsp;bpp buffers
  of memory free.</p>

<p>These thresholds can be configured with the <code>config.xml</code> framework.</p>

<pre class="devsite-click-to-copy">
&lt;!-- Device configuration setting the /proc/sys/vm/extra_free_kbytes tunable
in the kernel (if it exists).  A high value will increase the amount of memory
that the kernel tries to keep free, reducing allocation time and causing the
lowmemorykiller to kill earlier.  A low value allows more memory to be used by
processes but may cause more allocations to block waiting on disk I/O or
lowmemorykiller.  Overrides the default value chosen by ActivityManager based
on screen size.  0 prevents keeping any extra memory over what the kernel keeps
by default.  -1 keeps the default. --&gt;
&lt;integer name=&quot;config_extraFreeKbytesAbsolute&quot;&gt;-1&lt;/integer&gt;
</pre>

<pre class="devsite-click-to-copy">
&lt;!-- Device configuration adjusting the /proc/sys/vm/extra_free_kbytes
tunable in the kernel (if it exists).  0 uses the default value chosen by
ActivityManager.  A positive value  will increase the amount of memory that the
kernel tries to keep free, reducing allocation time and causing the
lowmemorykiller to kill earlier.  A negative value allows more memory to be
used by processes but may cause more allocations to block waiting on disk I/O
or lowmemorykiller.  Directly added to the default value chosen by
ActivityManager based on screen size. --&gt;
&lt;integer name=&quot;config_extraFreeKbytesAdjust&quot;&gt;0&lt;/integer&gt;
</pre>

<h3 id="lowmem">Tuning LowMemoryKiller</h3>

    <p><code>ActivityManager</code> configures the thresholds of the LowMemoryKiller to match its
expectation of the working set of file-backed pages (cached pages) required to
run the processes in each priority level bucket. If a device has high
requirements for the working set, for example if the vendor UI requires more
memory or if more services have been added, the thresholds can be increased. </p>

<p>The thresholds can be reduced if too much memory is being reserved for file-backed pages, so that
background processes are being killed long before disk thrashing would occur due to the cache
getting too small.</p>

<pre class="devsite-click-to-copy">
&lt;!-- Device configuration setting the minfree tunable in the lowmemorykiller
in the kernel.  A high value will cause the lowmemorykiller to fire earlier,
keeping more memory in the file cache and preventing I/O thrashing, but
allowing fewer processes to stay in memory.  A low value will keep more
processes in memory but may cause thrashing if set too low.  Overrides the
default value chosen by ActivityManager based on screen size and total memory
for the largest lowmemorykiller bucket, and scaled proportionally to the
smaller buckets.  -1 keeps the default. --&gt;
&lt;integer name=&quot;config_lowMemoryKillerMinFreeKbytesAbsolute&quot;&gt;-1&lt;/integer&gt;
</pre>

<pre class="devsite-click-to-copy">
&lt;!-- Device configuration adjusting the minfree tunable in the
lowmemorykiller in the kernel.  A high value will cause the lowmemorykiller to
fire earlier, keeping more memory in the file cache and preventing I/O
thrashing, but allowing fewer processes to stay in memory.  A low value will
keep more processes in memory but may cause thrashing if set too low.  Directly
added to the default value chosen by          ActivityManager based on screen
size and total memory for the largest lowmemorykiller bucket, and scaled
proportionally to the smaller buckets. 0 keeps the default. --&gt;
&lt;integer name=&quot;config_lowMemoryKillerMinFreeKbytesAdjust&quot;&gt;0&lt;/integer&gt;
</pre>

<h3 id="zram">Swap to zram</h3>

<p>zram swap can increase the amount of memory available in the system by
compressing memory pages and putting them in a dynamically allocated swap area
of memory. Since this is trading off CPU time for a small increase in memory, you
should be careful about measuring the performance impact zram swap has on your
system.</p>

<p>Android handles swap to zram at several levels:</p>

<ul>
  <li>First, the following kernel options must be enabled to use zram swap
    effectively:
    <ul>
      <li><code>CONFIG_SWAP</code></li>
      <li><code>CONFIG_CGROUP_MEM_RES_CTLR</code></li>
      <li><code>CONFIG_CGROUP_MEM_RES_CTLR_SWAP</code></li>
      <li><code>CONFIG_ZRAM</code></li>
    </ul>
  </li>
  <li>Then, you should add a line that looks like this to your fstab:
<pre class="devsite-click-to-copy">
/dev/block/zram0 none swap defaults zramsize=&lt;size in bytes&gt;,swapprio=&lt;swap partition priority&gt;
</pre>
  <ul>
   <li><code>zramsize</code> is mandatory and indicates how much uncompressed memory you want the
    zram area to hold. Compression ratios in the 30-50% range are usually observed.</li>
   <li><code>swapprio</code> is only needed if you don't have more than one swap
     area.</li>
  </ul>
    <p>Label the associated block device as a <code>swap_block_device</code>
      in the device-specific <code><a href="/security/selinux/implement">sepolicy/file_contexts</a></code> so
  that it's treated properly by SELinux.</p>
<pre class="devsite-click-to-copy">
/dev/block/zram0 u:object_r:swap_block_device:s0
</pre>
  </li>
  <li>By default, the Linux kernel swaps in eight pages of memory at a time. When
    using zram, the incremental cost of reading one page at a time is negligible
    and may help if the device is under extreme memory pressure. To read
    only one page at a time, add the following to your <code>init.rc</code>:
<pre class="devsite-click-to-copy">
write /proc/sys/vm/page-cluster 0
</pre>
  </li>
  <li>In your <code>init.rc</code> after the <code>mount_all /fstab.X</code> line, add:
<pre class="devsite-click-to-copy">
swapon_all /fstab.X
</pre>
  </li>
  <li>The memory cgroups are automatically configured at boot time if the
    feature is enabled in the kernel.</li>
  <li>If memory cgroups are available, <code>ActivityManager</code> marks
    lower-priority threads as being more swappable than other threads. If memory is
    needed, the Android kernel starts migrating memory pages to zram swap,
    giving a higher priority to the memory pages that have been marked by
    <code>ActivityManager</code>. </li>
</ul>

<h3 id="carveouts">Carveouts, Ion, and contiguous memory allocation (CMA)</h3>

<p>On low-memory devices, it's important to be mindful about
carveouts, especially those that aren't fully used, such as a carveout for
secure video playback. There are several solutions to minimize the impact
of your carveout regions that depend on the exact requirements of your
hardware.</p>

<p>If hardware permits discontiguous memory allocations, the Ion system heap
allows memory allocations from system memory,
eliminating the need for a carveout. Ion also attempts to make large
allocations to eliminate translation lookaside buffer (TLB) pressure on
peripherals. If memory regions must be contiguous or confined to a specific
address range, the CMA can be used.</p>

<p>This creates a carveout that the system can also use for movable pages.
When the region is needed, movable pages are migrated out of it, allowing
the system to use a large carveout for other purposes when it's free. You can
use CMA directly with the Ion CMA heap.</p>

<h2 id="app-opts">App optimization tips</h2>
<ul>
   <li>Review <a
href="http://developer.android.com/training/articles/memory.html"
class"external">Manage your app's memory</a> and these blog posts:
  <ul>
    <li><a
href="http://android-developers.blogspot.com/2009/01/avoiding-memory-leaks.html"
class="external">Avoiding memory leaks</a></li>
    <li><a
href="http://android-developers.blogspot.com/2011/03/memory-analysis-for-android.html
class="external"">Memory Analysis for Android Applications</a></li>
    <li><a
href="http://android-developers.blogspot.com/2009/02/track-memory-allocations.html
class="external"">Track memory allocations</a></li>
    <li> <a
href="http://tools.android.com/recent/lintperformancechecks class="external"">Lint
    Performance Checks</a></li>
    </ul>
</li>
  <li>Remove any unused assets from preinstalled apps using
    <code>development/tools/findunused</code> (this should help make the app
    smaller).</li>
<li>Use the PNG format for assets, especially when they have transparent areas.</li>
  <li>If writing native code, use <code>calloc()</code> rather than
    <code>malloc</code>/<code>memset</code>.</li>
<li>Don't enable code that writes Parcel data to disk and reads it later.</li>
<li>Use SSP filtering instead of subscribing to every package installed. Add
filtering like this:
<pre class="devsite-click-to-copy">
&lt;data android:scheme=&quot;package&quot; android:ssp=&quot;com.android.pkg1&quot; /&gt;
&lt;data android:scheme=&quot;package&quot; android:ssp=&quot;com.myapp.act1&quot; /&gt;
</pre>
</li>
</ul>

<h3 id="process-states">Understand the various process states in Android</h3>

  <table>
    <tr>
      <th>State</th>
      <th>Meaning</th>
      <th>Details</th>
    </tr>
    <tr>
      <td><code>SERVICE</code><br><code>SERVICE_RESTARTING</code></td>
      <td>Apps that run in the background for app-related reasons.</td>
      <td><code>SERVICE</code><code>SERVICE_RESTARTING</code> are the most common problems apps have when they
        run in the background too much. Use <em>%duration * pss</em> or <em>%duration</em>
        as a "badness" metric. Ideally, these apps shouldn't be running at all.</td>
    </tr>
    <tr>
      <td><code>IMPORTANT_FOREGROUND</code><br><code>RECEIVER</code></td>
      <td>Apps running in the background
      (not directly interacting with the user).</td>
      <td>These add memory load to the system. Use the (<em>%duration * pss</em>) "badness" value to
        order these processes. However, many of these apps run for good reasons. The size of
        <em>pss</em> is an important part of their memory load.</td>
    </tr>
    <tr>
      <td><code>PERSISTENT</code></td>
      <td>Persistent system process.</td>
      <td>Track <em>pss</em> to watch for these processes getting too large.</td>
    </tr>
    <tr>
      <td><code>TOP</code></td>
      <td>The process the user is currently interacting with.</td>
      <td><em>pss</em> is the important metric here, showing how much memory load the app
      creates while in use.</td>
    </tr>
    <tr>
      <td><code>HOME</code><br><code>CACHED_EMPTY</code></td>
      <td>The processes the system is keeping around in case they are needed again.</td>
      <td>These processes can be freely killed at any time and recreated if needed. The memory state
        (normal, moderate, low, critical) is computed based on how many of these processes the
        system is running. The key metric for these processes is the <em>pss</em>. In this state,
        these processes should decrease their memory footprint as much as possible to allow for the
        maximum total number of processes to be kept around. In this state, a well behaved app
        generally has a significantly smaller <em>pss</em> footprint than it does in the
        <code>TOP</code> state.</td>
    </tr>
    <tr>
      <td><code>CACHED_ACTIVITY</code><br><code>CACHED_ACTIVITY_CLIENT</code></td>
      <td>When compared with <code>TOP</code>, these show how well an app releases memory into the
        background.</td>
      <td>Excluding <code>CACHED_EMPTY</code> state makes this data better, because it removes
      situations when the process has started for some reasons besides interacting with the user.
      This eliminates dealing with the UI overhead <code>CACHED_EMPTY</code> gets when user-related
      activities.</td>
    </tr>
    </table>

<h2 id="analysis">Analysis</h2>

<h3 id="app-startup">Analyzing app startup time</h3>

<p>To analyze your app's startup time, run <code>$ adb shell am start -P</code>
 or <code>--start-profiler</code> and start your app. The profiler starts after the
 process is forked from the zygote and before any code is loaded into the fork.</p>

<h3 id="bug-reports">Analyzing using bug reports</h3>

<p>Bug reports contain several services, including <code>batterystats</code>,
<code>netstats</code>, <code>procstats</code>, and <code>usagestats</code>, which
can be used for debugging. Reports can include lines like this:</p>

<pre class="devsite-click-to-copy">
------ CHECKIN BATTERYSTATS (dumpsys batterystats --checkin) ------
7,0,h,-2558644,97,1946288161,3,2,0,340,4183
7,0,h,-2553041,97,1946288161,3,2,0,340,4183
</pre>

<h3 id="persistent">Checking for any persistent processes</h3>

<p>To check for any persistent processes, reboot the device and check the
processes. Then, run the device for a few hours and check the processes again.
There shouldn't be any long-running processes between the two checks.</p>

<h3 id="longevity">Running longevity tests</h3>

<p>To run longevity tests, run the device for longer durations and track the memory of the
 processes to determine if it increases or stays constant. Then create canonical use cases
 and run longevity tests on these scenarios.</p>

  </body>
</html>
