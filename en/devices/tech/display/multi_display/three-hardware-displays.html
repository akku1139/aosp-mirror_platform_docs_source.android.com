<html devsite>
  <head>
    <title>System Decorations</title>
    <meta name="project_path" value="/_project.yaml" />
    <meta name="book_path" value="/_book.yaml" />
  </head>
  <body>
{% include "_versions.html" %}

  <!--
      Copyright 2019 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->


<p>In Android 9 (and lower), SurfaceFlinger and <code>DisplayManagerService</code>
assumed the existence of at most two physical displays with hard-coded IDs 0
and 1. As described in
  <a href="/devices/tech/display/multi_display/static-display-identifiers">Static
    Display Identifiers</a>, SurfaceFlinger now leverages
a Hardware Composer (HWC) API to generate stable display IDs, which enables it
to manage an arbitrary number of physical displays.</p>

<p>The framework can look up the <code>IBinder</code> token for a physical
display via <code>SurfaceControl#getPhysicalDisplayToken</code> after obtaining
the 64-bit display ID from <code>SurfaceControl#getPhysicalDisplayIds</code> or
from a <code>DisplayEventReceiver</code> hotplug event.</p>

<aside class="note"><strong>Note.</strong> Per-display VSYNC is not supported.
All displays are driven by the VSYNC signal of the primary internal
display.</aside>

<p>In Android {{ androidQVersionNumber }}, primary internal display is
<code>TYPE_BUILT_IN</code>, and all secondary displays are flagged as
<code>TYPE_HDMI</code> regardless of connection type. Therefore, additional
internal displays are currently treated as external. As a workaround,
device-specific code can make assumptions about
<code>DisplayAddress.Physical#getPort</code> if the HWC is known and the port
allocation logic is predictable.</p>

<h2 id="implementation-three">Implementation</h2>

<p>Previously, displays were identified by 32-bit IDs, where 0 is the internal
display, 1 is the external display, [2, INT32_MAX] are HWC virtual displays, and
-1 represents an invalid display or a non-HWC virtual display. For
SurfaceFlinger and <code>DisplayManagerService</code> to track more than two
displays and recognize previously seen displays, displays should be given stable
and persistent IDs.</p>

<p>If the HWC supports <code>IComposerClient.getDisplayIdentificationData</code>
and provides display identification data, SurfaceFlinger parses the EDID
structure and allocates stable 64-bit display IDs for physical and HWC virtual
displays. The IDs are expressed using an option type, where the null value
represents an invalid display or non-HWC virtual display. Without HWC support,
SurfaceFlinger falls back to legacy behavior with at most two physical
displays.</p>

</body>
</html>
