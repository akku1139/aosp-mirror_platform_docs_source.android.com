<html devsite>
  <head>
    <title>AddressSanitizer</title>
    <meta name="project_path" value="/_project.yaml" />
    <meta name="book_path" value="/_book.yaml" />
  </head>
  <body>
  {% include "_versions.html" %}
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<p>AddressSanitizer (ASan) is a fast compiler-based tool for detecting
  memory bugs in native code.</p>

<p>ASan detects:</p>
<ul>
<li>Stack and heap buffer overflow/underflow</li>
<li>Heap use after free</li>
<li>Stack use outside scope</li>
<li>Double free/wild free</li>
</ul>

<p>ASan runs on both 32-bit and 64-bit ARM, plus x86 and x86-64. ASan's CPU overhead
is roughly 2x, code size overhead is between 50% and 2x, and a large memory overhead
(dependent on your allocation patterns, but on the order of 2x).</p>

<p>Android {{ androidQVersionNumber }} and the AOSP master branch on AArch64
support <a href="/devices/tech/debug/hwasan">hardware-accelerated
ASan (HWASan)</a>, a similar tool with lower RAM overhead and a larger
range of detected bugs. HWASan detects stack use after return, in addition to the bugs
detected by ASan.</p>
<p>HWASan has similar CPU and code size overhead, but a much smaller RAM overhead (15%).
HWASan is nondeterministic. There are only 256 possible tag values, so there's a flat 0.4%
probability of missing any bug. HWASan doesn't have ASan's limited-size red zones for
detecting overflows and limited-capacity quarantine for detecting use-after-free,
so it doesn't matter to HWASan how large the overflow is or how long ago the memory
was deallocated. This makes HWASan better than ASan. You can read more about the
<a href="http://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html"
class="external">design of HWASan</a> or about the use of
<a href="/devices/tech/debug/hwasan">HWASan on Android</a>.</p>

<p>ASan detects stack/global overflows
in addition to heap overflows, and is fast with minimal memory overhead.</p>

<p>This document describes how to build and run parts/all of Android with
ASan. If you're building an SDK/NDK app with ASan, see
<a href="https://developer.android.com/ndk/guides/asan" class="external">Address Sanitizer</a>
instead.</p>

<h2 id="sanitizing_individual_executables_with_asan">Sanitizing individual executables with ASan</h2>

<p>Add <code>LOCAL_SANITIZE:=address</code> or <code>sanitize: { address: true }</code> to
the build rule for the executable. You can search the code for existing examples or to find
the other available sanitizers.</p>

<p>When a bug is detected, ASan prints a verbose report both to the standard
output and to <code>logcat</code> and then crashes the process.</p>

<h2 id="sanitizing_shared_libraries_with_asan">Sanitizing shared libraries with ASan</h2>

<p>Due to the way ASan works, a library built with ASan can only be used by an
executable that's built with ASan.</p>

<aside class="note"><strong>Note:</strong> In runtime situations where an ASan library is
loaded into an incorrect process, you see unresolved symbol messages
starting with <code>_asan</code> or <code>_sanitizer</code>.</aside>

<p>To sanitize a shared library that's used in multiple executables, not all of
which are built with ASan, you need two copies of the library. The
recommended way to do this is to add the following to <code>Android.mk</code>
for the module in question:</p>

<pre class="devsite-click-to-copy">
LOCAL_SANITIZE:=address
LOCAL_MODULE_RELATIVE_PATH := asan
</pre>

<p>This puts the library in <code>/system/lib/asan</code> instead of
<code>/system/lib</code>. Then, run your executable with:</p>
<pre class="devsite-click-to-copy">LD_LIBRARY_PATH=/system/lib/asan</pre>

<p>For system daemons, add the following to the appropriate section of
<code>/init.rc</code> or <code>/init.$device$.rc</code>.</p>

<pre class="devsite-click-to-copy">
setenv LD_LIBRARY_PATH /system/lib/asan
</pre>

<aside class="warning"><strong>Warning:</strong> The <code>LOCAL_MODULE_RELATIVE_PATH</code>
setting <strong>moves</strong> your library to <code>/system/lib/asan</code>,
meaning that clobbering and rebuilding from scratch means that the
library is missing from <code>/system/lib</code>, and the image is probably unbootable.
That's an unfortunate limitation of the
current build system. Don't clobber; instead, use <code>make -j $N</code> and <code>adb
sync</code>.</aside>

<p>Verify that the process is using libraries from <code>/system/lib/asan</code>
when present by reading <code>/proc/$PID/maps</code>. If it's not, you may need
to disable SELinux:</p>

<pre class="devsite-click-to-copy">
<code class="devsite-terminal">adb root</code>
<code class="devsite-terminal">adb shell setenforce 0</code>
# restart the process with adb shell kill $PID
# if it is a system service, or may be adb shell stop; adb shell start.
</pre>

<h2 id="better_stack_traces">Better stack traces</h2>

<p>ASan uses a fast, frame-pointer-based unwinder to record a stack
trace for every memory allocation and deallocation event in the program. Most
of Android is built without frame pointers. As a result, you often get
only one or two meaningful frames. To fix this, either rebuild the library with
ASan (recommended!), or with:</p>

<pre class="devsite-click-to-copy">
LOCAL_CFLAGS:=-fno-omit-frame-pointer
LOCAL_ARM_MODE:=arm
</pre>

<p>Or set <code>ASAN_OPTIONS=fast_unwind_on_malloc=0</code> in the process
environment. The latter can be very CPU-intensive, depending on
the load.</p>

<h2 id="symbolization">Symbolization</h2>

<p>Initially, ASan reports contain references to offsets in binaries and shared
libraries. There are two ways to obtain source file and line information:</p>

<ul>
<li>Ensure that the <code>llvm-symbolizer</code> binary is present in <code>/system/bin</code>.
<code>llvm-symbolizer</code> is built from sources in
<code>third_party/llvm/tools/llvm-symbolizer</code>.</li>
<li>Filter the report through the <code>external/compiler-rt/lib/asan/scripts/symbolize.py</code>
script.
</ul>

<p>The second approach can provide more data (that is, <code>file:line</code> locations) because of
the availability of symbolized libraries on the host.</p>

<h2 id="addresssanitizer_in_the_apps">ASan in apps</h2>

<p>ASan can't see into Java code, but it can detect bugs in the JNI
libraries. For that, you need to build the executable with ASan, which in
this case is <code>/system/bin/app_process(<em>32|64</em>)</code>. This
enables ASan in all apps on the device at the same time, which is a
heavy load, but a device with 2&nbsp;GB RAM should be able to handle this.</p>

<p>Add <code>LOCAL_SANITIZE:=address</code> to
the <code>app_process</code> build rule in <code>frameworks/base/cmds/app_process</code>. Ignore
the <code>app_process__asan</code> target in the same file for now (if it's
still there at the time you read this). Edit the Zygote record in
<code>system/core/rootdir/init.zygote(<em>32|64</em>).rc</code> to add the following lines:</p>

<pre class="devsite-click-to-copy">
setenv LD_LIBRARY_PATH /system/lib/asan:/system/lib
setenv ASAN_OPTIONS
allow_user_segv_handler=true
</pre>

<p>Build, adb sync, fastboot flash boot, and reboot.</p>

<h2 id="using_the_wrap_property">Using the wrap property</h2>

<p>The approach in the previous section puts ASan into every
app in the system (actually, into every descendant of the Zygote
process). It's possible to run only one (or several) apps with ASan,
trading some memory overhead for slower app startup.</p>

<p>This can be done by starting your app with the <code>wrap.</code> property.
The following example runs the Gmail app under ASan:</p>

<pre class="devsite-click-to-copy">
<code class="devsite-terminal">adb root</code>
<code class="devsite-terminal">adb shell setenforce 0  # disable SELinux</code>
<code class="devsite-terminal">adb shell setprop wrap.com.google.android.gm "asanwrapper"</code>
</pre>

<p>In this context, <code>asanwrapper</code> rewrites <code>/system/bin/app_process</code>
to <code>/system/bin/asan/app_process</code>, which is built with
ASan. It also adds <code>/system/lib/asan</code> at the start of
the dynamic library search path. This way ASan-instrumented
libraries from <code>/system/lib/asan</code> are preferred to normal libraries
in <code>/system/lib</code> when running with <code>asanwrapper</code>.</p>

<p>If a bug is found, the app crashes, and the report is printed to
the log.</p>

<h2 id="sanitize_target">SANITIZE_TARGET</h2>

<p>Android 7.0 and higher includes support for building the entire Android platform with
ASan at once. (If you're building a release higher than Android 9, HWASan is a better choice.)</p>

<p>Run the following commands in the same build tree.</p>

<pre class="devsite-click-to-copy">
<code class="devsite-terminal">make -j42</code>
<code class="devsite-terminal">SANITIZE_TARGET=address make -j42</code>
</pre>

<p>In this mode, <code>userdata.img</code> contains extra libraries and must be
flashed to the device as well. Use the following command line:</p>

<pre class="devsite-terminal devsite-click-to-copy">
fastboot flash userdata &amp;&amp; fastboot flashall
</pre>

<p>This builds two sets of shared libraries: normal in
<code>/system/lib</code> (the first make invocation), and ASan-instrumented in
<code>/data/asan/lib</code> (the second make invocation). Executables from the
second build overwrite those from the first build. ASan-instrumented
executables get a different library search path that includes
<code>/data/asan/lib</code> before <code>/system/lib</code> through the use of
<code>/system/bin/linker_asan</code> in <code>PT_INTERP</code>.</p>

<p>The build system clobbers intermediate object directories when the
<code>$SANITIZE_TARGET</code> value has changed. This forces a rebuild of all
targets while preserving installed binaries under <code>/system/lib</code>.</p>

<p>Some targets can't be built with ASan:</p>

<ul>
  <li>Statically linked executables
  <li><code>LOCAL_CLANG:=false</code> targets
  <li><code>LOCAL_SANITIZE:=false</code> aren't ASan'd for <code>SANITIZE_TARGET=address</code>
</ul>

<p>Executables like these are skipped in the <code>SANITIZE_TARGET</code> build, and the
version from the first make invocation is left in <code>/system/bin</code>.</p>

<p>Libraries like this are built without ASan. They can contain some ASan
code from the static libraries that they depend upon.</p>

<h2 id="supporting_documentation">Supporting documentation</h2>
<ul>
<li><a href="https://developer.android.com/ndk/guides/asan" class="external">Address Sanitizer</a></li>
<li><a href="https://www.chromium.org/developers/testing/addresssanitizer" class="external">AddressSanitizer
and Chromium</a></li>
<li><a href="https://github.com/google/sanitizers" class="external">Other Google Sanitizers</a></li>
</ul>
  </body>
</html>
