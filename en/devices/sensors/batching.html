<html devsite>
  <head>
    <title>Batching</title>
    <meta name="project_path" value="/_project.yaml" />
    <meta name="book_path" value="/_book.yaml" />
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<h2 id="what_is_batching">What is batching?</h2>
<p><em>Batching</em> refers to storing sensor events in a hardware FIFO before reporting
  them through the <a href="/devices/sensors/hal-interface">HAL</a> instead of reporting them immediately.</p>
<p>Batching can enable significant power savings by preventing the SoC from waking
  up to receive each event. Instead, the events can be grouped and processed
  together.</p>
<p>The bigger the FIFOs, the more power can be saved. Implementing batching is an
  exercise of trading off hardware memory for reduced power consumption.</p>
<p>Batching happens when a sensor possesses a hardware FIFO
  (<code>sensor_t.fifoMaxEventCount &gt; 0</code>) and in one of two situations:</p>
<ul>
  <li><code>max_report_latency &gt; 0</code>, meaning the sensor events for this specific sensor can
    be delayed up to <code>max_report_latency</code> before being reported through the HAL.<br>OR</li>
  <li>The SoC is in suspend mode and the sensor is a non-wake-up sensor, meaning
    events must be stored while waiting for the SoC to wake up.</li>
</ul>
<p>See the paragraph on the <a
  href="/devices/sensors/hal-interface#batch_sensor_flags_sampling_period_maximum_report_latency">HAL
  batch function</a> for more details.</p>
<p>The opposite of batching is <em>continuous operation</em>, where events are reported
  immediately instead of being buffered. Continuous operation
  corresponds to:</p>
<ul>
  <li>When <code>max_report_latency = 0</code> and the events can be delivered to the app,
    meaning one of the following:
    <ul>
      <li>The SoC is awake.<br>OR</li>
      <li>The sensor is a wake-up sensor.</li>
    </ul>
 </li>
  <li>Or when the sensor doesn’t have a hardware FIFO (<code>sensor_t.fifoMaxEventCount =
    0</code>), in which case, one of the following occurs:
    <ul>
      <li>The events are reported if the SoC is awake or the sensor is a wake-up sensor.</li>
      <li>The events are lost when the SoC is asleep and the sensor is a non-wake-up
        sensor.</li>
    </ul>
 </li>
</ul>
<h2 id="wake-up_fifos_and_non-wake-up_fifos">Wake-up FIFOs and non-wake-up FIFOs</h2>
<p>Sensor events from <a href="/devices/sensors/suspend-mode#wake-up_sensors">wake-up
  sensors</a> must be stored in a wake-up FIFO. There can be one wake-up FIFO
  per sensor, or more commonly, one big shared wake-up FIFO where events from all wake-up
  sensors are interleaved. Other options are also possible, for example, some
  wake-up sensors having a dedicated FIFO, and the rest of the wake-up sensors
  sharing a FIFO.</p>
<p>Similarly, sensor events from <a
  href="/devices/sensors/suspend-mode#non-wake-up_sensors">non-wake-up sensors</a> must be
  stored in a non-wake-up FIFO, and there can be one or several
  non-wake-up FIFOs.</p>
<p>In all cases, wake-up sensor events and non-wake-up sensor events can't be
  interleaved in the same FIFO. Wake-up events go in wake-up FIFOs, and
  non-wake-up events go in non-wake-up FIFOs.</p>
<p>For the wake-up FIFO, having a single shared FIFO provides the best power
  benefits. For the non-wake-up FIFO, the power difference between a shared FIFO
and dedicated FIFOs is negligible. See <a
  href="#fifo_allocation_priority">FIFO allocation priority</a> for suggestions
  on how to allocate each FIFO.</p>
<h2 id="behavior_outside_of_suspend_mode">Behavior outside of suspend mode</h2>
<p>When the SoC is awake (not in suspend mode), events can be stored
  temporarily in their FIFO, as long as they are not delayed by more than
  <code>max_report_latency</code>.</p>
<p>As long as the SoC doesn’t enter the suspend mode, no event is dropped or
  lost. If an internal hardware FIFO is getting full before <code>max_report_latency</code>
  elapses, then events are reported at that point to ensure that no event is
  lost.</p>
<p>If several sensors share the same FIFO and <code>max_report_latency</code> for one of
  them elapses, all events from the FIFO are reported, even if
  <code>max_report_latency</code> for the other sensors hasn’t elapsed. The general goal is
  to reduce the number of times batches of events must be reported, so as soon as
  one event must be reported, all events from all sensors can be reported.</p>
<p>For example, if the following sensors are activated:</p>
<ul>
  <li>Accelerometer batched with <code>max_report_latency</code> = 20s</li>
  <li>Gyroscope batched with <code>max_report_latency</code> = 5s</li>
</ul>
<p>Then the accelerometer batches can be reported at the same time the gyroscope
  batches are reported (every 5 seconds), even if the accelerometer and the
  gyroscope don't share the same FIFO.</p>
<h2 id="behavior_in_suspend_mode">Behavior in suspend mode</h2>
<p>Batching is particularly beneficial for collecting sensor data in the
  background without keeping the SoC awake. Because the sensor drivers and HAL
  implementation aren't allowed to hold a wake-lock (see Note, below), the SoC can enter
  the suspend mode even while sensor data is being collected.</p>
<p>The behavior of sensors while the SoC is suspended depends on whether the
  sensor is a wake-up sensor. See <a
href="/devices/sensors/suspend-mode#wake-up_sensors">Wake-up sensors</a> for some
details.</p>
<p>When a non-wake-up FIFO fills up, it must wrap around and behave like a
  circular buffer, overwriting older events, so the new events replace the oldest ones.
  <code>max_report_latency</code> has no impact on non-wake-up FIFOs while in the suspend mode.</p>
<p>When a wake-up FIFO fills up, or when <code>max_report_latency</code> of one of the
  wake-up sensor elapses, the hardware must wake up the SoC and report the data.</p>
<p>In both cases (wake-up and non-wake-up), as soon as the SoC comes out of the
  suspend mode, a batch is produced with the content of all FIFOs, even if
  <code>max_report_latency</code> of some sensors hasn’t elapsed. This minimizes the risk
  of having to wake-up the SoC again soon if it goes back to the suspend mode. Hence, it
  minimizes power consumption.</p>
<aside class="note"><b>Note:</b> One notable exception of drivers not being allowed to hold a wake
  lock is when a wake-up sensor with <a href="/devices/sensors/report-modes#continuous">continuous
  reporting mode</a> is activated with <code>max_report_latency</code> &lt; 1
  second. In that case, the driver can hold a wake lock because the SoC wouldn't
  have time to enter the suspend mode, as it would be awoken by
  a wake-up event before reaching the suspend mode.</aside>
<h2 id="precautions_to_take_when_batching_wake-up_sensors">Precautions to take when batching wake-up sensors</h2>
<p>Depending on the device, it can take a few milliseconds for the SoC to
  come out of suspend and start flushing the FIFO. Allocate enough head room
  in the FIFO to allow the device to come out of suspend
  without the wake-up FIFO overflowing. Then no events are lost, and
  <code>max_report_latency</code> is respected.</p>
<h2 id="precautions_to_take_when_batching_non-wake-up_on-change_sensors">Precautions to take when batching non-wake-up on-change sensors</h2>
<p>On-change sensors only generate events when the value they're measuring is
  changing. If the measured value changes while the SoC is in the suspend mode,
  apps expect to receive an event as soon as the SoC wakes up. Because of
  this, batching of <a href="/devices/sensors/suspend-mode#non-wake-up_sensors">non-wake-up</a>
  on-change sensor events must be performed carefully if the sensor shares its
  FIFO with other sensors. The last event generated by each on-change sensor must
  always be saved outside of the shared FIFO so that it can't be overwritten by
  other events. When the SoC wakes up, after all events from the FIFO have been
  reported, the last on-change sensor event must be reported.</p>
<p>For example, avoid this situation:</p>
<ol>
  <li>An app registers to the non-wake-up step counter (on-change) and the
    non-wake-up accelerometer (continuous), both sharing the same FIFO.</li>
  <li>The app receives a step counter event <code>step_count=1000 steps</code>.</li>
  <li>The SoC goes to suspend.</li>
  <li>The user walks 20 steps, causing step counter and accelerometer events to be
    interleaved, the last step counter event being <code>step_count = 1020 steps</code>.</li>
  <li>The user doesn’t move for a long time, causing accelerometer events to continue
    accumulating in the FIFO, eventually overwriting every <code>step_count</code> event in the
    shared FIFO.</li>
  <li>The SoC wakes up and all events from the FIFO are sent to the app.</li>
  <li>The app receives only accelerometer events and indicates that the user
    didn’t walk (bad!).</li>
</ol>
<p>By saving the last step counter event outside of the FIFO, the HAL can report
  this event when the SoC wakes up, even if all other step counter events were
  overwritten by accelerometer events. This way, the app receives
  <code>step_count = 1020 steps</code> when the SoC wakes up.</p>
<h2 id="implementing_batching">Implementing batching</h2>
<p>Batching can't be emulated in software, so it must be implemented entirely in
  hardware, with hardware FIFOs. In particular, it can't be implemented on the
  SoC, for example in the HAL implementation, as this would require the SoC to
  be awake. The goal here is to save significant amounts of power.
  Batching must be implemented without the aid of the SoC, which should be
  allowed to be in suspend mode during batching.</p>
<p><code>max_report_latency</code> can be modified at any time, in particular while the
  specified sensor is already enabled; this doesn't result in the loss of
  events.</p>
<h2 id="fifo_allocation_priority">FIFO allocation priority</h2>
<p>On platforms in which hardware FIFO size is limited, the system designers may
  have to choose how much FIFO to reserve for each sensor. To help with this
  choice, here are some example apps that are more power-efficient when
different sensors are batched.</p>
<h3 id="high_value_low_power_pedestrian_dead_reckoning">High value: Low power pedestrian dead reckoning</h3>
<p>Target batching time: 1 to 10 minutes</p>
<p>Sensors to batch:</p>
<ul>
  <li>Wake-up step detector</li>
  <li>Wake-up game rotation vector at 5&nbsp;Hz</li>
  <li>Wake-up barometer at 5&nbsp;Hz</li>
  <li>Wake-up uncalibrated magnetometer at 5&nbsp;Hz</li>
</ul>
<p>Batching this data allows performing pedestrian dead reckoning while letting
  the SoC go to suspend.</p>
<h3 id="high_value_medium_power_intermittent_activity_gesture_recognition">High value: Medium power intermittent activity/gesture recognition</h3>
<p>Target batching time: 3 seconds</p>
<p>Sensors to batch: Non-wake-up accelerometer at 50&nbsp;Hz</p>
<p>Batching this data allows periodically recognizing arbitrary activities and
  gestures without having to keep the SoC awake while the data is collected.</p>
<h3 id="medium_value_medium_power_continuous_activity_gesture_recognition">Medium value: Medium power continuous activity/gesture recognition</h3>
<p>Target batching time: 1 to 3 minutes</p>
<p>Sensors to batch: Wake-up accelerometer at 50&nbsp;Hz</p>
<p>Batching this data allows continuously recognizing arbitrary activities and
  gestures without having to keep the SoC awake while the data is collected.</p>
<h3 id="medium-high_value_interrupt_load_reduction">Medium-high value: Interrupt load reduction</h3>
<p>Target batching time: &lt; 1 second</p>
<p>Sensors to batch: Any high-frequency sensor, usually non-wake-up.</p>
<p>If the gyroscope is set at 240&nbsp;Hz, even batching just 10 gyro events can reduce
  the number of interrupts from 240/second to 24/second.</p>
<h3 id="medium_value_continuous_low_frequency_data_collection">Medium value: Continuous low-frequency data collection</h3>
<p>Target batching time: 1 to 10 minutes</p>
<p>Sensors to batch:</p>
<ul>
  <li>Wake-up barometer at 1&nbsp;Hz</li>
  <li>Wake-up humidity sensor at 1&nbsp;Hz</li>
  <li>Other low frequency wake-up sensors at similar rates</li>
</ul>
<p>Allows creating monitoring apps at low power.</p>
<h3 id="medium-low_value_continuous_full-sensors_collection">Medium-low value: Continuous full-sensors collection</h3>
<p>Target batching time: 1 to 10 minutes</p>
<p>Sensors to batch: All wake-up sensors, at high frequencies</p>
<p>Allows full collection of sensor data while leaving the SoC in suspend mode.
  Consider this only if FIFO space isn't an issue.</p>

  </body>
</html>
