<html devsite>
  <head>
    <title>Batching</title>
    <meta name="project_path" value="/_project.yaml" />
    <meta name="book_path" value="/_book.yaml" />
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<h2 id="what_is_batching">What is batching?</h2>
<p>Batching refers to buffering
sensor events in a sensor hub and/or hardware FIFO before reporting the events
through the <a href="/devices/sensors/sensors-hal2">Sensors HAL</a>. The
location where sensor events are buffered (sensor hub and/or hardware FIFO) are
referred to as "FIFO" on this page. When sensor event batching is not active,
sensor events are immediately reported to the Sensors HAL when available.</p>

<aside class="note"><strong>Note:</strong> Batching and the Sensors HAL’s
  <code>batch()</code> function are separate concepts, although related.
  Batching refers to buffering sensor events to save power. The
  <code>batch()</code> function is used to configure a sensor’s reporting
  frequency and the maximum delay between an event being generated and it being
  reported to the Sensors HAL.</aside>

<p>Batching can enable significant power savings by only waking up the main
  applications processor (AP), which runs Android, when many sensor events are
  ready to be processed, instead of waking it for each individual event. The
  potential power savings is directly correlated to the number of events that
  the sensor hub and/or FIFO can buffer: there's a greater potential for power
  savings if more events can be batched. Batching leverages the use of
  low-power memory in order to reduce the number of high-power AP wake-ups.</p>

<p>Batching can occur only when a sensor possesses a hardware FIFO and/or can
  buffer events within a sensor hub. In either case, the sensor must report the
  maximum number of events that can be batched at once through
  <code>SensorInfo.fifoMaxEventCount</code>.</p>

<p>If a sensor has space reserved within a FIFO, the sensor must report the
  number of reserved events through
  <code>SensorInfo.fifoReservedEventCount</code>. If the FIFO is dedicated to
  the sensor, then <code>SensorInfo.fifoReservedEventCount</code> is the size of
  of the FIFO. If the FIFO is shared amongst several sensors, this value may be
  zero. A common use case is to allow a sensor to use the entire FIFO if it's
  the only active sensor. If multiple sensors are active, then each sensor is
  guaranteed space for at least <code>SensorInfo.fifoReservedEventCount</code>
  events in the FIFO. If a sensor hub is used, the guarantee may be enforced
  through software.</p>

<p>Sensor events are batched in the following situations:</p>

<ul>
  <li>The sensor’s current maximum report latency is greater than zero, which
    means that sensor events can be delayed up to the maximum report latency
    before being reported through the HAL.</li>
  <li>The AP is in suspend mode and the sensor is a non-wake-up sensor. In this
    case, events must not wake the AP and must be stored until the AP wakes
    up.</li>
</ul>

<p>If a sensor doesn't support batching and the AP is asleep, only wake-up
  sensor events are reported to the AP and non-wake-up events must not be
  reported to the AP.</p>

<h2 id="batching_parameters">Batching parameters</h2>

<p> The two parameters that govern the behavior of batching are <a
  href="#sampling_period_ns">sampling_period_ns</a> and <a
  href="#max_report_latency_ns">max_report_latency_ns</a>.
  <code>sampling_period_ns</code> determines how often a new sensor event is
  generated, and <code>max_report_latency_ns</code> determines how long until
  the event must be reported to the Sensors HAL.</p>

<h3 id="sampling_period_ns">sampling_period_ns</h3>

<p>What the <code>sampling_period_ns</code> parameter means depends on the
  specified sensor's reporting mode:</p>
<ul>
  <li>Continuous: <code>sampling_period_ns</code> is the sampling rate, meaning
    the rate at which events are generated.</li>
  <li>On-change: <code>sampling_period_ns</code> limits the sampling rate of
    events, meaning events are generated no faster than every
    <code>sampling_period_ns</code> nanoseconds. Periods can be longer than
    <code>sampling_period_ns</code> if no event is generated and the measured
    values don't change for long periods. For more details, see <a
    href="/devices/sensors/report-modes#on-change">on-change</a> reporting mode.</li>
  <li>One-shot: <code>sampling_period_ns</code> is ignored. It has no
  effect.</li>
  <li>Special: For details on how <code>sampling_period_ns</code> is used
    for special sensors, see <a href="/devices/sensors/sensor-types">
    Sensor Types</a>.</li>
</ul>
<p>For more information about the impact of <code>sampling_period_ns</code> in
  the different modes, see <a href="/devices/sensors/report-modes">Reporting
  modes</a>.</p>
<p>For continuous and on-change sensors:</p>
<ul>
  <li>if <code>sampling_period_ns</code> is less than
    <code>SensorInfo.minDelay</code>, then the HAL implementation must silently
    clamp it to <code>max(SensorInfo.minDelay, 1ms)</code>. Android doesn't
    support the generation of events at more than 1000&nbsp;Hz.</li>
  <li>if <code>sampling_period_ns</code> is greater than
    <code>SensorInfo.maxDelay</code>, then the HAL implementation must silently
    truncate it to <code>SensorInfo.maxDelay</code>.</li>
</ul>
<p>Physical sensors sometimes have limitations on the rates at which they can
  run and the accuracy of their clocks. To account for this, the actual sampling
  frequency can differ from the requested frequency as long as it satisfies the
  requirements in the table below.</p>
<table>
  <tr>
    <th><p>If the requested frequency is</p></th>
    <th><p>Then the actual frequency must be</p></th>
  </tr>
  <tr>
    <td><p>below min frequency (&lt;1/maxDelay)</p></td>
    <td><p>between 90% and 110% of the min frequency</p></td>
  </tr>
  <tr>
    <td><p>between min and max frequency</p></td>
    <td><p>between 90% and 220% of the requested frequency</p></td>
  </tr>
  <tr>
    <td><p>above max frequency (&gt;1/minDelay)</p></td>
    <td><p>between 90% and 110% of the max frequency, and below 1100&nbsp;Hz</p>
    </td>
  </tr>
</table>
<aside class="note"><strong>Note: </strong>This contract is valid only at the
  HAL level, which always has a single client. At the SDK level, applications
  might get different rates due to multiplexing in the framework. For more
  details, see
  <a href="/devices/sensors/sensor-stack#framework">Framework</a>.</aside>

<h3 id="max_report_latency_ns">max_report_latency_ns</h3>
<p><code>max_report_latency_ns</code> sets the maximum time in nanoseconds, by
  which events can be delayed and stored in the hardware FIFO before being
  reported through the HAL while the AP is awake.</p>
<p>A value of zero signifies that the events must be reported as soon as they
  are measured, either skipping the FIFO altogether, or emptying the FIFO as
  soon as one event from the sensor is present.</p>
<p>For example, an accelerometer activated at 50&nbsp;Hz with
  <code>max_report_latency_ns=0</code> will trigger interrupts 50 times per
  second when the AP is awake.</p>
<p>When <code>max_report_latency_ns&gt;0</code>, sensor events do not need to be
  reported as soon as they are detected. They can be temporarily stored in the
  FIFO and reported in batches, as long as no event is delayed by more than
  <code>max_report_latency_ns</code> nanoseconds. This means that all events
  since the previous batch are recorded and returned at once. This reduces the
  amount of interrupts sent to the AP and allows the AP to switch to a lower
  power mode (idle) while the sensor is capturing and batching data.</p>
<p>Each event has a timestamp associated with it. Delaying the time at which an
  event is reported does not impact the event timestamp. The timestamp must be
  accurate and correspond to the time at which the event physically happened,
  not the time it was reported.</p>
<p>Allowing sensor events to be stored temporarily in the FIFO doesn't modify
  the behavior of submitting events to the HAL; events from different sensors
  can be interleaved and all events from the same sensor are
  time-ordered.</p>

<h2 id="wake-up_and_non-wake-up_events">Wake-up and non-wake-up events</h2>
<p>Sensor events from <a
  href="/devices/sensors/suspend-mode#wake-up_sensors">wake-up sensors</a> must
  be stored in one or more wake-up FIFOs. A common design is to have a
  single, large, shared wake-up FIFO where events from all wake-up sensors are
  interleaved. Alternatively, you can have one wake-up FIFO per sensor or have
  dedicated FIFOs for particular wake-up sensors and a shared FIFO for the rest
  of the wake-up sensors.</p>

<p>Similarly, sensor events from <a
  href="/devices/sensors/suspend-mode#non-wake-up_sensors">non-wake-up
  sensors</a> must be stored in one or more non-wake-up FIFOs.</p>
<p>In all cases, wake-up sensor events and non-wake-up sensor events can't be
  interleaved in the same FIFO. Wake-up events must be stored in a wake-up FIFO,
  and non-wake-up events must be stored in a non-wake-up FIFO.</p>
<p>For the wake-up FIFO, the single, large, shared FIFO design provides the
  best power benefits. For the non-wake-up FIFO, the single, large shared FIFO
  and several small reserved FIFOs designs have similar power characteristics.
  For more suggestions on how to configure each FIFO, see <a
  href="#fifo_allocation_priority">FIFO allocation priority</a>.</p>

<h2 id="behavior_outside_of_suspend_mode">Behavior outside of suspend mode</h2>

<p>When the AP is awake (not in suspend mode), events are stored
  temporarily in FIFOs as long as they are not delayed by more than
  <code>max_report_latency</code>.</p>
<p>As long as the AP doesn’t enter suspend mode, no event shall be dropped or
  lost. If internal FIFOs become full before <code>max_report_latency</code>
  elapses, events are reported at that point to ensure that no event is lost.</p>
<p>If several sensors share the same FIFO and the
  <code>max_report_latency</code> of one of them elapses, all events from the
  FIFO are reported, even if the <code>max_report_latency</code> of the other
  sensors haven't yet elapsed. This reduces the number of times batches of
  events are reported. When one event must be reported, all events from all
  sensors are reported.</p>
<p>For example, if the following sensors are activated:</p>
<ul>
  <li>accelerometer batched with <code>max_report_latency</code> = 20s</li>
  <li>gyroscope batched with <code>max_report_latency</code> = 5s</li>
</ul>
<p>The accelerometer batches are reported at the same time the gyroscope
  batches are reported (every 5 seconds), even if the accelerometer and the
  gyroscope do not share the same FIFO.</p>

<h2 id="behavior_in_suspend_mode">Behavior in suspend mode</h2>
<p>Batching is particularly beneficial for collecting sensor data in the
  background without keeping the AP awake. Because the sensor drivers and HAL
  implementation aren't allowed to hold a wake-lock*, the AP can enter the
  suspend mode even while sensor data is being collected.</p>

<p>The behavior of sensors while the AP is suspended depends on whether the
  sensor is a wake-up sensor. For more details, see <a
  href="/devices/sensors/suspend-mode#wake-up_sensors">Wake-up sensors</a>.</p>
<p>When a non-wake-up FIFO fills up, it must wrap around and behave like a
  circular buffer, overwriting older events with the new events replacing the
  old ones. <code>max_report_latency</code> has no impact on non-wake-up FIFOs
  while in suspend mode.</p>
<p>When a wake-up FIFO fills up, or when the <code>max_report_latency</code> of
  one of the wake-up sensors elapses, the hardware must wake up the AP and
  report the data.</p>
<p>In both cases (wake-up and non-wake-up), as soon as the AP comes out of
  suspend mode, a batch is produced with the content of all FIFOs, even if
  <code>max_report_latency</code> of some sensors haven't yet elapsed. This
  minimizes the risk of the AP having to wake up again soon after it returns to
  suspend mode and, therefore, minimizes power consumption.</p>
<p>*One notable exception of drivers not being allowed to hold a wake lock is
  when a wake-up sensor with the <a
  href="/devices/sensors/report-modes#continuous">continuous reporting mode</a>
  is activated with <code>max_report_latency</code> &lt; 1 second. In this case,
  the driver can hold a wake lock because the AP doesn't have time to enter
  suspend mode, as it would be awoken by a wake-up event before reaching the
  suspend mode.</p>
<h2 id="precautions_to_take_when_batching_wake-up_sensors">
  Precautions to take when batching wake-up sensors</h2>
<p>Depending on the device, it might take a few milliseconds for the AP to come
  out of suspend mode completely and start flushing the FIFO. Enough head room
  must be allocated in the FIFO to allow the device to come out of suspend mode
  without the wake-up FIFO overflowing. No events shall be lost, and the
  <code>max_report_latency</code> must be respected.</p>
<h2 id="precautions_to_take_when_batching_non-wake-up_on-change_sensors">
  Precautions to take when batching non-wake-up on-change sensors</h2>
<p>On-change sensors only generate events when the value they are measuring is
  changing. If the measured value changes while the AP is in suspend mode,
  applications expect to receive an event as soon as the AP wakes up. Because of
  this, batching of
  <a href="/devices/sensors/suspend-mode#non-wake-up_sensors">non-wake-up</a>
  on-change sensor events must be performed carefully if the sensor shares its
  FIFO with other sensors. The last event generated by each on-change sensor
  must always be saved outside of the shared FIFO so it can never be overwritten
  by other events. When the AP wakes up, after all events from the FIFO have
  been reported, the last on-change sensor event must be reported.</p>
<p>Here is a situation to avoid:</p>
<ol>
  <li>An application registers to the non-wake-up step counter (on-change) and
    the non-wake-up accelerometer (continuous), both sharing the same FIFO.</li>
  <li>The application receives a step counter event <code>step_count=1000
  steps</code>code>.</li>
  <li>The AP goes to suspend.</li>
  <li>The user walks 20 steps, causing step counter and accelerometer events to
    be interleaved, the last step counter event being <code>step_count = 1020
    steps</code>.</li>
  <li>The user doesn’t move for a long time, causing accelerometer events to
    continue accumulating in the FIFO, eventually overwriting every
    <code>step_count</code> event in the shared FIFO.</li>
  <li>AP wakes up and all events from the FIFO are sent to the application.</li>
  <li>The application receives only accelerometer events and thinks that the
    user didn’t walk.</li>
</ol>
<p>By saving the last step counter event outside of the FIFO, the HAL can report
  this event when the AP wakes up, even if all other step counter events were
  overwritten by accelerometer events. This way, the application receives
  <code>step_count = 1020 steps</code> when the AP wakes up.</p>
<h2 id="implementing_batching">Implementing batching</h2>
<p>To save power, batching must be implemented without the aid of the AP, and
  the AP must be allowed to suspend during batching.</p>

<p>If batching is performed in a sensor hub, the sensor hub's power usage should
  be minimized.</p>

<p>The maximum report latency can be modified at any time, in particular while
  the specified sensor is already enabled; and this shouldn't result in the loss
  of events.</p>
<h2 id="fifo_allocation_priority">FIFO allocation priority</h2>
<p>On platforms in which hardware FIFO and/or sensor hub buffer size is limited,
  system designers may have to choose how much FIFO to reserve for each
  sensor. To help with this choice, here is a list of possible applications
  when batching is implemented on the different sensors.</p>
<h3 id="high_value_low_power_pedestrian_dead_reckoning">High value: Low power
  pedestrian dead reckoning</h3>
<p>Target batching time: 1 to 10 minutes</p>
<p>Sensors to batch:</p>
<ul>
  <li>Wake-up step detector</li>
  <li>Wake-up game rotation vector at 5&nbsp;Hz</li>
  <li>Wake-up barometer at 5&nbsp;Hz</li>
  <li>Wake-up uncalibrated magnetometer at 5&nbsp;Hz</li>
</ul>
<p>Batching this data allows performing pedestrian dead reckoning while letting
  the AP go to suspend.</p>
<h3 id="high_value_medium_power_intermittent_activity_gesture_recognition">High
  value: Medium power intermittent activity/gesture recognition</h3>
<p>Target batching time: 3 seconds</p>
<p>Sensors to batch: Non-wake-up accelerometer at 50&nbsp;Hz</p>
<p>Batching this data allows periodically recognizing arbitrary activities and
  gestures without having to keep the AP awake while the data is collected.</p>
<h3 id="medium_value_medium_power_continuous_activity_gesture_recognition">
  Medium value: Medium power continuous activity/gesture recognition</h3>
<p>Target batching time: 1 to 3 minutes</p>
<p>Sensors to batch: Wake-up accelerometer at 50&nbsp;Hz</p>
<p>Batching this data allows continuously recognizing arbitrary activities and
  gestures without having to keep the AP awake while the data is collected.</p>
<h3 id="medium-high_value_interrupt_load_reduction">
  Medium-high value: Interrupt load reduction</h3>
<p>Target batching time: &lt; 1 second</p>
<p>Sensors to batch: any high-frequency sensor, usually non-wake-up.</p>
<p>If the gyroscope is set at 240&nbsp;Hz, even batching just 10 gyro events can
  reduce the number of interrupts from 240/second to 24/second.</p>
<h3 id="medium_value_continuous_low_frequency_data_collection">
  Medium value: Continuous low-frequency data collection</h3>
<p>Target batching time: 1 to 10 minutes</p>
<p>Sensors to batch:</p>
<ul>
  <li>Wake-up barometer at 1&nbsp;Hz</li>
  <li>Wake-up humidity sensor at 1&nbsp;Hz</li>
  <li>Other low-frequency wake-up sensors at similar rates</li>
</ul>
<p>Allows creating monitoring applications at low power.</p>
<h3 id="medium-low_value_continuous_full-sensors_collection">
  Medium-low value: Continuous full-sensors collection</h3>
<p>Target batching time: 1 to 10 minutes</p>
<p>Sensors to batch: All wake-up sensors, at high frequencies</p>
<p>Allows full collection of sensor data while leaving the AP in suspend mode.
  Only consider if FIFO space isn't an issue.</p>

  </body>
</html>
