<html devsite>
  <head>
    <title>BufferQueue and Gralloc</title>
    <meta name="project_path" value="/_project.yaml" />
    <meta name="book_path" value="/_book.yaml" />
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<p>The BufferQueue class connects components that generate buffers of graphical
data (<em>producers</em>) to components that accept the data for display or further
processing (<em>consumers</em>). Nearly everything that moves buffers of
graphical data through the system relies on BufferQueue.</p>

<p>The Gralloc memory allocator performs buffer allocations and is
implemented through two vendor-specific HIDL interfaces (see
<code>hardware/interfaces/graphics/allocator/</code> and
<code>hardware/interfaces/graphics/mapper/</code>). The
<code>allocate()</code> function takes expected arguments (width, height, pixel
format) as well as a set of usage flags.</p>

<h2 id="BufferQueue">BufferQueue producers and consumers</h2>

<p>Consumers create and own the BufferQueue data structure and can exist in
different processes than their producers. When a producer needs a buffer, it
requests a free buffer from BufferQueue by calling
<code>dequeueBuffer()</code>, specifying the buffers's width, height,
pixel format, and usage flags. The producer then populates the buffer and
returns the buffer to the queue by calling <code>queueBuffer()</code>. Next,
the consumer acquires the buffer with <code>acquireBuffer()</code> and makes
use of the buffer contents. When the consumer is done, it returns the buffer to
the queue by calling <code>releaseBuffer()</code>. The <a
href="/devices/graphics#synchronization_framework">sync framework</a> controls
how buffers move through the Android graphics pipeline.</p>

<p>Some characteristics of the BufferQueue, such as the maximum number of
buffers it can hold, are determined jointly by the producer and the consumer.
However, the BufferQueue allocates buffers as it needs them.
Buffers are retained unless the characteristics change; for example, if a
producer requests buffers with a different size, old buffers are freed and new
buffers are allocated on demand.</p>

<p>Buffer contents are never copied by BufferQueue, as moving that much data
around is inefficient. Instead, buffers are always passed by a handle.</p>

<h3 id="tracking">Tracking BufferQueue with Systrace</h3>

<p>To understand how graphics buffers move around, use <a
href="https://developer.android.com/studio/profile/systrace" class="external">
Systrace</a>, a tool that records device activity over a short period of time.
The system-level graphics code is well instrumented, as is much of the relevant
app framework code.</p>

<p>To use Systrace, enable the <code>gfx</code>, <code>view</code>, and
<code>sched</code> tags. BufferQueue objects are displayed in the trace.
As an example, if you take a trace while
<a href="https://github.com/google/grafika/blob/master/app/src/main/java/com/android/grafika/PlayMovieSurfaceActivity.java"
class="external">Grafika's Play
video (SurfaceView)</a> is running, the row labeled <em>SurfaceView</em> tells you
how many buffers were queued up at any given time.</p>

<p>The value increments while the app is active, which triggers the rendering
of frames by the MediaCodec decoder. The value decrements while SurfaceFlinger
is working and consuming buffers. When showing video at 30&nbsp;fps, the queue's value
varies from 0 to 1 because the ~60&nbsp;fps display can keep up with the source.
SurfaceFlinger wakes only when there's work to be done, not 60 times per second.
The system tries to avoid work and disables VSYNC if nothing
is updating the screen.</p>

<p>If you switch to <a href="https://github.com/google/grafika/blob/master/app/src/main/java/com/android/grafika/PlayMovieActivity.java"
class="external">Grafika's Play video (TextureView)</a> and grab a new trace,
you see a row labeled
<code>com.android.grafika</code>&hairsp;/&hairsp;<code>com.android.grafika.PlayMovieActivity</code>.
This is the main UI layer, which is another BufferQueue. Because TextureView
renders into the UI layer rather than a separate layer, all of the
video-driven updates are displayed here.</p>

<h2 id="gralloc_HAL">Gralloc</h2>

<p>The Gralloc allocator HAL
<code>hardware/libhardware/include/hardware/gralloc.h</code>
performs buffer allocations though usage flags. Usage flags include attributes
such as:</p>

<ul>
<li>How often the memory will be accessed from software (CPU)</li>
<li>How often the memory will be accessed from hardware (GPU)</li>
<li>Whether the memory will be used as an OpenGL ES (GLES) texture</li>
<li>Whether the memory will be used by a video encoder</li>
</ul>

<p>For example, if a producer's buffer format specifies <code>RGBA_8888</code> pixels, and
the producer indicates that the buffer will be accessed from software (meaning an app
will touch pixels on the CPU), Gralloc creates a buffer with 4&nbsp;bytes per pixel
in R-G-B-A order. If instead, a producer specifies its buffer will be only
accessed from hardware and as a GLES texture, Gralloc can do anything the GLES
driver wants, such as BGRA ordering, nonlinear swizzled layouts, and alternative
color formats. Allowing the hardware to use its preferred format can
improve performance.</p>

<p>Some values can't be combined on certain platforms. For example, the video
encoder flag may require YUV pixels, so adding software access and specifying
<code>RGBA_8888</code> fails.</p>

<p>The handle returned by Gralloc can be passed between processes
through Binder.</p>

<h3 id="protected_buffers">Protected buffers</h3>

<p>The Gralloc usage flag <code>GRALLOC_USAGE_PROTECTED</code> allows the
graphics buffer to be displayed only through a hardware-protected path. These
overlay planes are the only way to display DRM content (DRM-protected buffers
can't be accessed by SurfaceFlinger or the OpenGL ES driver).</p>

<p>DRM-protected video can be presented only on an overlay plane. Video players
that support protected content must be implemented with SurfaceView. Software
running on unprotected hardware can't read or write the buffer;
hardware-protected paths must appear on the Hardware Composer overlay (that is,
protected videos disappear from the display if Hardware Composer switches
to OpenGL ES composition).</p>

<p>For details on protected content, see <a href="/devices/drm">DRM</a>.</p>

  </body>
</html>
