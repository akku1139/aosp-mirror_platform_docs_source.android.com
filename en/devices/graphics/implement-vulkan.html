<html devsite>
  <head>
    <title>Implementing Vulkan</title>
    <meta name="project_path" value="/_project.yaml" />
    <meta name="book_path" value="/_book.yaml" />
  </head>
  <body>
    {% include "_versions.html" %}
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->


<p>Vulkan is a low-overhead, cross-platform API for high-performance 3D
graphics. Like OpenGL ES (GLES), Vulkan provides tools for creating high-quality,
real-time graphics in apps. Advantages of using Vulkan include reductions in CPU
overhead and support for the <a href="https://www.khronos.org/spir"
class="external">SPIR-V Binary Intermediate</a> language.</p>

<aside class="note"><strong>Note:</strong> This section describes Vulkan
implementation; for details on Vulkan architecture, advantages, API, and other
resources, see <a href="/devices/graphics/arch-vulkan.html">Vulkan
Architecture</a>.</aside>

<p>To implement Vulkan successfully, a device must include:</p>
<ul>
<li>The Vulkan loader, provided by Android.</li>
<li>A Vulkan driver, provided by SoCs such as GPU IHVs, that
implements the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0-wsi_extensions/xhtml/vkspec.html"
class="external">Vulkan API</a>. To support Vulkan functionality, the Android
device needs Vulkan-capable GPU hardware and the associated driver. The GPU
must also support GLES 3.1 and higher. Consult your SoC vendor to
request driver support.</li>
</ul>

<p>If a device includes a Vulkan driver, the device needs to declare
<code>FEATURE_VULKAN_HARDWARE_LEVEL</code> and
<code>FEATURE_VULKAN_HARDWARE_VERSION</code> system features, with versions that
accurately reflect the capabilities of the device. This helps ensure that the
  device is in compliance with
the <a href="/compatibility/cdd">Compatibility Definition Document</a> (CDD).
</p>

<h2 id="vulkan_loader">Vulkan loader</h2>

<p>The Vulkan loader <code>platform/frameworks/native/vulkan</code> is the
primary interface between Vulkan apps and a device's Vulkan driver. The Vulkan
loader is installed at <code>/system/lib[64]/libvulkan.so</code>. The loader
provides the core Vulkan API entry points, as well as the entry points of
extensions required by the Android CDD. Window System Integration (WSI)
extensions are exported by the loader and primarily implemented in the loader
rather than in the driver. The loader also supports enumerating and loading
layers that can expose additional extensions and intercept core API calls on
their way to the driver.</p>

<p>The NDK includes a stub <code>libvulkan.so</code> library for
linking. The library exports the same symbols as the loader. Apps call the functions
exported from the real <code>libvulkan.so</code> library to
enter trampoline functions in the loader, which dispatch to the appropriate
layer or driver based on their first argument. The <code>vkGet*ProcAddr()</code>
call returns the function pointers to which the trampolines dispatch (that is,
it calls directly into the core API code). Calling through the function
pointers, rather than the exported symbols, is more efficient as it
skips the trampoline and dispatch.</p>

<h3 id="driver_emun">Driver enumeration and loading</h3>

<p>When the system image is built, Android expects the system to know which GPUs
are available. The loader uses the existing HAL mechanism in
<code><a href="https://android.googlesource.com/platform/hardware/libhardware/+/master/include/hardware/hardware.h" class="external">hardware.h</code></a>
to discover and load the driver. Preferred paths for 32-bit and 64-bit Vulkan drivers are:</p>

<pre class="devsite-click-to-copy">
/vendor/lib/hw/vulkan.&lt;ro.hardware.vulkan&gt;.so
/vendor/lib/hw/vulkan.&lt;ro.product.platform&gt;.so
/vendor/lib64/hw/vulkan.&lt;ro.hardware.vulkan&gt;.so
/vendor/lib64/hw/vulkan.&lt;ro.product.platform&gt;.so
</pre>

<aside class="note"><strong>Note:</strong>
<code>&lt;ro.hardware.vulkan&gt;</code> and
<code>&lt;ro.product.platform&gt;</code> are replaced by the value of the system
property of that name. For details and supported alternative locations, refer to
<a href="https://android.googlesource.com/platform/hardware/libhardware/+/master/hardware.c"
class="external"><code>libhardware/hardware.c</code></a>.</aside>

<p>In Android 7.0 and higher, the Vulkan <code>hw_module_t</code> derivative
wraps a single <code>hw_module_t</code> struct; only one driver is supported and the constant string
<code>HWVULKAN_DEVICE_0</code> is passed to <code>open()</code>.</p>

<p>The Vulkan <code>hw_device_t</code> derivative corresponds to a single
driver that can support multiple physical devices. The
<code>hw_device_t</code> structure can extend to export
<code>vkGetGlobalExtensionProperties()</code>, <code>vkCreateInstance()</code>, and
<code>vkGetInstanceProcAddr()</code> functions. The loader can find all other
<code>VkInstance()</code>, <code>VkPhysicalDevice()</code>, and
<code>vkGetDeviceProcAddr()</code> functions by calling
the <code>hw_device_t</code> structure's <code>vkGetInstanceProcAddr()</code>.</p>

<h3 id="layer_discover">Layer discovery and loading</h3>

<p>The Vulkan loader supports enumerating and loading layers that can expose
additional extensions and intercept core API calls on their way to the
driver. Android doesn't include layers on the system image; however,
apps may include layers in their APK.</p>

<p>When using layers, keep in mind that Android's security model and policies
differ significantly from other platforms. In particular, Android doesn't allow
loading external code into a nondebuggable process on production (nonrooted)
devices, nor does it allow external code to inspect or control the process's
memory, state, and so on. This includes a prohibition on saving core dumps, API
traces, and so on to disk for later inspection. Only layers delivered as part of
nondebuggable apps are enabled on production devices, and drivers must not provide
functionality that violates these policies.</p>

<p>Use cases for layers include:</p>
<ul>
<li><strong>Development-time layers</strong> &mdash; Validation
layers and shims for tracing/profiling/debugging tools shouldn't be installed on
the system image of production devices. Validation layers and shims for
tracing/profiling/debugging tools should be updatable without a system
image. Developers who want to use one
of these layers during development can modify the app package, for example,
by adding a file to their native libraries directory. IHV and OEM engineers who
want to diagnose failures in shipping unmodifiable apps are assumed to have
access to nonproduction (rooted) builds of the system image, unless those apps
are debuggable. For more information see <a
href="https://developer.android.com/ndk/guides/graphics/validation-layer#vl-adb"
class="external">Vulkan validation layers on Android</a>.</li>
<li><strong>Utility layers</strong> &mdash; These layers expose
extensions, such as a layer that implements a memory manager for device memory.
Developers choose layers, and versions of those layers, to use in their
app; different apps using the same layer may still use
different versions. Developers choose which of these layers to ship in their
app package.</li>
<li><strong>Injected (implicit) layers</strong> &mdash; Includes layers such as
frame rate, social network, and game launcher overlays provided by the user or
some other app without the app's knowledge or consent. These
violate Android's security policies and aren't supported.</li>
</ul>

<p>For nondebuggable apps, the loader searches for layers only in the
app's native library directory and attempts to load any library with a name
matching a particular pattern (for example, <code>libVKLayer_foo.so</code>).</p>

<p>For debuggable apps, the loader searches for layers in
<code>/data/local/debug/vulkan</code> and attempts to load any library matching
a particular pattern.</p>

<p>Android enables layers to be ported with build-environment changes between
Android and other platforms. For details on the interface between layers and the
loader, see
<a href="https://github.com/KhronosGroup/Vulkan-Loader/blob/master/loader/LoaderAndLayerInterface.md" class="external">
Architecture of the Vulkan Loader Interfaces</a>. The Khronos-maintained
validation layers are hosted in
<a href="https://github.com/KhronosGroup/Vulkan-ValidationLayers"
class="external">Vulkan Validation Layers</a>.</p>


<h2 id="versions">Vulkan API versions and capabilities</h2>

<p>Android 9 and higher support the Vulkan API version
1.1. Android 7 to Android 9 support the Vulkan API version 1.0.
For more information about the Vulkan 1.1 API, see the
<a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html"
class="external">Vulkan 1.1 API spec</a>.</p>

<h4>Vulkan 1.1 support overview</h4>

<p>Vulkan 1.1 includes support for memory/synchronization interop, which
enables OEMs to support Vulkan 1.1 on devices. Additionally,
memory/synchronization interop enables developers
to determine whether Vulkan 1.1 is supported on a device, and use it effectively
when it is. Vulkan 1.1 has the same hardware requirements as Vulkan 1.0, but most of the
implementation is in the SOC-specific graphics driver, not in the framework.</p>

<p>The most important Vulkan 1.1 features for Android are:</p>

<ul>
<li>Support for importing and exporting memory buffers and synchronization
objects from outside Vulkan (for interop with camera, codecs, and GLES)</li>
<li>Support for YCbCr formats</li>
</ul>

<p>Vulkan 1.1 also includes several smaller features and API usability
enhancements.</p>

<h4>Implementing Vulkan 1.1</h4>

<p>Android devices should support Vulkan 1.1 if they:</p>

<ul>
  <li>Launch with Android {{ androidQVersionNumber }}.</li>
  <li>Support a 64-bit ABI.</li>
  <li>Aren't low memory.</li>
</ul>

<p>Other devices can optionally support Vulkan 1.1.</p>

<p>To implement Vulkan 1.1:</p>

<ol>
<li>Add a Vulkan driver that supports Vulkan 1.1 plus the additional Android 1.1
<a href="/compatibility/cdd">CDD requirements</a>, or update the existing Vulkan
1.0 driver.</li>
<li>Ensure that
<code>PackageManager#hasSystemFeature(PackageManager.FEATURE_VULKAN_HARDWARE_VERSION, 0x401000)</code>
returns
<code>true</code> by adding a rule such as the following to an appropriate
<code>device.mk</code> file:
<pre class="prettyprint">PRODUCT_COPY_FILES += frameworks/native/data/etc/android.hardware.vulkan.version-1_1.xml:
$(TARGET_COPY_OUT_VENDOR)/etc/permissions/android.hardware.vulkan.version.xml
</pre></li>
</ol>

<aside class="note"><strong>Note:</strong> Apps that depend on Vulkan 1.1 can
run only on devices that support Vulkan 1.1. Some apps might not require
Vulkan 1.1 but provide additional features or performance when it's
present.</aside>

<h2 id="wsi">Window System Integration (WSI)</h2>

<p>In <code>libvulkan.so</code>, the driver implements the following
Window System Integration (WSI) extensions:</p>

<ul>
  <li><code>VK_KHR_surface</code></li>
  <li><code>VK_KHR_android_surface</code></li>
  <li><code>VK_KHR_swapchain</code></li>
  <li><code>VK_KHR_driver_properties</code>, implemented for Vulkan 1.1 in
    Android {{ androidQVersionNumber}} only</li>
  <li><code>VK_GOOGLE_display_timing</code>, implemented for any Vulkan version
    in Android {{ androidQVersionNumber}}</li>
</ul>

<p>The <code>VkSurfaceKHR</code> and <code>VkSwapchainKHR</code> objects and all
interactions with <code>ANativeWindow</code> are handled by the platform and aren't
exposed to drivers. The WSI implementation relies on the
<code>VK_ANDROID_native_buffer</code> extension, which must be
supported by the driver; this extension is used only by the WSI implementation
and isn't exposed to apps.</p>

<h3 id="gralloc_usage_flags">Gralloc usage flags</h3>

<p>Vulkan implementations may need swapchain buffers to be allocated with
implementation-defined private Gralloc usage flags. When creating a swapchain,
Android asks the driver to translate the requested format and image usage
flags into Gralloc usage flags by calling:</p>

<pre class="devsite-click-to-copy">
typedef enum VkSwapchainImageUsageFlagBitsANDROID {
    VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID = 0x00000001,
    VK_SWAPCHAIN_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSwapchainImageUsageFlagBitsANDROID;
typedef VkFlags VkSwapchainImageUsageFlagsANDROID;

VkResult VKAPI vkGetSwapchainGrallocUsage2ANDROID(
    VkDevice                          device,
    VkFormat                          format,
    VkImageUsageFlags                 imageUsage,
    VkSwapchainImageUsageFlagsANDROID swapchainUsage,
    uint64_t*                         grallocConsumerUsage,
    uint64_t*                         grallocProducerUsage
);
</pre>

<p>The <code>format</code> and <code>imageUsage</code> parameters are taken from
the <code>VkSwapchainCreateInfoKHR</code> structure. The driver should fill
<code>*grallocConsumerUsage</code> and <code>*grallocProducerUsage</code> with
the Gralloc usage flags required for the format
and usage. The usage flags returned by the driver are combined with the usage
flags requested by the swapchain consumer when allocating buffers.</p>

<p>Android 7.x calls an earlier version of <code>VkSwapchainImageUsageFlagsANDROID()</code>,
named <code>vkGetSwapchainGrallocUsageANDROID()</code>. Android 8.0 and higher deprecates
<code>vkGetSwapchainGrallocUsageANDROID()</code> but still calls
<code>vkGetSwapchainGrallocUsageANDROID()</code> if
<code>vkGetSwapchainGrallocUsage2ANDROID()</code> isn't provided by the driver:</p>

<pre class="devsite-click-to-copy">
VkResult VKAPI vkGetSwapchainGrallocUsageANDROID(
    VkDevice            device,
    VkFormat            format,
    VkImageUsageFlags   imageUsage,
    int*                grallocUsage
);
</pre>

<p><code>vkGetSwapchainGrallocUsageANDROID()</code> doesn't support swapchain usage
flags or extended Gralloc usage flags.</p>

<h3 id="gralloc_usage_flags">Gralloc-backed images</h3>

<p><code>VkNativeBufferANDROID</code> is a <code>vkCreateImage</code> extension
structure for creating an image backed by a Gralloc buffer. <code>VkNativeBufferANDROID</code> is
provided to <code>vkCreateImage()</code> in the <code>VkImageCreateInfo</code>
structure chain. Calls to <code>vkCreateImage()</code> with <code>VkNativeBufferANDROID</code> happen
during the first call to <code>vkGetSwapChainInfoWSI(..
VK_SWAP_CHAIN_INFO_TYPE_IMAGES_WSI ..)</code>. The WSI implementation allocates
the number of native buffers requested for the swapchain, then creates a
<code>VkImage</code> for each one:</p>

<pre class="devsite-click-to-copy">
typedef struct {
    VkStructureType             sType; // must be VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID
    const void*                 pNext;

    // Buffer handle and stride returned from gralloc alloc()
    buffer_handle_t             handle;
    int                         stride;

    // Gralloc format and usage requested when the buffer was allocated.
    int                         format;
    int                         usage;
    // Beginning in Android 8.0, the usage field above is deprecated and the
    // usage2 struct below was added. The usage field is still filled in for
    // compatibility with Android 7.0 drivers. Drivers for Android 8.0
    // should prefer the usage2 struct, especially if the
    // android.hardware.graphics.allocator HAL uses the extended usage bits.
    struct {
        uint64_t                consumer;
        uint64_t                producer;
    } usage2;
} VkNativeBufferANDROID;
</pre>

<p>When creating a Gralloc-backed image, <code>VkImageCreateInfo</code> has
the following data:</p>

<pre class="devsite-click-to-copy">
  .sType               = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
  .pNext               = the above VkNativeBufferANDROID structure
  .imageType           = VK_IMAGE_TYPE_2D
  .format              = a VkFormat matching the format requested for the gralloc buffer
  .extent              = the 2D dimensions requested for the gralloc buffer
  .mipLevels           = 1
  .arraySize           = 1
  .samples             = 1
  .tiling              = VK_IMAGE_TILING_OPTIMAL
  .usage               = VkSwapChainCreateInfoWSI::imageUsageFlags
  .flags               = 0
  .sharingMode         = VkSwapChainCreateInfoWSI::sharingMode
  .queueFamilyCount    = VkSwapChainCreateInfoWSI::queueFamilyCount
  .pQueueFamilyIndices = VkSwapChainCreateInfoWSI::pQueueFamilyIndices
</pre>

<p>In Android 8.0 and higher, the platform provides a
<code>VkSwapchainImageCreateInfo</code> extension structure in the
<code>VkImageCreateInfo</code> chain provided to <code>vkCreateImage</code>
when any swapchain image usage flags are required for the swapchain.
The extension structure contains the swapchain image usage flags:</p>

<pre class="devsite-click-to-copy">
typedef struct {
    VkStructureType                        sType; // must be VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID
    const void*                            pNext;

    VkSwapchainImageUsageFlagsANDROID      usage;
} VkSwapchainImageCreateInfoANDROID;
</pre>

<p>In Android {{ androidQVersionNumber }} and higher, the platform supports
<code>VK_KHR_swapchain</code> v70, so the Vulkan app is able to create a
<code>VkImage</code> backed by swapchain memory. The app first calls
<code>vkCreateImage</code> with a <code>VkImageSwapchainCreateInfoKHR</code>
structure chained to the <code>VkImageCreateInfo</code> structure. Then the
app calls <code>vkBindImageMemory2(KHR)</code> with a
<code>VkBindImageMemorySwapchainInfoKHR</code> structure chained to the
<code>VkBindImageMemoryInfo</code> structure. The <code>imageIndex</code>
specified in the <code>VkBindImageMemorySwapchainInfoKHR</code> structure must
be a valid swapchain image index. Meanwhile, the platform provides a
<code>VkNativeBufferANDROID</code> extension structure with the corresponding
Gralloc buffer information to the <code>VkBindImageMemoryInfo</code> chain, so
the driver knows which Gralloc buffer to bind the <code>VkImage</code> with.</p>

<h3 id="acquire_image">Acquiring images</h3>

<p><code>vkAcquireImageANDROID</code> acquires ownership of a swapchain image
and imports an externally signaled native fence into both an existing
<code>VkSemaphore</code> object and an existing <code>VkFence</code> object:</p>

<pre class="devsite-click-to-copy">
VkResult VKAPI vkAcquireImageANDROID(
    VkDevice            device,
    VkImage             image,
    int                 nativeFenceFd,
    VkSemaphore         semaphore,
    VkFence             fence
);
</pre>

<p><code>vkAcquireImageANDROID()</code> is called during
<code>vkAcquireNextImageKHR</code> to import a
native fence into the <code>VkSemaphore</code> and <code>VkFence</code> objects
provided by the app (however, both semaphore and fence objects are
optional in this call). The driver may also use this opportunity to recognize
and handle any external changes to the Gralloc buffer state; many drivers won't
need to do anything here. This call puts <code>VkSemaphore</code> and
<code>VkFence</code> into the same pending state as
<code>vkQueueSignalSemaphore</code> and <code>vkQueueSubmit</code> respectively,
so queues can wait on the semaphore and the app can wait on the fence.</p>

<p>Both objects become signaled when the underlying native fence signals; if
the native fence has already signaled, then the semaphore is in the signaled
state when this function returns. The driver takes ownership of the fence file
descriptor and closes the fence file descriptor when no longer needed. The driver
must do so even if neither a semaphore or fence object is provided, or even if
<code>vkAcquireImageANDROID</code> fails and returns an error. If
<code>fenceFd</code> is -1, it's as if the native fence was already
signaled.</p>

<h3 id="acquire_image">Releasing images</h3>
<p><code>vkQueueSignalReleaseImageANDROID</code> prepares a swapchain image for
external use, creates a native fence, and schedules the native fence to be signaled after
the input semaphores have signaled:</p>

<pre class="devsite-click-to-copy">
VkResult VKAPI vkQueueSignalReleaseImageANDROID(
    VkQueue             queue,
    uint32_t            waitSemaphoreCount,
    const VkSemaphore*  pWaitSemaphores,
    VkImage             image,
    int*                pNativeFenceFd
);
</pre>


<p><code>vkQueuePresentKHR()</code> calls <code>vkQueueSignalReleaseImageANDROID()</code>
on the provided queue. The driver must produce a native fence that doesn't signal
until all <code>waitSemaphoreCount</code> semaphores in
<code>pWaitSemaphores</code> signal, and any additional work required to
prepare <code>image</code> for presentation completes.</p>

<p>If the wait semaphores (if any) already signaled, and <code>queue</code> is
already idle, the driver can set <code>*pNativeFenceFd</code>
 to <code>-1</code> instead of an actual native fence file descriptor, indicating that
there's nothing to wait for. The caller owns and closes the file descriptor
returned in <code>*pNativeFenceFd</code>.</p>

<p>Many drivers can ignore the image parameter, but some may need to prepare
CPU-side data structures associated with a Gralloc buffer for use by external
image consumers. Preparing buffer contents for use by external consumers should
be done asynchronously as part of transitioning the image to
<code>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code>.</p>

<p>If the image was created with
<code>VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID</code>, then the driver must
allow <code>vkQueueSignalReleaseImageANDROID()</code> to be called repeatedly
without intervening calls to <code>vkAcquireImageANDROID()</code>.</p>

<h3 id="shared_presentable_image">Shared presentable image support</h3>

<p>Some devices can share ownership of a single image between
the display pipeline and the Vulkan implementation to minimize latency.
In Android 9 and higher, the loader conditionally advertises the
<code>VK_KHR_shared_presentable_image</code> extension based on the driver's
response to a call to <code>vkGetPhysicalDeviceProperties2</code>.</p>

<p>If the driver doesn't support either Vulkan 1.1 or the
<code>VK_KHR_physical_device_properties2</code> extension, the loader doesn't
advertise support for shared presentable images. Otherwise, the loader queries
the driver capabilities by calling <code>vkGetPhysicalDeviceProperties2()</code>
and including the following structure in the
<code>VkPhysicalDeviceProperties2::pNext</code> chain:</p>

<pre class="devsite-click-to-copy">
typedef struct {
    VkStructureType sType; // must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID
    const void*     pNext;
    VkBool32        sharedImage;
} VkPhysicalDevicePresentationPropertiesANDROID;
</pre>

<p>If the driver can share ownership of an image with the display
system, it sets the <code>sharedImage</code> member to <code>VK_TRUE</code>.</p>

<h2 id="validation">Validation</h2>

<p>OEMs can test their Vulkan implementation using CTS, which includes:</p>

<ul>
<li><a href="/devices/graphics/cts-integration">Khronos Vulkan Conformance tests</a>
in the <code>CtsDeqpTestCases</code> module,
which include functional API tests for Vulkan 1.0 and 1.1.</li>
<li>The <code>CtsGraphicsTestCases</code> module, which tests that the device is
configured correctly for Vulkan capabilities it supports.</li>
</ul>

</body>
</html>
