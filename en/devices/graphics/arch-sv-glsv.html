<html devsite>
  <head>
    <title>SurfaceView and GLSurfaceView</title>
    <meta name="project_path" value="/_project.yaml" />
    <meta name="book_path" value="/_book.yaml" />
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<p>The Android app framework UI is based on a hierarchy of objects that start
with a <a href="https://developer.android.com/reference/android/view/View"
class="external">View</a>. All UI elements go through a series of measurements
and a layout process that fits them into a rectangular area. Then, all visible
view objects are rendered to a surface that was set up by the
WindowManager when the app was brought to the foreground. The app's UI thread
performs layout and rendering to a buffer per frame.</p>

<h2 id="surfaceview">SurfaceView</h2>

<p>A SurfaceView is a component that you can use to embed an
additional composite layer within your view hierarchy. A SurfaceView takes the
same layout parameters as other views, so it can be manipulated like any other
view, but the SurfaceView's contents are transparent.</p>

<p>When you render with an external buffer source, such as GL context or a media
decoder, you need to copy buffers from the buffer source to display the buffers
on the screen. Using a SurfaceView enables you to do that.</p>

<p>When the SurfaceView's view component is about to become visible, the
framework asks SurfaceControl to request a new surface from SurfaceFlinger.
To receive callbacks when the surface is created or destroyed, use the
<a href="/devices/graphics/arch-sh#surfaceholder">SurfaceHolder</a> interface. By
default, the newly created surface is placed behind the app UI surface.
You can override the default Z-ordering to put the new surface on top.</p>

<p>Rendering with SurfaceView is beneficial in cases where you need to render
to a separate surface, such as when you render with the Camera API or an
OpenGL ES context. When you render with SurfaceView, SurfaceFlinger directly
composes buffers to the screen. Without a SurfaceView, you need to composite
buffers to an onscreen surface, which then gets composited to the screen, so
rendering with SurfaceView eliminates extra work. After rendering with
SurfaceView, use the UI thread to coordinate with the activity lifecycle
and make adjustments to the size or position of the view if needed. Then,
the Hardware Composer blends the app UI and the other layers.</p>

<p>The new surface is the producer side of a BufferQueue, whose consumer is a
SurfaceFlinger layer. You can update the surface with any mechanism that can
feed a BufferQueue, such as surface-supplied Canvas functions, attaching an
EGLSurface and drawing on the surface with GLES, or configuring a media
decoder to write the surface.</p>

<h2 id="activity">SurfaceView and the activity lifecycle</h2>

<p>When using a SurfaceView, render the surface
from a thread other than the main UI thread.</p>

<p>For an activity with a SurfaceView, there are two separate but interdependent
state machines:</p>

<ul>
  <li>App <code>onCreate</code>/<code>onResume</code>/<code>onPause</code></li>
<li>Surface created/changed/destroyed</li>
</ul>

<p>When the activity starts, you get callbacks in this order:</p>

<ol>
  <li><code>onCreate()</code></li>
  <li><code>onResume()</code></li>
  <li><code>surfaceCreated()</code></li>
  <li><code>surfaceChanged()</code></li>
</ol>

<p>If you click back, you get:</p>

<ol>
  <li><code>onPause()</code></li>
  <li><code>surfaceDestroyed()</code> (called just before the surface goes away)</li>
</ol>

<p>If you rotate the screen, the activity is torn down and recreated and you
get the full cycle. You can tell it's a quick restart by checking
<code>isFinishing()</code>. It's possible to start/stop an activity so
quickly that <code>surfaceCreated()</code> happens after
<code>onPause()</code>.</p>

<p>If you tap the power button to blank the screen, you get only
<code>onPause()</code> without <code>surfaceDestroyed()</code>. The surface
remains active, and rendering can continue. You can keep getting
Choreographer events if you continue to request them. If you have a lock
screen that forces a different orientation, your activity may be restarted when
the device is unblanked. Otherwise, you can come out of screen-blank with the
same surface as before.</p>

<p>The lifespan of the thread can be tied to the surface or to the activity,
depending on what you want to happen when the screen goes blank. The thread
can start/stop either on Activity start/stop or on surface create/destroy.</p>

<p>Having the thread start/stop on Activity start/stop works well with the app
lifecycle. You start the renderer thread
in <code>onResume()</code> and stop it in <code>onStop()</code>.
When creating and configuring the thread, sometimes the surface
already exists, othertimes it doesn't (for example, it's still active after toggling
the screen with the power button). You have to wait for the surface to be created
before initializing in the thread. You can't initialize in the
<code>surfaceCreate()</code> callback because it won't fire again if the surface
wasn't recreated. Instead, query or cache the surface
state, and forward it to the renderer thread.</p>

<aside class="note"><strong>Note:</strong> Be careful when passing objects
between threads. It is best to pass the surface or SurfaceHolder through a
Handler message (rather than just stuffing it into the thread) to avoid issues
on multicore systems. For details, refer to
<a href="http://developer.android.com/training/articles/smp.html">SMP Primer
for Android</a>.</aside>

<p>Having the thread start/stop on surface create/destroy works well because
the surface and the renderer are logically
intertwined. You start the thread after the surface is created, which
avoids some interthread communication concerns; and surface created/changed
messages are simply forwarded. To ensure that rendering stops when the screen
goes blank and resumes when it un-blanks, tell Choreographer to stop invoking
the frame draw callback. <code>onResume()</code> resumes the callbacks if the
renderer thread is running. However, if you animate
based on elapsed time between frames, there could be a large gap before the
next event arrives; using an explicit pause/resume message can solve this issue.</p>

<aside class="note"><strong>Note:</strong> For an example of having a thread
start/stop on surface create/destory, see <a
href="https://github.com/google/grafika/blob/master/app/src/main/java/com/android/grafika/HardwareScalerActivity.java"
class="external">Grafika's Hardware scaler activity</a>.</aside>

<p>Both options, whether the lifespan of the thread is tied to the Activity
or the surface, focus on how the renderer thread is
configured and whether it's executing. A related concern is extracting state
from the thread when the activity is killed (in <code>onStop()</code> or
<code>onSaveInstanceState()</code>); in such cases, tying the lifespan of the
thread to the activity works best because
after the renderer thread has been joined, the rendered thread's state can be
accessed without synchronization primitives.</p>

<h2 id="glsurfaceview">GLSurfaceView</h2>

<p>The <a href="https://developer.android.com/reference/android/opengl/GLSurfaceView?hl=en"
class="external">GLSurfaceView</a> class provides helper classes for managing EGL contexts,
interthread communication, and interaction with the activity lifecycle.
You don't need to use a GLSurfaceView to use GLES.</p>

<p>For example, GLSurfaceView creates a thread for rendering and configures an
EGL context there. The state is cleaned up automatically when the activity
pauses. Most apps don't need to know anything about EGL to use GLES with
GLSurfaceView.</p>

<p>In most cases, GLSurfaceView can make working with GLES
easier. In some situations, it can get in the way.</p>

  </body>
</html>
