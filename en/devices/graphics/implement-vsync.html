<html devsite>
  <head>
    <title>VSYNC</title>
    <meta name="project_path" value="/_project.yaml" />
    <meta name="book_path" value="/_book.yaml" />
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->


<p>The VSYNC signal synchronizes the display pipeline. The display
pipeline consists of app rendering, SurfaceFlinger composition, and the Hardware
Composer (HWC) presenting images on the display. VYSNC synchronizes the
time apps wake up to start rendering, the time SurfaceFlinger wakes up to
composite the screen, and the display refresh cycle. This synchronization
eliminates stutter and improves the visual performance of graphics.</p>

<p>The HWC generates VSYNC events and sends the events to SurfaceFlinger through
the callback:</p>

<pre class="prettyprint">
typedef void (*HWC2_PFN_VSYNC)(hwc2_callback_data_t callbackData,
        hwc2_display_t display, int64_t timestamp);
</pre>

<aside class="note"><strong>Note:</strong> The HWC triggers
<code>hwc2_callback_data_t</code> from a thread of
<code>HAL_PRIORITY_URGENT_DISPLAY</code> with as little latency as possible,
typically less than 0.5&nbsp;ms.</aside>

<p>SurfaceFlinger controls whether or not the HWC generates VSYNC events by
calling to <code>setVsyncEnabled</code>. SurfaceFlinger enables
<code>setVsyncEnabled</code> to generate VSYNC events so it can synchronize with
the refresh cycle of the display. When SurfaceFlinger is synchronized to the
display refresh cycle, SurfaceFlinger disables <code>setVsyncEnabled</code> to
stop the HWC from generating VSYNC events. If SurfaceFlinger detects a
difference between the actual VSYNC and the VSYNC it previously established
SurfaceFlinger re-enables VSYNC event generation.</p>


<h2 id=vsync_offset>VSYNC offset</h2>

<p>The sync app and SurfaceFlinger render loops to the
hardware VSYNC. On a VSYNC event, the display begins showing frame <em>N</em> while
SurfaceFlinger begins compositing windows for frame <em>N+1</em>. The app handles
pending input and generates frame <em>N+2</em>.</p>

<p>Synchronizing with VSYNC delivers consistent latency. It reduces errors in
apps and SurfaceFlinger and minimizes displays drifting in and out of phase with
each other. This, assumes app and SurfaceFlinger per-frame
times don’t vary widely. The latency is at least two frames.</p>

<p>To remedy this, you can employ VSYNC offsets to reduce the input-to-display
latency by making app and composition signal relative to hardware
VSYNC. This is possible because app plus composition usually takes less
than 33&nbsp;ms.</p>

<p>The result of VSYNC offset is three signals with same period and offset
phase:</p>

<ul>
<li><code>HW_VSYNC_0</code> &mdash; Display begins showing next frame.</li>
<li><code>VSYNC</code> &mdash; App reads input and generates next frame.</li>
<li><code>SF_VSYNC</code> &mdash; SurfaceFlinger begins compositing for next frame.</li>
</ul>

<p>With VSYNC offset, SurfaceFlinger receives the buffer and composites the
frame while the app simultaneously processes the input and renders
the frame.</p>

<aside class="note"><strong>Note:</strong> VSYNC offsets reduce the time available
for app and composition, providing a greater chance for error.</aside>

<h3 id=dispsync>DispSync</h3>

<p>DispSync maintains a model of the periodic hardware-based VSYNC events of a
display and uses that model to execute callbacks at specific phase
offsets from the hardware VSYNC events.</p>

<p>DispSync is a software phase-lock loop (PLL) that generates the
VSYNC and SF_VSYNC signals used by Choreographer and SurfaceFlinger, even if
not offset from hardware VSYNC.</p>

<img src="images/dispsync.png" alt="DispSync flow">

<p class="img-caption"><strong>Figure 1.</strong> DispSync flow</p>

<p>DispSync has the following qualities:</p>

<ul>
<li><em>Reference</em> &mdash; HW_VSYNC_0.</li>
<li><em>Output</em> &mdash; VSYNC and SF_VSYNC.</li>
<li><em>Feedback</em> &mdash; Retire fence signal timestamps from Hardware Composer.
</li>
</ul>

<h3 id=vsync_retire_offset>VSYNC/Retire offset</h3>

<p>The signal timestamp of retire fences must match HW VSYNC, even on devices
that don’t use the offset phase. Otherwise, errors appear to be more severe
than they are. Smart panels often have a delta where the retire fence is the end
of direct memory access (DMA) to display memory, but the actual display switch
and HW VSYNC is some time later.</p>

<p><code>PRESENT_TIME_OFFSET_FROM_VSYNC_NS</code> is set in the device’s
<code>BoardConfig.mk</code> makefile. It's based on the display controller and panel
characteristics. The time from the retire fence timestamp to the HW VSYNC
signal is measured in nanoseconds.</p>

<h3 id=vsync_and_sf_vsync_offsets>VSYNC and SF_VSYNC offsets</h3>

<p><code>VSYNC_EVENT_PHASE_OFFSET_NS</code> and
<code>SF_VSYNC_EVENT_PHASE_OFFSET_NS</code> are set conservatively based on
high-load use cases, such as partial GPU composition during window transition
or Chrome scrolling through a web page containing animations. These offsets
allow for long app render time and long GPU composition time.</p>

<p>More than a millisecond or two of latency is noticeable. To minimize latency
without significantly increasing error counts, integrate thorogh automated error
testing.</p>

<aside class="note"><strong>Note:</strong> VSYNC and SF_VSYNC offsets are also
configured in the device’s <code>BoardConfig.mk</code> file. Both settings are
offset in nanoseconds after <code>HW_VSYNC_0</code>, default to zero (if not set),
and can be negative.</aside>

  </body>
</html>
