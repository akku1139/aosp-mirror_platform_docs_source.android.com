<html devsite>
  <head>
    <title>Surface and SurfaceHolder</title>
    <meta name="project_path" value="/_project.yaml" />
    <meta name="book_path" value="/_book.yaml" />
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<p>Surface objects enable apps to render images to be presented on screens.
SurfaceHolder interfaces enable apps to edit and control surfaces.</p>

<h2 id="surface">Surface</h2>

<p>A <a href="https://developer.android.com/reference/android/view/Surface.html"
class="external">surface</a> is an interface for a producer to exchange buffers
with a consumer.</p>

<p>The BufferQueue for a display surface is typically configured for
triple-buffering. Buffers are allocated on demand, so if the producer
generates buffers slowly enough, such as at 30&nbsp;fps on a 60&nbsp;fps
display, there might only be two allocated buffers in the queue.
Allocating buffers on demand helps
minimize memory consumption. You can see a summary of the buffers associated
with every layer in the <code>dumpsys SurfaceFlinger</code> output.</p>

<p>Most clients render onto surfaces using <a
href="/devices/graphics/arch-egl-opengl">OpenGL ES</a> or <a
href="/devices/graphics/arch-vulkan">Vulkan</a>. However, some clients render
onto surfaces using a canvas.<p>

<h3 id="canvas">Canvas rendering</h3>

<p>The canvas implementation is provided by the
<a href="https://skia.org/" class="external">Skia Graphics Library</a>.
If you want to draw a rectangle, you call the Canvas API, which sets bytes in a
buffer appropriately. To ensure that a buffer isn't updated by two clients at
once, or written to while being displayed, lock the buffer to access
it. Use the following commands to work with canvas locks:

<ul>
  <li><a href="https://developer.android.com/reference/android/view/Surface.html#lockCanvas(android.graphics.Rect)"
class="external"><code>lockCanvas()</code></a> locks the buffer for rendering on the CPU
  and returns a Canvas to use for drawing.</li>
  <li><a href="https://developer.android.com/reference/android/view/Surface.html#unlockCanvasAndPost(android.graphics.Canvas)"
class="external"><code>unlockCanvasAndPost()</code></a> unlocks the buffer and
    sends it to the compositor.</li>
  <li><a href="https://developer.android.com/reference/android/view/Surface.html#lockHardwareCanvas()"
class="external"><code>lockHardwareCanvas()</code></a> locks the buffer for rendering on
    the GPU and returns a canvas to use for drawing.</li>
</ul>

<aside class="note"><strong>Note:</strong> The canvas obtained when an app locks
a surface with <code>lockCanvas()</code> is never hardware accelerated.</aside>

<aside class="caution"><strong>Caution:</strong> You can't draw on a surface
with GLES or send it frames from a video decoder if you've ever called
<code>lockCanvas()</code>. <code>lockCanvas()</code> connects the CPU
renderer to the producer side of the BufferQueue and doesn't disconnect until
the surface is destroyed. The canvas-based CPU renderer can't be disconnected
and reconnected to a surface, unlike most producers (like GLES or Vulkan).</aside>

<p>The first time the producer requests a buffer from a BufferQueue, the
buffer is
allocated and initialized to zero. Initialization is necessary to avoid
inadvertently sharing data between processes. However, if you reuse a buffer,
the previous contents are still present. If you repeatedly call
<code>lockCanvas()</code> and <code>unlockCanvasAndPost()</code> without
drawing anything, the producer cycles between previously rendered frames.</p>

<p>The surface lock/unlock code keeps a reference to the previously rendered
buffer. If you specify a dirty region when locking the surface, it copies
the nondirty pixels from the previous buffer. SurfaceFlinger or HWC typically
handle the buffer; but because we only need to read from
the buffer, there's no need to wait for exclusive access.</p>

<h2 id="surfaceholder">SurfaceHolder</h2>

<p>A <a href="https://developer.android.com/reference/android/view/SurfaceHolder.html"
class="external">SurfaceHolder</a> is an interface the system uses to share ownership of
surfaces with apps. Some clients that work with surfaces want a SurfaceHolder,
because APIs to get and set surface parameters are implemented through a
SurfaceHolder. A <a href="/devices/graphics/arch-sv-glsv">SurfaceView</a> contains
a SurfaceHolder.</p>

<p>Most components that interact with a view involve a SurfaceHolder.
Some other APIs, such as MediaCodec, operate on the surface itself.</p>

  </body>
</html>
