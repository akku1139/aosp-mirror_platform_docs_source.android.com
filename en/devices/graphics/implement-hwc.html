<html devsite>
  <head>
    <title>Implementing Hardware Composer HAL</title>
    <meta name="project_path" value="/_project.yaml" />
    <meta name="book_path" value="/_book.yaml" />
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->
{% include "_versions.html" %}

<p>The Hardware Composer (HWC) HAL composites layers received from
SurfaceFlinger, reducing the amount of composition OpenGL ES (GLES) and the GPU
perform.</p>

<p>The HWC abstracts objects, such as overlays and 2D blitters, to composite
surfaces and communicates with specialized window composition hardware to
composite windows. Use the HWC to composite windows instead of having
SurfaceFlinger composite with the GPU. Most GPUs aren't optimized for
composition, and when the GPU composes layers from
SurfaceFlinger, apps can't use the GPU for their own rendering.</p>

<p>HWC implementations should support:</p>

<ul>
  <li>At least four overlays:
    <ul>
      <li>Status bar</li>
      <li>System bar</li>
      <li>App</li>
      <li>Wallpaper/background</li>
    </ul></li>
  <li>Layers that are larger than the display (for example, a wallpaper)</li>
  <li>Simultaneous premultiplied per-pixel alpha blending and per-plane
    alpha blending</li>
  <li>Hardware path for protected video playback</li>
  <li>RGBA packing order, YUV formats, and tiling, swizzling, and stride
    properties</li>
</ul>

<p>To implement the HWC:</p>

<ol>
  <li>Implement a nonoperational HWC and send all composition work to
    GLES.</li>
  <li>Implement an algorithm to delegate composition to the HWC incrementally.
    For example, delegate only the first three or four surfaces to the overlay
    hardware of the HWC.</li>
  <li>Optimize the HWC. This may include:
    <ul>
      <li>Selecting surfaces that maximize the load taken off the GPU and
        sending them to the HWC.</li>
      <li>Detecting whether the screen is updating. If it isn't, delegate
        composition to GLES instead of the HWC to save power. When the screen
        updates again, continue to offload composition to the HWC.</li>
      <li>Preparing for common use cases such as:
        <ul>
          <li>The home screen, which includes the status bar, system bar, app
            window, and live wallpapers</li>
          <li>Full-screen games in portrait and landscape mode</li>
          <li>Full-screen video with closed captioning and playback
            control</li>
          <li>Protected video playback</li>
          <li>Split-screen multiwindow</li>
        </ul></li>
    </ul></li>
</ol>

<aside class="note"><strong>Note:</strong> Use cases should address regular,
  predictable cases instead of edge cases to maximize optimization benefits.
</aside>

<h2 id="primitives">HWC primitives</h2>

<p>The HWC provides two primitives, <a
href="/devices/graphics/arch-layers-display#layers">layers</a> and <a
href="/devices/graphics/arch-layers-display#display">displays</a>, to
represent composition work and its interaction with the display hardware. The
HWC also provides control over <a
href="/devices/graphics/implement-vsync">VSYNC</a> and a callback to SurfaceFlinger
to notify it when a VSYNC event occurs.</p>

<h2 id="hidl">HIDL interface</h2>

<p>Android 8.0 and higher uses a
<a href="/devices/architecture/hidl">HIDL</a> interface called Composer HAL for
binderized IPC between the HWC and SurfaceFlinger. The Composer HAL replaces the
legacy <code>hwcomposer2.h</code> interface. If vendors provide a Composer HAL
implementation of the HWC, Composer HAL directly accepts HIDL calls from
SurfaceFlinger. If vendors provide a legacy implementation of the HWC, Composer
HAL loads function pointers from <code>hwcomposer2.h</code>,
forwarding HIDL calls into function pointer calls.</p>

<p>The HWC provides functions to determine the properties of a given display; to
switch between different display configurations (such as 4k or 1080p
resolution) and color modes (such as native color or true sRGB); and to turn
the display on, off, or into a low-power mode if supported.</p>

<h3 id="func_pointers">Function pointers</h3>

<p>If vendors implement Composer HAL directly, SurfaceFlinger calls its functions
through HIDL IPC. For example, to create a layer, SurfaceFlinger calls
<code>createLayer()</code> on the Composer HAL.

<p>If vendors implement the <code>hwcomposer2.h</code> interface, Composer HAL
calls into <code>hwcomposer2.h</code> function pointers. In <code>hwcomposer2.h</code> comments,
HWC interface functions are
referred to by lowerCamelCase names that don't exist in the interface
as named fields. Almost every function is loaded by requesting a
function pointer using <code>getFunction</code> provided by
<code>hwc2_device_t</code>. For example, the function <code>createLayer</code>
is a function pointer of type <code>HWC2_PFN_CREATE_LAYER</code>, which is
returned when the enumerated value <code>HWC2_FUNCTION_CREATE_LAYER</code> is
passed into <code>getFunction</code>.</p>

<p>For detailed documentation on Composer HAL functions and HWC function passthrough
functions, see <a
href="https://android.googlesource.com/platform/hardware/interfaces/+/master/graphics/composer#"
class="external"><code>composer</code></a>. For detailed documentation on
HWC function pointers, see the
<a href="https://android.googlesource.com/platform/hardware/libhardware/+/master/include/hardware/hwcomposer2.h"
class="external"><code>hwcomposer2.h</code></a>.</p>

<h3 id="layer_display_handles">Layer and display handles</h3>

<p>Layers and displays are manipulated by handles generated by the HWC.
The handles are opaque to SurfaceFlinger.</p>

<p>When SurfaceFlinger creates a new layer, it calls <code>createLayer</code>,
which returns of type <code>Layer</code> for direct
implementations or <code>hwc2_layer_t</code> for passthrough implementations. When
SurfaceFlinger modifies a property of that layer, SurfaceFlinger passes
the <code>hwc2_layer_t</code> value into the appropriate modification function
along with any other information needed to make the modification. The
<code>hwc2_layer_t</code> type is large enough to hold either a pointer or an
index.</p>

<p>Physical displays are created by being hotplugged. When a physical display is
hotplugged, the HWC creates a handle and passes the handle to SurfaceFlinger
through the hotplug callback. Virtual displays are created by SurfaceFlinger
calling <code>createVirtualDisplay()</code> to request a display. If the HWC
supports virtual display composition, it returns a handle. Then, SurfaceFlinger
delegates the displays's composition to the HWC. If the HWC doesn't support virtual
display composition, SurfaceFlinger creates the handle and composites the display.</p>

<h2 id="display_comp_ops">Display composition operations</h2>

<p>Once per VSYNC, SurfaceFlinger wakes if it has new content to
composite. This new content can be new image buffers from apps or
a change in the properties of one or more layers. When SurfaceFlinger
wakes it:</p>

<ol>
  <li>Handles transactions, if present.</li>
  <li>Latches new graphic buffers, if present.</li>
  <li>Performs a new composition, if step 1 or 2 resulted in a change
    to the display contents.</li>
</ol>

<p>To perform a new composition, SurfaceFlinger creates and
destroys layers or modifies layer states, as applicable. It also updates
layers with their current contents, using calls such as
<code>setLayerBuffer</code> or <code>setLayerColor</code>. After all layers are
updated, SurfaceFlinger calls <code>validateDisplay</code>, which tells
the HWC to examine the state of the layers and determine how composition will
proceed. By default, SurfaceFlinger attempts to configure every layer
such that the layer is composited by the HWC; though in some
circumstances, SurfaceFlinger composites layers through the GPU fallback.</p>

<p>After the call to <code>validateDisplay</code>, SurfaceFlinger calls
<code>getChangedCompositionTypes</code> to see if the HWC
wants any of the layer composition types changed before performing the
composition. To accept the changes, SurfaceFlinger calls
<code>acceptDisplayChanges</code>.</p>

<p>If any layers are marked for SurfaceFlinger composition, SurfaceFlinger
composites them into the target buffer. SurfaceFlinger then calls
<code>setClientTarget</code> to give the buffer to the display so that the
buffer can be displayed on the screen or further composited with layers that
haven't been marked for SurfaceFlinger composition. If no layers are marked for
SurfaceFlinger composition, SurfaceFlinger bypasses the composition step.</p>

<p>Finally, SurfaceFlinger calls <code>presentDisplay</code> to tell
the HWC to complete the composition process and display the final result.</p>

<h2 id="multiple_displays">Multiple displays</h2>

<p>Android {{ androidQVersionNumber }} supports multiple physical displays.
When designing an HWC implementation intended for use on Android 7.0 and
higher, there are some restrictions not present in the HWC definition:
</p>

<ul>
<li>It's assumed that there's exactly one <em>internal</em> display. The internal
display is the display that the initial hotplug reports during
boot. After the internal display is hotplugged, it can't
be disconnected.</li>
<li>In addition to the internal display, any number of external displays may be hotplugged
during normal operation of the device. The framework assumes that all
hotplugs after the first internal display are external displays, so if any more
internal displays are added, they're categorized incorrectly as
<code>Display.TYPE_HDMI</code> instead of
<code>Display.TYPE_BUILT_IN</code>.</li>
</ul>

<p>While the SurfaceFlinger operations described above are performed
per-display, they're performed sequentially for all active displays,
even if the contents of only one display are updated.</p>

<p>For example, if the external display is updated, the sequence is:</p>

<pre class="devsite-click-to-copy">
// In Android {{ androidPVersionNumber }} and lower:

// Update state for internal display
// Update state for external display
validateDisplay(&lt;internal display&gt;)
validateDisplay(&lt;external display&gt;)
presentDisplay(&lt;internal display&gt;)
presentDisplay(&lt;external display&gt;)

// In Android {{ androidQVersionNumber }} and higher:

// Update state for internal display
// Update state for external display
validateInternal(&lt;internal display&gt;)
presentInternal(&lt;internal display&gt;)
validateExternal(&lt;external display&gt;)
presentExternal(&lt;external display&gt;)
</pre>

<h2 id="vdisplay-composition">Virtual display composition</h2>

<p>Virtual display composition is similar to  external display
composition. The difference between virtual display composition and physical
display composition is that virtual displays send output to a Gralloc buffer
instead of to the screen. Hardware Composer (HWC) writes the output to a buffer,
provides the completion fence, and sends the buffer to a consumer (such as the
video encoder, GPU, CPU, and so on). Virtual displays can use 2D/blitter or
overlays if the display pipeline writes to memory.</p>

<h3 id="modes">Modes</h3>

<p>Each frame is in one of three modes after SurfaceFlinger calls the
<code>validateDisplay()</code> HWC method:</p>

<ul>
<li><strong>GLES</strong> &mdash; The GPU composites all layers, writing
  directly to the output buffer. The HWC isn't involved in composition.</li>
<li><strong>MIXED</strong> &mdash; The GPU composites some layers to the
  framebuffer and HWC composites the framebuffer and the remaining layers,
  writing directly to the output buffer.</li>
<li><strong>HWC</strong> &mdash; HWC composites all layers and writes directly
  to the output buffer.</li>
</ul>

<h3 id="output_format">Output format</h3>

<p>Virtual display buffer output formats depend on their mode:</p>

<ul>
<li><strong>GLES mode</strong> &mdash; The EGL driver sets the output buffer
  format in <code>dequeueBuffer()</code>, typically <code>RGBA_8888</code>.
  The consumer must be able to accept the output format the driver sets or the
  buffer can't be read.</li>
<li><strong>MIXED and HWC modes</strong> &mdash; If the consumer needs CPU
  access, the consumer sets the format. Otherwise, the format is
  <code>IMPLEMENTATION_DEFINED</code>, and Gralloc sets the best format based on
  the usage flags. For example, Gralloc sets a YCbCr format if the consumer is
  video encoder and HWC can write the format efficiently.</li>
</ul>

<aside class="note"><strong>Note:</strong> Android {{ androidQVersionNumber }}
removes the requirement that <code>eglSwapBuffers()</code> dequeues buffers
after rendering begins. Buffers may be dequeued immediately.</aside>

<h2 id="sync_fences">Synchronization fences</h2>

<p>Synchronization (sync) fences are a crucial aspect of the Android graphics
system. Fences let CPU work proceed independently from concurrent GPU work,
blocking only when there's a true dependency.</p>

<p>For example, when an app submits a buffer that's being produced on
the GPU, it also submits a sync fence object. This fence signals when the
GPU has finished writing into the buffer.</p>

<p>The HWC requires that the GPU finish writing buffers before buffers are
displayed. Sync fences are passed through the graphics pipeline with buffers
and signal when buffers are written. Before a buffer is displayed, the HWC
checks if the sync fence has signaled, and if it has, it displays the
buffer.</p>

<p>For more information about sync fences see <a
href="/devices/graphics/sync#hardware_composer_integration">Hardware Composer
Integration</a>.</p>

  </body>
</html>
