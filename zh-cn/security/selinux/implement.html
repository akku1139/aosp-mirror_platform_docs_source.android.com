<html devsite><head>
    <title>实现 SELinux</title>
    <meta name="project_path" value="/_project.yaml"/>
    <meta name="book_path" value="/_book.yaml"/>
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<p>SELinux 被设置为“默认拒绝”模式，这表示，对于在内核中存在钩子的每一次访问，都必须获得政策的明确许可。这意味着政策文件中包含规则、类型、类、权限等方面的大量信息。关于 SELinux 的完整注意事项不在本文档的讨论范围之内，现在您必须要了解的是在启动新的 Android 设备时如何编写政策规则。目前有大量关于 SELinux 的信息可供您参考。关于建议的资源，请参阅<a href="/security/selinux#supporting_documentation">支持文档</a>。</p>

<h2 id="key_files">关键文件</h2>

<p>要启用 SELinux，请集成<a href="https://android.googlesource.com/kernel/common/" class="external">最新的 Android 内核</a>，然后整合 <a href="https://android.googlesource.com/platform/system/sepolicy/" class="external">system/sepolicy</a> 目录中的文件。这些文件在编译后会包含 SELinux 内核安全政策，并涵盖上游 Android 操作系统。</p>
<p>通常情况下，您不能直接修改 <code>system/sepolicy</code> 文件，但您可以添加或修改自己的设备专用政策文件（位于 <code>/device/<var>manufacturer</var>/<var>device-name</var>/sepolicy</code> 目录中）。在 Android 8.0 及更高版本中，您对这些文件所做的更改只会影响供应商目录中的政策。要详细了解 Android 8.0 及更高版本中的公共 sepolicy 分离，请参阅<a href="/security/selinux/customize#android-o">在 Android 8.0 及更高版本中自定义 SEPolicy</a>。无论是哪个 Android 版本，您都仍需要修改以下文件：</p>

<h3 id="policy-files">政策文件</h3>

<p>以 <code>*.te</code> 结尾的文件是 SELinux 政策源代码文件，用于定义域及其标签。您可能需要在 <code>/device/<var>manufacturer</var>/<var>device-name</var>/sepolicy</code> 中创建新的政策文件，但您应尽可能尝试更新现有文件。</p>

<h3 id="context-files">上下文的描述文件</h3>
<p>您可以在上下文的描述文件中为您的对象指定标签。</p>
  <ul>
  <li><code>file_contexts</code> 用于为文件分配标签，并且可供多种用户空间组件使用。在创建新政策时，请创建或更新该文件，以便为文件分配新标签。要应用新的 <code>file_contexts</code>，请重新构建文件系统映像，或对要重新添加标签的文件运行 <code>restorecon</code>。在升级时，对 <code>file_contexts</code> 所做的更改会在升级过程中自动应用于系统和用户数据分区。此外，您还可以通过以下方式使这些更改在升级过程中自动应用于其他分区：在以允许读写的方式装载相应分区后，将 <code>restorecon_recursive</code> 调用添加到 init.board<var></var>.rc 文件中。</li>
  <li><code>genfs_contexts</code> 用于为不支持扩展属性的文件系统（例如，<code>proc</code> 或 <code>vfat</code>）分配标签。此配置会作为内核政策的一部分进行加载，但更改可能对内核 inode 无效。要全面应用更改，您需要重新启动设备，或卸载并重新装载文件系统。此外，通过使用 <code>context=mount</code> 选项，您还可以为装载的特定系统文件（例如 <code>vfat</code>）分配特定标签。</li>
  <li><code>property_contexts</code> 用于为 Android 系统属性分配标签，以便控制哪些进程可以设置这些属性。在启动期间，<code>init</code> 进程会读取此配置。</li>
  <li><code>service_contexts</code> 用于为 Android Binder 服务分配标签，以便控制哪些进程可以为相应服务添加（注册）和查找（查询）Binder 引用。在启动期间，<code>servicemanager</code> 进程会读取此配置。</li>
  <li><code>seapp_contexts</code> 用于为应用进程和 <code>/data/data</code> 目录分配标签。在每次应用启动时，<code>zygote</code> 进程都会读取此配置；在启动期间，<code>installd</code> 会读取此配置。</li>
  <li><code>mac_permissions.xml</code> 用于根据应用签名和应用软件包名称（后者可选）为应用分配 <code>seinfo</code> 标记。随后，分配的 <code>seinfo</code> 标记可在 <code>seapp_contexts</code> 文件中用作密钥，以便为带有该 <code>seinfo</code> 标记的所有应用分配特定标签。在启动期间，<code>system_server</code> 会读取此配置。</li>
</ul>

<h3 id="boardconfig">BoardConfig.mk makefile</h3>

<p>修改或添加政策文件和上下文的描述文件后，请更新您的 <code>/device/<var>manufacturer</var>/<var>device-name</var>/BoardConfig.mk</code> makefile 以引用 <code>sepolicy</code> 子目录和每个新的政策文件。
要详细了解 <code>BOARD_SEPOLICY</code> 变量，请参阅 <a href="https://android.googlesource.com/platform/system/sepolicy/+/master/README" class="external"><code>system/sepolicy/README</code> 文件</a>。</p>

<pre class="devsite-click-to-copy">
BOARD_SEPOLICY_DIRS += \
        &lt;root&gt;/device/<var>manufacturer</var>/<var>device-name</var>/sepolicy

BOARD_SEPOLICY_UNION += \
        genfs_contexts \
        file_contexts \
        sepolicy.te
</pre>

<p>重新进行编译后，您的设备会启用 SELinux。现在，您可以根据您向 Android 操作系统添加的内容自定义 SELinux 政策（如<a href="/security/selinux/customize.html">自定义</a>中所述），也可以验证现有设置（如<a href="/security/selinux/validate.html">验证</a>中所述）。</p>

<p>在新政策文件和 BoardConfig.mk 更新部署到位后，新政策设置会自动内置到最终的内核政策文件中。
要详细了解如何在设备上编译 sepolicy，请参阅<a href="security/selinux/building">编译 sepolicy</a>。</p>

<h2 id="steps">实现</h2>

<p>要开始使用 SELinux，请执行以下操作：</p>

<ol>
  <li>在内核中启用 SELinux：
    <code>CONFIG_SECURITY_SELINUX=y</code></li>
  <li>更改 kernel_cmdline 参数，以便：
      <pre class="devsite-click-to-copy">
BOARD_KERNEL_CMDLINE := androidboot.selinux=permissive</pre>
      这仅适用于初始制定设备政策的情况。在拥有初始引导程序政策后，请移除此参数，以便将设备恢复强制模式，否则设备将无法通过 CTS 验证。</li>
  <li>以宽容模式启动系统，看看在启动时会遇到哪些拒绝事件：<br />
      在 Ubuntu 14.04 或更高版本中，请运行以下命令：
<pre class="devsite-terminal devsite-click-to-copy">
adb shell su -c dmesg | grep denied | audit2allow -p out/target/product/<var>BOARD</var>/root/sepolicy
</pre>
      在 Ubuntu 12.04 中，请运行以下命令：
<pre class="devsite-terminal devsite-click-to-copy">
adb pull /sys/fs/selinux/policy
adb logcat -b all | audit2allow -p policy
</pre></li>
  <li>评估与以下内容类似的警告的输出：<code>init: Warning!
      Service name needs a SELinux domain defined; please fix!</code> 如需查看相关说明和工具，请参阅<a href="/security/selinux/validate">验证</a>。</li>
  <li>标识设备以及需要添加标签的其他新文件。</li>
  <li>为您的对象使用现有标签或新标签。查看 <code>*_contexts</code> 文件，了解之前是如何为内容添加标签的，然后根据对标签含义的了解分配一个新标签。这个标签最好是能够融入到政策中的现有标签，但有时也需要使用新标签，而且还需要提供关于访问该标签的规则。将您的标签添加到相应的上下文的描述文件中。</li>
  <li>标识那些应拥有自己的安全域的域/进程。
      您可能需要为每一项分别编写一个全新的政策。例如，从 <code>init</code> 衍生的所有服务都应该有自己的安全域。以下命令有助于查看保持运行的服务（不过所有服务都需要如此处理）：<br />
<pre class="devsite-terminal devsite-click-to-copy">
adb shell su -c ps -Z | grep init
</pre>
<pre class="devsite-terminal devsite-click-to-copy">
adb shell su -c dmesg | grep 'avc: '
</pre></li>
  <li>查看 <code>init.<var>device</var>.rc</code> 以发现任何没有域类型的域。<em></em>请在开发过程早期为其提供相应的域，以避免向 <code>init</code> 添加规则或将 <code>init</code> 访问权限与其自身政策中的访问权限混淆。</li>
  <li>将 <code>BOARD_CONFIG.mk</code> 设为使用 <code>BOARD_SEPOLICY_*</code> 变量。如需关于如何进行这项设置的详细信息，请参阅 <code>system/sepolicy</code> 中的 <a href="https://android.googlesource.com/platform/system/sepolicy/+/master/README" class="external">README</a>。</li>
  <li>检查 init.device<var></var>.rc 和 fstab.device<var></var> 文件，确保每一次使用“<code>mount</code>”都对应一个添加了适当标签的文件系统，或者指定了 <code>context= mount</code> 选项。</li>
  <li>查看每个拒绝事件，并创建 SELinux 政策来妥善处理每个拒绝事件。请参阅<a href="/security/selinux/customize">自定义</a>中的示例。
</li></ol>

<p>您最好从 AOSP 中的政策入手，然后在这些政策的基础上创建自己的自定义政策。要详细了解政策策略以及其中一些步骤，请参阅<a href="/security/selinux/device-policy">编写 SELinux 政策</a>。</p>

<h2 id="use_cases">用例</h2>

<p>下面列举了一些在开发软件以及制定关联的 SELinux 政策时需要注意的具体漏洞：</p>

<p><strong>符号链接</strong> - 由于符号链接以文件形式显示，因此系统通常将其作为文件进行读取，而这可能会导致漏洞。例如，某些特权组件（例如 <code>init</code>）会更改某些文件的权限，有时会使之极度开放。</p>

<p>这样一来，攻击者便可以将这些文件替换成指向其控制的代码的符号链接，从而重写任意文件。但如果您知道自己的应用绝不会遍历符号链接，则可以通过 SELinux 来禁止您的应用遍历符号链接。</p>

<p><strong>系统文件</strong> - 以应该只有系统服务器可以修改的一系列系统文件为例。由于 <code>netd</code>、<code>init</code> 和 <code>vold</code> 是以 Root 身份运行的，因此它们也可以访问这些系统文件。这样一来，如果 <code>netd</code> 遭到入侵，它将可以入侵这些文件，并可能会入侵系统服务器本身。</p>

<p>借助 SELinux，您可以将这些文件标识为系统服务器数据文件。这样一来，系统服务器就是唯一对这些文件具有读写权限的域。即使 <code>netd</code> 遭到入侵，它也无法将域切换到系统服务器域并访问这些系统文件，就算它是以 Root 身份运行的也是如此。</p>

<p><strong>应用数据</strong> - 另一个示例是必须以 Root 身份运行但不应获得应用数据访问权限的一系列函数。这一项非常有用，因为它可以做出广泛的声明，例如禁止与应用数据无关的特定域访问互联网。</p>

<p><strong>setattr</strong> - 对于 <code>chmod</code>、<code>chown</code> 等命令，您可以标识关联域可以在哪些文件中进行 <code>setattr</code> 操作。这样一来，便可以禁止对这些文件之外的任何文件进行这类更改，即使以 Root 身份进行也不例外。因此，应用可以对带 <code>app_data_files</code> 标签的文件运行 <code>chmod</code> 和 <code>chown</code> 命令，但不能对带 <code>shell_data_files</code> 或 <code>system_data_files</code> 标签的文件运行这些命令。</p>

</body></html>