<html devsite><head>
    <title>Fingerprint HIDL</title>
    <meta name="project_path" value="/_project.yaml"/>
    <meta name="book_path" value="/_book.yaml"/>
  </head>
  <body>

  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<p>在配有指纹传感器的设备上，用户可以注册一个或多个指纹，并使用这些指纹来解锁设备以及执行其他任务。Android 会利用 Fingerprint HIDL（硬件接口定义语言）连接到供应商专用库和指纹硬件（例如指纹传感器）。</p>

<p>要实现 Fingerprint HIDL，您必须在某个供应商专用库中实现 <a href="https://android.googlesource.com/platform/hardware/interfaces/+/refs/heads/master/biometrics/fingerprint/2.1/IBiometricsFingerprint.hal" class="external"><code>IBiometricsFingerprint.hal</code></a>。</p>

<h2 id="fingerprint_matching">指纹匹配</h2>

<p>设备的指纹传感器通常处于闲置状态。不过，为了响应对 <code>authenticate</code> 或 <code>enroll</code> 的调用，指纹传感器会监听触摸操作（并且屏幕可能会在用户触摸指纹传感器时被唤醒）。指纹匹配的概要流程包括以下步骤：</p>

<ol>
  <li>用户将手指放在指纹传感器上。</li>
  <li>供应商专用库会根据当前的已注册指纹模板集判断是否匹配。</li>
  <li>匹配结果会传递到 <code>FingerprintService</code>。</li>
</ol>

<p>该流程假设设备上已经注册了一个指纹，即供应商专用库已为该指纹注册了一个模板。如需了解详情，请参阅<a href="/security/authentication/index.html">身份验证</a>。</p>

<aside class="note"><strong>注意</strong>：设备上存储的指纹模板越多，进行指纹匹配所需的时间就越长。</aside>

<h2 id="architecture">架构</h2>

<p>Fingerprint HAL 会与以下组件交互。</p>

<ul>
  <li><code>BiometricManager</code> 会在应用进程中与应用直接交互。每个应用都有一个 <code>IBiometricsFingerprint.hal</code> 实例。</li>
  <li><code>FingerprintService</code> 在系统进程中运行，可处理与 Fingerprint HAL 之间的通信。</li>
  <li><strong>Fingerprint HAL</strong> 是 IBiometricsFingerprint HIDL 接口的 C/C++ 实现。它包含可与设备专有硬件进行通信的供应商专用库。</li>
  <li><strong>Keystore API 和 Keymaster</strong> 组件提供由硬件支持的加密功能，以便在安全环境（例如可信执行环境 (TEE)）中安全地存储密钥。</li>
</ul>

<img src="../images/fingerprint-data-flow.png" alt="指纹身份验证的数据流程" id="figure1"/>
<figcaption><strong>图 1.</strong> 指纹身份验证的概要数据流程</figcaption>

<p>供应商专用 HAL 实现必须使用 TEE 所要求的通信协议。不得将原始图像和处理后的指纹特征传递到不可信内存中。所有此类生物识别数据都需要存储在安全硬件（例如 TEE）中。请确保即使具备 Root 权限，也<strong>不能</strong>取得生物识别数据。</p>

<p><code>FingerprintService</code> 和 <code>fingerprintd</code> 会通过 Fingerprint HAL 调用供应商专用库，以便注册指纹以及执行其他操作：</p>

<img src="../images/fingerprint-daemon.png" alt="与 fingerprintd 交互" id="figure2"/>
<figcaption><strong>图 2.</strong> Fingerprint 守护进程与 Fingerprint 供应商专用库之间的交互</figcaption>

<h2 id="implementation">实现准则</h2>

<p>以下 Fingerprint HAL 准则旨在确保指纹数据<strong>不会被泄露</strong>，并在从设备中移除用户时，一并<strong>移除</strong>指纹数据：</p>

<ul>
  <li>必须要确保在任何情况下都无法从传感器驱动程序或 TEE 以外访问原始指纹数据或衍生内容（例如模板）。如果硬件支持 TEE，则只能将硬件访问权限授予 TEE，并且必须通过 SELinux 政策对硬件访问权限加以保护。串行外设接口 (SPI) 通道必须只能供 TEE 访问，并且必须有针对所有设备文件的明确 SELinux 政策。</li>
  <li>指纹采集、注册和识别必须在 TEE 内部进行。</li>
  <li>只有加密形式的指纹数据可以存储在文件系统中（即使文件系统本身已加密）。
  </li>
  <li>指纹模板必须采用设备专用私钥进行签名。对于高级加密标准 (AES)，模板必须至少通过绝对文件系统路径、群组和指纹 ID 进行签名，这样一来，相应模板文件便无法在其他设备上使用，并且无法用于在同一设备上注册的任何其他用户。例如，您将无法复制同一设备上其他用户的指纹数据，也无法从其他设备复制指纹数据。
  </li>
  <li>实现必须使用 <code>setActiveGroup()</code> 函数提供的文件系统路径，或提供一种能够在移除用户时一并清空所有用户模板数据的方法。强烈建议将指纹模板文件以加密形式存储在提供的路径中。如果因 TEE 存储要求而导致这种做法不可行，实现人员必须添加一些钩子，以确保在移除用户时一并移除相关数据。
  </li>
</ul>

<h2 id="methods">Fingerprint 方法</h2>

<p>Fingerprint HIDL 接口在 <a href="https://android.googlesource.com/platform/hardware/interfaces/+/refs/heads/master/biometrics/fingerprint/2.1/IBiometricsFingerprint.hal" class="external"><code>IBiometricsFingerprint.hal</code></a> 中包含以下主要方法。</p>

<table>
  <thead>
  <tr>
    <th>方法</th>
    <th>说明</th>
  </tr>
  </thead>
<tbody>
  <tr>
    <td><code>enroll()</code></td>
    <td>将 HAL 状态机切换到开始收集和存储指纹模板的状态。注册完成后或超时后，HAL 状态机会返回到闲置状态。</td>
  </tr>
  <tr>
    <td><code>preEnroll()</code></td>
    <td>生成一个独一无二的令牌，以指明指纹注册已开始。为 <code>enroll</code> 函数提供令牌，以确保事先已经过身份验证（例如使用密码）。为了防止被篡改，确认设备凭据后，便会开始封装令牌。在注册期间必须检查令牌，以确认令牌仍然有效。</td>
  </tr>
  <tr>
    <td><code>getAuthenticatorId()</code></td>
    <td>返回与当前指纹集关联的令牌。</td>
  </tr>
  <tr>
    <td><code>cancel()</code></td>
    <td>取消待处理的注册或身份验证操作。HAL 状态机会返回到闲置状态。</td>
  </tr>
  <tr>
    <td><code>enumerate()</code></td>
    <td>同步调用，用于枚举所有已知指纹模板。</td>
  </tr>
  <tr>
    <td><code>remove()</code></td>
    <td>删除指纹模板。</td>
  </tr>
  <tr>
    <td><code>enumerate()</code></td>
    <td>枚举与活跃用户关联的所有指纹模板。</td>
  </tr>
  <tr>
    <td><code>remove()</code></td>
    <td>移除与活跃用户关联的某个或所有指纹模板。</td>
  </tr>
  <tr>
    <td><code>setActiveGroup()</code></td>
    <td>限定只能对属于指定群组（通过群组标识符 (GID) 来标识）的指纹集执行某项 HAL 操作。</td>
  </tr>
  <tr>
    <td><code>authenticate()</code></td>
    <td>验证与指纹相关的操作（通过操作 ID 来标识）。</td>
  </tr>
  <tr>
    <td><code>setNotify()</code></td>
    <td>注册一个从 HAL 接收通知的用户函数。如果 HAL 状态机处于繁忙状态，该函数会阻塞，直到 HAL 不再处于繁忙状态为止。</td>
  </tr>
  <tr>
    <td><code>postEnroll()</code></td>
    <td>结束注册操作并使 <code>preEnroll()</code> 生成的质询代码无效。必须在多手指注册会话结束时调用该函数，以表明不会再添加手指。</td>
  </tr>
</tbody>
</table>

<p>如需详细了解这些函数，请参阅 <a href="https://android.googlesource.com/platform/hardware/interfaces/+/refs/heads/master/biometrics/fingerprint/2.1/IBiometricsFingerprint.hal" class="external"><code>IBiometricsFingerprint.hal</code></a> 中的备注。</p>

</body></html>