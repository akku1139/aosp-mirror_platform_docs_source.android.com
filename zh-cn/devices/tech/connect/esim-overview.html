<html devsite><head>

  <meta name="book_path" value="/_book.yaml"/>

  <meta name="project_path" value="/_project.yaml"/>
</head>
<body>
<!--
  Copyright 2018 The Android Open Source Project

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<h1 id="implementing_esim" class="page-title">实现 eSIM</h1>

<p>嵌入式 SIM（又称 eSIM 或 eUICC）是一种最新技术，可让移动用户在没有实体 SIM 卡的情况下，下载运营商配置文件并激活运营商服务。该技术是由 GSMA 推动的全球规范，支持在任何移动设备上进行远程 SIM 配置。从 Android 9 开始，Android 框架提供了用于访问 eSIM 和管理 eSIM 上的订阅配置文件的标准 API。借助这些 eUICC API，第三方可以在支持 eSIM 的 Android 设备上开发自己的运营商应用和 Local Profile Assistant (LPA)。<em></em></p>

<p>LPA 是一款独立的系统应用，应包含在 Android 编译映像中。对 eSIM 上配置文件的管理通常由 LPA 完成，因为它充当着 SM-DP+（用来准备、存储配置文件包并将其交付给设备的远程服务）和 eUICC 芯片之间的桥梁。LPA APK 可以选择性地包含一个界面组件（又称 LPA 界面或 LUI），以便为最终用户提供一个中心位置来管理所有嵌入式订阅配置文件。Android 框架可自动发现可用性最高的 LPA 并与之连接，然后通过 LPA 实例路由所有 eUICC 操作。</p>

<p><img src="/devices/tech/connect/images/rsp-architecture.png" alt="简化的远程 SIM 配置 (RSP) 架构"/></p>

<p><strong>图 1.</strong> 简化的远程 SIM 配置 (RSP) 架构</p>

<p><em></em>有兴趣开发运营商应用的移动网络运营商可以参阅 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/telephony/java/android/telephony/euicc/EuiccManager.java" class="external">EuiccManager</a> 中的 API，其中介绍了高级配置文件管理操作（例如 <code>downloadSubscription()</code>、<code>switchToSubscription()</code> 和 <code>deleteSubscription()</code>）。</p>

<p>如果您是有兴趣自行开发 LPA 系统应用的原始设备制造商 (OEM)，那么您必须为 Android 框架扩展 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/service/euicc/EuiccService.java" class="external">EuiccService</a> 以连接到您的 LPA 服务。此外，您还应使用 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/telephony/java/android/telephony/euicc/EuiccCardManager.java" class="external">EuiccCardManager</a> 中的 API，这些 API 提供了基于 GSMA 远程 SIM 配置 (RSP) v2.0 的 ES10x 函数。此类函数用于向 eUICC 芯片发出命令（例如 <code>prepareDownload()</code>、<code>loadBoundProfilePackage()</code>、<code>retrieveNotificationList()</code> 和 <code>resetMemory()</code>）。</p>

<p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/telephony/java/android/telephony/euicc/EuiccManager.java" class="external">EuiccManager</a> 中的 API 需要一个正确实现的 LPA 应用才能正常运行，且 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/telephony/java/android/telephony/euicc/EuiccCardManager.java" class="external">EuiccCardManager</a> API 的调用程序必须是 LPA。这是 Android 框架的强制要求。</p>

<h2 id="making_a_carrier_app">开发运营商应用</h2>

<p>借助 Android 9 中的 eUICC API，移动网络运营商可以开发运营商品牌的应用，以便直接管理其配置文件。这包括下载和删除运营商所拥有的订阅配置文件，以及切换到运营商所拥有的配置文件。</p>

<h3 id="euiccmanager">EuiccManager</h3>

<p><code>EuiccManager</code> 是应用与 LPA 交互的主入口点。这包括可下载、删除及切换到运营商所拥有的订阅的运营商应用。此外，这还包括 LUI 系统应用，该应用可提供用于管理所有嵌入式订阅的中心位置/界面，而且可以不同于提供 <code>EuiccService</code> 的应用。<em></em></p>

<p>要使用公共 API，运营商应用必须先通过 <code>Context#getSystemService</code> 获取 <code>EuiccManager</code> 的实例：</p>
<pre class="prettyprint"><code>EuiccManager mgr = (EuiccManager) context.getSystemService(Context.EUICC_SERVICE);
</code></pre>
<p>在执行任何 eSIM 操作之前，您应检查设备是否支持 eSIM。如果系统已指定 android.hardware.telephony.euicc 功能且存在 LPA 软件包，<code>EuiccManager#isEnabled()</code> 通常会返回 true。</p>
<pre class="prettyprint"><code>boolean isEnabled = mgr.isEnabled();
if (!isEnabled) {
    return;
}
</code></pre>
<p>要获取有关 eUICC 硬件和 eSIM 操作系统版本的信息，请执行以下命令：</p>
<pre class="prettyprint"><code>EuiccInfo info = mgr.getEuiccInfo();
String osVer = info.getOsVersion();
</code></pre>
<p>很多 API（例如 <code>downloadSubscription()</code> 和 <code>switchToSubscription()</code>）都会使用 <code>PendingIntent</code> 回调，因为回调操作可能需要数秒甚至几分钟的时间才能完成。系统会使用 <code>EuiccManager#EMBEDDED_SUBSCRIPTION_RESULT_</code> 空间中的结果代码发送 <code>PendingIntent</code>，该代码提供了由框架指定的错误代码，以及传播自 LPA 的任意详细结果代码 <code>EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE</code>，这使得运营商应用可以通过跟踪来完成日志记录/调试操作。<code>PendingIntent</code> 必须是 <code>BroadcastReceiver</code>。</p>

<p>要下载指定的 <code>DownloadableSubscription</code>（通过激活码或二维码创建），请执行以下命令：<em></em></p>
<pre class="prettyprint"><code>// Register receiver.
static final String ACTION_DOWNLOAD_SUBSCRIPTION = "download_subscription";
static final String LPA_DECLARED_PERMISSION
    = "com.your.company.lpa.permission.BROADCAST";
BroadcastReceiver receiver =
        new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (!action.equals(intent.getAction())) {
                    return;
                }
                resultCode = getResultCode();
                detailedCode = intent.getIntExtra(
                    EuiccManager.EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE,
                    0 /* defaultValue*/);
                resultIntent = intent;
            }
        };
context.registerReceiver(receiver,
        new IntentFilter(ACTION_DOWNLOAD_SUBSCRIPTION),
        LPA_DECLARED_PERMISSION /* broadcastPermission*/,
        null /* handler */);

// Download subscription asynchronously.
DownloadableSubscription sub = DownloadableSubscription
        .forActivationCode(code /* encodedActivationCode*/);
Intent intent = new Intent(action);
PendingIntent callbackIntent = PendingIntent.getBroadcast(
        getContext(), 0 /* requestCode */, intent,
        PendingIntent.FLAG_UPDATE_CURRENT);
mgr.downloadSubscription(sub, true /* switchAfterDownload */,
        callbackIntent);
</code></pre>
<p>要切换到某条订阅内容（已指定订阅 ID），请执行以下命令：</p>
<pre class="prettyprint"><code>// Register receiver.
static final String ACTION_SWITCH_TO_SUBSCRIPTION = "switch_to_subscription";
static final String LPA_DECLARED_PERMISSION
    = "com.your.company.lpa.permission.BROADCAST";
BroadcastReceiver receiver =
        new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (!action.equals(intent.getAction())) {
                    return;
                }
                resultCode = getResultCode();
                detailedCode = intent.getIntExtra(
                    EuiccManager.EXTRA_EMBEDDED_SUBSCRIPTION_DETAILED_CODE,
                    0 /* defaultValue*/);
                resultIntent = intent;
            }
        };
context.registerReceiver(receiver,
        new IntentFilter(ACTION_SWITCH_TO_SUBSCRIPTION),
        LPA_DECLARED_PERMISSION /* broadcastPermission*/,
        null /* handler */);

// Switch to a subscription asynchronously.
Intent intent = new Intent(action);
PendingIntent callbackIntent = PendingIntent.getBroadcast(
        getContext(), 0 /* requestCode */, intent,
        PendingIntent.FLAG_UPDATE_CURRENT);
mgr.switchToSubscription(1 /* subscriptionId */, callbackIntent);
</code></pre>
<p>有关 <code>EuiccManager</code> API 和代码示例的完整列表，请参阅 <a href="/devices/tech/connect/esim-euicc-api">eUICC API</a>。</p>

<h3 id="resolvable_errors">可解决的错误</h3>

<p>有时，系统无法完成 eSIM 操作，但用户可以直接解决由此导致的错误。例如，如果配置文件元数据提示需要运营商确认码，则 <code>downloadSubscription</code> 可能会失败。<em></em>或者，如果运营商应用具备目标配置文件的运营商权限（即运营商拥有该配置文件），但它不具备当前所启用配置文件的运营商权限（因此需要征得用户的同意），<code>switchToSubscription</code> 可能也会失败。</p>

<p>在这些情况下，调用程序使用 <code>EuiccManager#EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR</code> 进行回调。回调 <code>Intent</code> 将包含内部 extra，以便在调用程序将其传递给 <a href="https://developer.android.com/reference/android/telephony/euicc/EuiccManager.html#startResolutionActivity(android.app.Activity,%20int,%20android.content.Intent,%20android.app.PendingIntent)" class="external"><code>EuiccManager#startResolutionActivity</code></a> 时，可以通过 LUI 请求解决问题。再次以确认码为例，<a href="https://developer.android.com/reference/android/telephony/euicc/EuiccManager.html#startResolutionActivity(android.app.Activity,%20int,%20android.content.Intent,%20android.app.PendingIntent)" class="external"><code>EuiccManager#startResolutionActivity</code></a> 会触发 LUI 屏幕来让用户输入确认码，输入完成后，下载操作即会恢复。这种方法使得运营商应用能够完全控制在何时显示该界面，同时也为 LPA/LUI 提供了一种扩展方法，用于在将来添加处理“用户可恢复问题”的新方法（无需客户端应用做出更改）。</p>

<p>Android 9 在 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/service/euicc/EuiccService.java" class="external"><code>EuiccService</code></a> 中定义了 LUI 应处理的上述可修正的错误：</p>
<pre class="prettyprint"><code>/**
 * Alert the user that this action will result in an active SIM being
 * deactivated. To implement the LUI triggered by the system, you need to define
 * this in AndroidManifest.xml.
 */
public static final String ACTION_RESOLVE_DEACTIVATE_SIM =
        "android.service.euicc.action.RESOLVE_DEACTIVATE_SIM";
/**
 * Alert the user about a download/switch being done for an app that doesn't
 * currently have carrier privileges.
 */
public static final String ACTION_RESOLVE_NO_PRIVILEGES =
        "android.service.euicc.action.RESOLVE_NO_PRIVILEGES";

/** Ask the user to input carrier confirmation code. */
public static final String ACTION_RESOLVE_CONFIRMATION_CODE =
        "android.service.euicc.action.RESOLVE_CONFIRMATION_CODE";
</code></pre>
<h3 id="carrier_privileges">运营商权限</h3>

<p>如果您是打算自行开发运营商应用（调用 <code>EuiccManager</code> 以将配置文件下载到设备上）的运营商，那么您的配置文件应在元数据中包含与您的运营商应用相对应的运营商权限规则。这是因为属于不同供应商的订阅配置文件可在同一设备的 eUICC 中共存，但每个运营商应用只能访问相应运营商拥有的配置文件。例如，运营商 A 应该无法下载、启用或停用运营商 B 拥有的配置文件。</p>

<p>为确保某个配置文件仅供其所有者访问，Android 采用了一种机制向配置文件所有者的应用（即运营商应用）授予特殊权限。Android 平台会加载存储在配置文件的访问规则文件 (ARF) 中的证书，并向由这些证书签名的应用授予权限，以允许其调用 <code>EuiccManager</code> API。详细流程如下所述：</p>

<ol>
<li>运营商签署运营商应用 APK；<a href="https://developer.android.com/studio/command-line/apksigner" class="external">apksigner</a> 工具将公钥证书附加到 APK。</li>
<li><p>运营商/SM-DP+ 准备配置文件及其元数据，其中的 ARF 包含以下内容：</p>

<ol>
<li>运营商应用的公钥证书的签名（SHA-1 或 SHA-256）（必需）</li>
<li>运营商应用的软件包名称（可选）</li>
</ol></li>
<li><p>运营商应用尝试通过 <code>EuiccManager</code> API 执行 eUICC 操作。</p></li>
<li><p>Android 平台会验证调用程序应用证书的 SHA-1 或 SHA-256 哈希是否与从目标配置文件的 ARF 中获取的证书签名相匹配。如果运营商应用的软件包名称包含在该 ARF 中，那么它也必须与调用程序应用的软件包名称相匹配。</p></li>
<li><p>对签名和软件包名称（如果包含）进行验证后，系统便会通过目标配置文件向调用程序应用授予运营商权限。</p></li>
</ol>

<p>由于配置文件元数据可在配置文件之外使用（以便 LPA 在下载配置文件之前通过 SM-DP+ 检索配置文件元数据，或在配置文件停用后通过 ISD-R 进行检索），因此，它应当包含与该配置文件相同的运营商权限规则。</p>

<p>eUICC 操作系统和 SM-DP+ 必须支持配置文件元数据中的专有标记 <strong>BF76</strong>。标记内容应与 <a href="/devices/tech/config/uicc">UICC 运营商权限</a>中指定的 ARA（访问规则小程序）所返回的运营商权限规则相同：</p>
<pre class="prettyprint"><code>RefArDo ::= [PRIVATE 2] SEQUENCE {  -- Tag E2
    refDo [PRIVATE 1] SEQUENCE {  -- Tag E1
        deviceAppIdRefDo [PRIVATE 1] OCTET STRING (SIZE(20|32)),  -- Tag C1
        pkgRefDo [PRIVATE 10] OCTET STRING (SIZE(0..127)) OPTIONAL  -- Tag CA
    },
    arDo [PRIVATE 3] SEQUENCE {  -- Tag E3
        permArDo [PRIVATE 27] OCTET STRING (SIZE(8))  -- Tag DB
    }
}
</code></pre>
<p>要详细了解应用签名，请参阅<a href="https://developer.android.com/studio/publish/app-signing" class="external">为您的应用签名</a>。要详细了解运营商权限，请参阅 <a href="/devices/tech/config/uicc">UICC 运营商权限</a>。</p>

<h2 id="making_an_lpa_app">开发 LPA 应用</h2>

<p>您可以实现自己的 LPA，但必须将其与 Android Euicc API 连接起来。以下部分简要概述了如何开发 LPA 应用，以及如何将其与 Android 系统集成。</p>

<h3 id="hardwaremodem_requirements">硬件/调制解调器要求</h3>

<p>eUICC 芯片上的 LPA 和 eSIM 操作系统必须支持最低 2.0 或 2.2 版的 GSMA RSP（远程 SIM 配置）。您还应当安排使用具有与之匹配的 RSP 版本的 SM-DP+ 和 SM-DS 服务器。要详细了解 RSP 架构，请参阅 <a href="https://www.gsma.com/newsroom/all-documents/sgp-21-rsp-architecture-v2-2/" class="external">GSMA SGP.21 RSP 架构规范</a>。</p>

<p>此外，要与 Android 9 中的 eUICC API 集成，设备调制解调器应发送支持已编码的 eUICC 功能的终端功能（本地配置文件管理和配置文件下载）。它还需要实现以下 API：</p>

<ul>
<li>IRadio HAL v1.1：setSimPower</li>
<li>IRadio HAL v1.2：getIccCardStatus</li>
<li>IRadioConfig HAL v1.0：getSimSlotsStatus</li>
</ul>

<p>调制解调器应将已启用默认启动配置文件的 eSIM 卡识别为有效 SIM 卡，并使该 SIM 卡保持正常使用状态。</p>

<p>有关调制解调器要求的完整列表，请参阅 <a href="/devices/tech/connect/esim-modem-requirements">eSIM 支持的调制解调器要求</a>。</p>

<h3 id="euiccservice">EuiccService</h3>

<p>LPA 由两个独立的组件组成（可在同一 APK 中实现）：LPA 后端和 LPA 界面或 LUI。</p>

<p>要实现 LPA 后端，您必须扩展 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/service/euicc/EuiccService.java" class="external"><code>EuiccService</code></a> 并在清单文件中声明此服务。该服务必须请求获得 <code>android.permission.BIND_EUICC_SERVICE</code> 系统权限，以确保只有系统才能与之绑定。该服务还必须包含具有 <code>android.service.euicc.EuiccService</code> 操作的 intent 过滤器。如果设备上存在多个实现，则应将 intent 过滤器的优先级设置为非零值。例如：</p>
<pre class="prettyprint"><code>&lt;service
    android:name=".EuiccServiceImpl"
    android:permission="android.permission.BIND_EUICC_SERVICE"&gt;
    &lt;intent-filter android:priority="100"&gt;
        &lt;action android:name="android.service.euicc.EuiccService" /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
</code></pre>
<p>Android 框架从内部确定处于活跃状态的 LPA，并视需要与其交互以支持 Android eUICC API。系统会查询 <code>PackageManager</code>（针对具有 <code>android.permission.WRITE_EMBEDDED_SUBSCRIPTIONS</code> 权限的所有应用），而该权限为 <code>android.service.euicc.EuiccService</code> 操作指定了一项服务。系统将选择优先级最高的服务，如果未找到任何服务，则会停用 LPA 支持。</p>

<p>要实现 LUI，您必须为以下操作提供操作组件：</p>

<ul>
<li><code>android.service.euicc.action.MANAGE_EMBEDDED_SUBSCRIPTIONS</code></li>
<li><code>android.service.euicc.action.PROVISION_EMBEDDED_SUBSCRIPTION</code></li>
</ul>

<p>与服务一样，每个 Activity 都必须获得 <code>android.permission.BIND_EUICC_SERVICE</code> 系统权限，而且都应当包含具有适当操作的 intent 过滤器、<code>android.service.euicc.category.EUICC_UI</code> 类别以及非零优先级。选择这些 Activity 的实现与选择 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/service/euicc/EuiccService.java" class="external"><code>EuiccService</code></a> 实现所使用的逻辑是类似的。例如：</p>
<pre class="prettyprint"><code>&lt;activity android:name=".MyLuiActivity"
          android:exported="true"
          android:permission="android.permission.BIND_EUICC_SERVICE"&gt;
    &lt;intent-filter android:priority="100"&gt;
        &lt;action android:name="android.service.euicc.action.MANAGE_EMBEDDED_SUBSCRIPTIONS" /&gt;
        &lt;action android:name="android.service.euicc.action.PROVISION_EMBEDDED_SUBSCRIPTION" /&gt;
        &lt;category android:name="android.intent.category.DEFAULT" /&gt;
        &lt;category android:name="android.service.euicc.category.EUICC_UI" /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<p>这意味着，实现这些屏幕的界面的 APK 可以与实现 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/service/euicc/EuiccService.java" class="external"><code>EuiccService</code></a> 的 APK 不同。使用单个 APK 还是多个 APK（例如一个用于实现 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/service/euicc/EuiccService.java" class="external"><code>EuiccService</code></a>，另一个用于提供 LUI Activity）取决于设计时的选择。</p>

<h3 id="euicccardmanager">EuiccCardManager</h3>

<p><code>EuiccCardManager</code> 是用于与 eSIM 芯片进行通信的接口。它可提供 ES10 函数（如 GSMA RSP 规范中所述）并处理低级 APDU 请求/响应命令以及 ASN.1 解析。
<code>EuiccCardManager</code> 是一种系统 API，只能由具有系统权限的应用进行调用。</p>

<p><img src="/devices/tech/connect/images/carrier-app-euicc-apis.png" alt="运营商应用、LPA 和 Euicc API"/></p>

<p><strong>图 2.</strong> 运营商应用和 LPA 同时使用 Euicc API</p>

<p>通过 <code>EuiccCardManager</code> 实现的配置文件操作 API 要求调用程序是 LPA。这是 Android 框架的强制要求。这意味着调用程序必须扩展 <code>EuiccService</code> 并在清单文件中得以声明（如前几部分所述）。</p>

<p>与 <code>EuiccManager</code> 类似，要使用 <code>EuiccCardManager</code> API，您的 LPA 必须先通过 <code>Context#getSystemService</code> 获取 <code>EuiccCardManager</code> 的实例：</p>
<pre class="prettyprint"><code>EuiccCardManager cardMgr = (EuiccCardManager) context.getSystemService(Context.EUICC_CARD_SERVICE);
</code></pre>
<p>接下来，要获取 eUICC 上的所有配置文件，请执行以下命令：</p>
<pre class="prettyprint"><code>ResultCallback&lt;EuiccProfileInfo[]&gt; callback =
       new ResultCallback&lt;EuiccProfileInfo[]&gt;() {
           @Override
           public void onComplete(int resultCode,
                   EuiccProfileInfo[] result) {
               if (resultCode == EuiccCardManagerReflector.RESULT_OK) {
                   // handle result
               } else {
                   // handle error
               }
           }
       };

cardMgr.requestAllProfiles(eid, AsyncTask.THREAD_POOL_EXECUTOR, callback);
</code></pre>
<p>在内部，<code>EuiccCardManager</code> 会通过 AIDL 接口绑定到 <code>EuiccCardController</code>（在电话进程中运行），而且每个 <code>EuiccCardManager</code> 方法均可以通过不同的专用 AIDL 接口从电话进程接收回调。使用 <code>EuiccCardManager</code> API 时，调用程序 (LPA) 必须提供 <a href="https://developer.android.com/reference/java/util/concurrent/Executor" class="external"><code>Executor</code></a>（通过它可以调用回调）。该 <code>Executor</code> 可以在单个线程上运行，也可以在线程池上运行，具体取决于您的选择。</p>

<p>大多数 <code>EuiccCardManager</code> API 都具有相同的使用模式。例如，要将绑定的配置文件包加载到 eUICC，请执行以下命令：</p>
<pre class="prettyprint"><code>...
cardMgr.loadBoundProfilePackage(eid, boundProfilePackage,
        AsyncTask.THREAD_POOL_EXECUTOR, callback);
</code></pre>
<p>要切换为具有指定 ICCID 的其他配置文件，请执行以下命令：</p>
<pre class="prettyprint"><code>...
cardMgr.switchToProfile(eid, iccid, true /* refresh */,
        AsyncTask.THREAD_POOL_EXECUTOR, callback);
</code></pre>
<p>要通过 eUICC 芯片获取默认的 SM-DP+ 地址，请执行以下命令：</p>
<pre class="prettyprint"><code>...
cardMgr.requestDefaultSmdpAddress(eid, AsyncTask.THREAD_POOL_EXECUTOR,
        callback);
</code></pre>
<p>要检索指定通知事件的通知列表，请执行以下命令：</p>
<pre class="prettyprint"><code>...
cardMgr.listNotifications(eid,
        EuiccNotification.Event.INSTALL
              | EuiccNotification.Event.DELETE /* events */,
        AsyncTask.THREAD_POOL_EXECUTOR, callback);
</code></pre>
<h2 id="validation">验证</h2>

<p>AOSP 未附带 LPA 实现，因此，您不应在所有 Android 版本中都提供 LPA 支持（并非每款手机都支持 eSIM）。因此，我们没有提供端到端的 CTS 测试用例。不过，AOSP 中提供了基本的测试用例，以确保公开的 eUICC API 在 Android 版本中有效。</p>

<p>您应该确保版本通过以下 CTS 测试用例（针对公共 API）：</p>

<p><a href="https://android.googlesource.com/platform/cts/+/master/tests/tests/telephony/src/android/telephony/euicc/cts" class="external">https://android.googlesource.com/platform/cts/+/master/tests/tests/telephony/src/android/telephony/</a> </p>

<p>实现运营商应用的运营商应该执行其常规的内部质量保证周期测试，以确保所有实现的功能都能正常运行。运营商应用至少应能够列出同一运营商拥有的所有订阅配置文件，下载并安装配置文件，激活配置文件上的服务，在配置文件之间切换以及删除配置文件。</p>

<p>如果您目前正在开发自己的 LPA，则应进行更严格的测试。您应与调制解调器供应商、eUICC 芯片或 eSIM 操作系统供应商、SM-DP+ 供应商以及运营商进行合作，以解决相关问题并确保 LPA 在 RSP 架构中的互操作性。进行大量的手动测试是必不可少的。为获得最佳测试覆盖率，您应遵循 <a href="https://www.gsma.com/newsroom/all-documents/sgp-23-v1-2-rsp-test-specification/" class="external">GSMA SGP.23 RSP 测试计划</a>。</p>

</body></html>