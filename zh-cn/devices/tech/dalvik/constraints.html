<html devsite><head>
    <title>约束</title>
    <meta name="project_path" value="/_project.yaml"/>
    <meta name="book_path" value="/_book.yaml"/>
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<p><code>.dex</code> 文件是 Dalvik 字节码的传输格式。要成为有效的 <code>.dex</code> 文件，文件必须在语法和语义上受到一定的约束；此外，要仅支持有效的 .dex 文件，还需要运行时。</p>

    <h2 id="gen-constraints">.dex 的一般完整性约束</h2>

    <p>一般完整性约束涉及较大结构的 <code>.dex</code> 文件，详见 <a href="dex-format.html"><code>.dex</code> 格式</a>。</p>

    <table>
      <tbody><tr>
        <th>标识符</th>

        <th>说明</th>
      </tr>

      <tr>
        <td>G1</td>

        <td><code>.dex</code> 文件的 <code>magic</code> 数值必须是 <code>dex\n035\0</code> 或 <code>dex\n037\0</code>。
        </td>
      </tr>

      <tr>
        <td>G2</td>

        <td>校验和必须是除了 <code>magic</code> 和 <code>checksum</code> 字段之外的整个文件内容的 Adler-32 校验和。
        </td>
      </tr>

      <tr>
        <td>G3</td>

        <td>签名必须是除了 <code>magic</code>、<code>checksum</code> 和 <code>signature</code> 之外的整个文件内容的 SHA-1 哈希值。
        </td>
      </tr>

      <tr>
        <td>G4</td>

        <td><code>file_size</code> 必须与实际文件大小（以字节为单位）相匹配。
        </td>
      </tr>

      <tr>
        <td>G5</td>

        <td><code>header_size</code> 的值必须为 <code>0x70</code>
        </td>
      </tr>

      <tr>
        <td>G6</td>

        <td><code>endian_tag</code> 的值必须为 <code>ENDIAN_CONSTANT</code> 或 <code>REVERSE_ENDIAN_CONSTANT</code>
        </td>
      </tr>

      <tr>
        <td>G7</td>

        <td>对于 <code>link</code>、<code>string_ids</code>、<code>type_ids</code>、<code>proto_ids</code>、<code>field_ids</code>、<code>method_ids</code>、<code>class_defs</code> 和 <code>data</code> 各区段，<code>offset</code> 和 <code>size</code> 字段必须都为零或都为非零。在后一种情况下，偏移必须四字节对齐。
        </td>
      </tr>

      <tr>
        <td>G8</td>

        <td>标头中除 <code>map_off</code> 之外的所有偏移字段都必须四字节对齐。
        </td>
      </tr>

      <tr>
        <td>G9</td>

        <td><code>map_off</code> 字段必须为零或指向数据区段。在后一种情况下，<code>data</code> 区段必须存在。
        </td>
      </tr>

      <tr>
        <td>G10</td>

        <td><code>link</code>、<code>string_ids</code>、<code>type_ids</code>、<code>proto_ids</code>、<code>field_ids</code>、<code>method_ids</code>、<code>class_defs</code> 和 <code>data</code> 区段都不得彼此重叠或者与标头重叠。
        </td>
      </tr>

      <tr>
        <td>G11</td>

        <td>如果存在映射，则每个映射条目都必须具有有效的类型。每种类型最多可以出现一次。
        </td>
      </tr>

      <tr>
        <td>G12</td>

        <td>如果存在映射，则每个映射条目必须具有非零偏移和大小。偏移必须指向文件的相应区段（即，<code>string_id_item</code> 必须指向 <code>string_ids</code> 区段），并且项的显式或隐式大小必须与该区段的实际内容和大小相匹配。
        </td>
      </tr>

      <tr>
        <td>G13</td>

        <td>如果存在映射，则映射条目 <code>n+1</code> 的偏移量必须大于或等于映射条目 <code>n plus than size of map entry n</code> 的偏移量。这意味着条目互不重叠且从低到高排序。
        </td>
      </tr>

      <tr>
        <td>G14</td>

        <td>以下类型的条目必须具有四字节对齐的偏移量：<code>string_id_item</code>、<code>type_id_item</code>、<code>proto_id_item</code>、<code>field_id_item</code>、<code>method_id_item</code>、<code>class_def_item</code>、<code>type_list</code>、<code>code_item</code>、<code>annotations_directory_item</code>。
        </td>
      </tr>

      <tr>
        <td>G15</td>

        <td>对于每个 <code>string_id_item</code>，<code>string_data_off</code> 字段必须包含对 <code>data</code> 区段的有效引用。对于引用的 <code>string_data_item</code>，<code>data</code> 字段必须包含有效的 MUTF-8 字符串，并且 <code>utf16_size</code> 必须与字符串的解码长度相匹配。
        </td>
      </tr>

      <tr>
        <td>G16</td>

        <td>对于每个 <code>type_id_item</code>，<code>descriptor_idx</code> 字段必须包含对 <code>string_ids</code> 列表的有效引用。引用的字符串必须是有效的类型描述符。
        </td>
      </tr>

      <tr>
        <td>G17</td>

        <td>对于每个 <code>proto_id_item</code>，<code>shorty_idx</code> 字段必须包含对 <code>string_ids</code> 列表的有效引用。引用的字符串必须是有效的短描述符。此外，<code>return_type_idx</code> 字段必须是 <code>type_ids</code> 区段的有效索引，并且 <code>parameters_off</code> 字段必须为零或指向 <code>data</code> 区段的有效偏移量。如果为非零，则参数列表不得包含任何空白条目。
        </td>
      </tr>

      <tr>
        <td>G18</td>

        <td>对于每个 <code>field_id_item</code>，<code>class_idx</code> 和 <code>type_idx</code> 字段都必须是 <code>type_ids</code> 列表的有效索引。<code>class_idx</code> 引用的条目必须是非数组引用类型。此外，<code>name_idx</code> 字段必须是对 <code>string_ids</code> 区段的有效引用，且引用条目的内容必须符合 <code>MemberName</code> 规范。
        </td>
      </tr>

      <tr>
        <td>G19</td>

        <td>对于每个 <code>method_id_item</code>，<code>class_idx</code> 字段必须是 <code>type_ids</code> 区段的有效索引，且引用的条目必须是非数组引用类型。<code>proto_id</code> 字段必须是对 <code>proto_ids</code> 列表的有效引用。<code>name_idx</code> 字段必须是对 <code>string_ids</code> 区段的有效引用，且引用条目的内容必须符合 <code>MemberName</code> 规范。
        </td>
      </tr>

      <tr>
        <td>G20</td>

        <td>对于每个 <code>field_id_item</code>，<code>class_idx</code> 字段必须是 <code>type_ids</code> 列表的有效索引。引用的条目必须是非数组引用类型。
        </td>
      </tr>

</tbody></table>

<h2 id="static-constraints">静态字节码约束</h2>

    <p>静态约束是对字节码的各个元素的约束。通常，可以在不使用控制或数据流分析技术的情况下检查这类约束。
    </p>

    <table>
      <tbody><tr>
        <th>标识符</th>

        <th>说明</th>
      </tr>

      <tr>
        <td>A1</td>

        <td><code>insns</code> 数组不能为空。
        </td>
      </tr>

      <tr>
        <td>A2</td>

        <td><code>insns</code> 数组中第一个运算码的索引必须为零。
        </td>
      </tr>

      <tr>
        <td>A3</td>

        <td><code>insns</code> 数组必须只包含有效的 Dalvik 运算码。
        </td>
      </tr>

      <tr>
        <td>A4</td>

        <td>指令 <code>n+1</code> 的索引必须等于指令 <code>n</code> 的索引加上指令 <code>n</code> 的长度，同时要考虑可能的运算数。
        </td>
      </tr>

      <tr>
        <td>A5</td>

        <td><code>insns</code> 数组中最后一条指令必须以索引 <code>insns_size-1</code> 结尾。
        </td>
      </tr>

      <tr>
        <td>A6</td>

        <td>所有 <code>goto</code> 和 <code>if-&lt;kind&gt;</code> 目标必须是同一方法中的运算码。
        </td>
      </tr>

      <tr>
        <td>A7</td>

        <td><code>packed-switch</code> 指令的所有目标必须是同一方法中的运算码。目标的大小和列表必须一致。
        </td>
      </tr>

      <tr>
        <td>A8</td>

        <td><code>sparse-switch</code> 指令的所有目标必须是同一方法中的运算码。相应的表必须一致，并从低到高排序。
        </td>
      </tr>

      <tr>
        <td>A9</td>

        <td><code>const-string</code> 和 <code>const-string/jumbo</code> 指令的 <code>B</code> 运算数必须是字符串常量池中的有效索引。
        </td>
      </tr>

      <tr>
        <td>A10</td>

        <td><code>iget&lt;kind&gt;</code> 和 <code>iput&lt;kind&gt;</code> 指令的 <code>C</code> 运算数必须是字段常量池中的有效索引。引用的条目必须表示一个实例字段。
        </td>
      </tr>

      <tr>
        <td>A11</td>

        <td><code>sget&lt;kind&gt;</code> 和 <code>sput&lt;kind&gt;</code> 指令的 <code>C</code> 运算数必须是字段常量池中的有效索引。引用的条目必须表示静态字段。
        </td>
      </tr>

      <tr>
        <td>A12</td>

        <td><code>invoke-virtual</code>、<code>invoke-super</code>、<code>invoke-direct</code> 和 <code>invoke-static</code> 指令的 <code>C</code> 运算数必须是方法常量池中的有效索引。
        </td>
      </tr>

      <tr>
        <td>A13</td>

        <td><code>invoke-virtual/range</code>、<code>invoke-super/range</code>、<code>invoke-direct/range</code> 和 <code>invoke-static/range</code> 指令的 <code>B</code> 运算数必须是方法常量池中的有效索引。
        </td>
      </tr>

      <tr>
        <td>A14</td>

        <td>名称以“&lt;”开头的方法只能由 VM 隐式调用，而不能由 <code>.dex</code> 文件生成的代码调用。唯一的例外是实例初始化程序，它可以由 <code>invoke-direct</code> 调用。
        </td>
      </tr>

      <tr>
        <td>A15</td>

        <td><code>invoke-interface</code> 指令的 <code>C</code> 运算数必须是方法常量池中的有效索引。引用的 <code>method_id</code> 必须属于接口（而非类）。
        </td>
      </tr>

      <tr>
        <td>A16</td>

        <td><code>invoke-interface/range</code> 指令的 <code>B</code> 运算数必须是方法常量池中的有效索引。引用的 <code>method_id</code> 必须属于接口（而非类）。
        </td>
      </tr>

      <tr>
        <td>A17</td>

        <td><code>const-class</code>、<code>check-cast</code>、<code>new-instance</code> 和 <code>filled-new-array/range</code> 指令的 <code>B</code> 运算数必须是类型常量池中的有效索引。
        </td>
      </tr>

      <tr>
        <td>A18</td>

        <td><code>instance-of</code>、<code>new-array</code> 和 <code>filled-new-array</code> 指令的 <code>C</code> 运算数必须是类型常量池中的有效索引。
        </td>
      </tr>

     <tr>
        <td>A19</td>

        <td>由 <code>new-array</code> 指令创建的数组维数必须小于 <code>256</code>。
        </td>
      </tr>

      <tr>
        <td>A20</td>

        <td><code>new</code> 指令不得引用数组类、接口和抽象类。
        </td>
      </tr>

      <tr>
        <td>A21</td>

        <td><code>new-array</code> 指令引用的类型必须是有效的非引用类型。
        </td>
      </tr>

      <tr>
        <td>A22</td>

        <td>指令以单精度宽度（非值对）方式形式引用的所有寄存器必须对当前方法有效。也就是说，它们的索引必须是非负数，并且小于 <code>registers_size</code>。
        </td>
      </tr>

      <tr>
        <td>A23</td>

        <td>指令以双精度宽度（值对）形式引用的所有寄存器必须对当前方法有效。也就是说，它们的索引必须是非负数，并且小于 <code>registers_size-1</code>。
        </td>
      </tr>
      <tr>
        <td>A24</td>

        <td><code>invoke-virtual</code> 和 <code>invoke-direct</code> 指令的 <code>method_id</code> 运算数必须属于一个类（而不是一个接口）。在版本 <code>037</code> 之前的 Dex 文件中，<code>invoke-super</code> 和 <code>invoke-static</code> 指令也是如此。
        </td>
      </tr>

      <tr>
        <td>A25</td>

        <td><code>invoke-virtual/range</code> 和 <code>invoke-direct/range</code> 指令的 <code>method_id</code> 运算数必须属于一个类（而不是一个接口）。在版本 <code>037</code> 之前的 Dex 文件中，<code>invoke-super/range</code> 和 <code>invoke-static/range</code> 指令也是如此。
        </td>
      </tr>
    </tbody></table>

    <h2 id="struct-constraints">结构字节码约束</h2>

    <p>结构约束是对字节码的若干元素之间的关系的约束。通常，无法在不使用控制或数据流分析技术的情况下检查这类约束。
    </p>

    <table>
      <tbody><tr>
        <th>标识符</th>

        <th>说明</th>
      </tr>

      <tr>
        <td>B1</td>

        <td>参数（寄存器和立即值）的数量和类型必须始终与指令相匹配。
        </td>
      </tr>

      <tr>
        <td>B2</td>

        <td>寄存器对绝不能分解。
        </td>
      </tr>

      <tr>
        <td>B3</td>

        <td>必须先分配寄存器（或寄存器对），然后才能读取。
        </td>
      </tr>

      <tr>
        <td>B4</td>

        <td><code>invoke-direct</code> 指令必须仅在当前类或其一个超类中调用实例初始化程序或方法。
        </td>
      </tr>

      <tr>
        <td>B5</td>

        <td>必须只在未初始化的实例上调用实例初始化程序。
        </td>
      </tr>

      <tr>
        <td>B6</td>

        <td>只能在已初始化的实例上调用实例方法，并且只能在已初始化的实例上访问实例字段。
        </td>
      </tr>

      <tr>
        <td>B7</td>

        <td>如果在实例初始化之前再次执行相同的 <code>new-instance</code> 指令，则不能使用保留 <code>new-instance</code> 指令结果的寄存器。
        </td>
      </tr>

      <tr>
        <td>B8</td>

        <td>实例初始化程序必须调用另一个实例初始化程序（相同的类或超类），然后才能访问任何实例成员。异常是非继承的实例字段，通常可在调用另一个初始化程序和 <code>Object</code> 类之前进行分配。
        </td>
      </tr>

      <tr>
        <td>B9</td>

        <td>所有实际的方法参数必须与其各自的形式参数分配兼容。
        </td>
      </tr>

      <tr>
        <td>B10</td>

        <td>对于每个实例方法调用，实际实例必须与指令中指定的类或接口分配兼容。
        </td>
      </tr>

      <tr>
        <td>B11</td>

        <td><code>return&lt;kind&gt;</code> 指令必须与其方法的返回类型相匹配。
        </td>
      </tr>

      <tr>
        <td>B12</td>

        <td>访问超类的受保护成员时，被访问实例的实际类型必须是当前类或它的其中一个子类。
        </td>
      </tr>

     <tr>
        <td>B13</td>

        <td>存储到静态字段中的值的类型必须与字段的类型分配兼容或可转换为字段的类型。
        </td>
      </tr>

      <tr>
        <td>B14</td>

        <td>存储在字段中的值的类型必须与字段的类型分配兼容或可转换为字段的类型。
        </td>
      </tr>

      <tr>
        <td>B15</td>

        <td>存储到数组中的每个值的类型必须与数组的组件类型分配兼容。
        </td>
      </tr>

      <tr>
        <td>B16</td>

        <td><code>throw</code> 指令的 <code>A</code> 运算数必须与 <code>java.lang.Throwable</code> 分配兼容。
        </td>
      </tr>

      <tr>
        <td>B17</td>

        <td>方法的最后一个可访问指令必须是向后的 <code>goto</code> 或分支、<code>return</code> 或 <code>throw</code> 指令。不能将 <code>insns</code> 数组留在底部。
        </td>
      </tr>

      <tr>
        <td>B18</td>

        <td>前一寄存器对中未分配的一半地址可能不会被读取（被视为无效地址），在其他一些指令重新分配之后才会使用。
        </td>
      </tr>

      <tr>
        <td>B19</td>

        <td><code>move-result&lt;kind&gt;</code> 指令之前（在 <code>insns</code> 数组中）必须紧接 <code>invoke-&lt;kind&gt;</code> 指令。唯一的例外情况是 <code>move-result-object</code> 指令，该指令前面也可以接 <code>filled-new-array</code> 指令。
        </td>
      </tr>

      <tr>
        <td>B20</td>

        <td><code>move-result&lt;kind&gt;</code> 指令前面（在实际控制流程中）必须直接是紧接匹配的 <code>return-&lt;kind&gt;</code> 指令（不能跳转到该指令）。唯一的例外情况是 <code>move-result-object</code> 指令，它前面也可以接 <code>filled-new-array</code> 指令。
        </td>
      </tr>

      <tr>
        <td>B21</td>

        <td><code>move-exception</code> 指令必须仅作为异常处理程序中的第一条指令出现。
        </td>
      </tr>

      <tr>
        <td>B22</td>

        <td>控制流不得访问 <code>packed-switch-data</code>、<code>sparse-switch-data</code> 和 <code>fill-array-data</code> 伪指令。
        </td>
      </tr>
    </tbody></table>

</body></html>