<html devsite><head>
    <title>构建可感知多用户的应用</title>
    <meta name="project_path" value="/_project.yaml"/>
    <meta name="book_path" value="/_book.yaml"/>
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<p>对于支持<a href="multi-user.html">多用户</a>的设备，设备上的应用应能够感知不同的用户。</p>

<p>某些应用需要将一些组件作为单例运行，并且可接受来自任意用户的请求。目前只有系统应用可以使用此功能。</p>

<p>这类设备具有以下优势：</p>

<ul>
  <li>节约资源</li><li>判定各个用户之间的一个或多个共享资源</li><li>通过使用单个服务器连接减少网络开销</li></ul>

<p>有关多用户权限流程的描述，请参见下图。</p>

<p><img src="images/multi-user-perms.png" alt="Multiple users permissions flow"/>
</p><p class="img-caption"><strong>图 1</strong> 多用户权限</p>

<h2 id="enabling_a_singleton_component">启用单例组件</h2>

<p>要将应用识别为单例，请将 <code>android:singleUser=”true”</code> 添加至 Android 清单中的服务或提供程序。</p>

<p>在仅以用户 0 的身份运行的进程中，系统会将该组件实例化。所有连接到该提供程序或服务的用户请求都将按指定路径发送到用户 0 的进程中。如果该组件是应用中的唯一组件，则只运行一个应用实例。</p>

<p>软件包中的活动仍将在每个用户各自的进程中启动，并且 UID 处于相应用户的 UID 范围内（例如 1010034）。</p>

<h2 id="interacting_with_users">与用户互动</h2>

<h3 id="perms_required">设置权限</h3>

<p>需要下列权限：</p>

<pre>
INTERACT_ACROSS_USERS (signature|system)
INTERACT_ACROSS_USERS_FULL (signature)
</pre>

<h3 id="apis">使用 API</h3>

<p>使用下列 API，确保应用能够感知多个用户。</p>

<ol>
  <li>从传入的 Binder 调用中提取用户句柄：<ul>
    <li> <code>int userHandle = UserHandle.getCallingUserId()</code>
  </li></ul>
  </li><li>使用受保护的全新 API 启动特定用户的服务、活动和广播：<ul>
    <li><code>Context.startActivityAsUser(Intent, UserHandle)</code>
    </li><li><code>Context.bindServiceAsUser(Intent, …, UserHandle)</code>
    </li><li><code>Context.sendBroadcastAsUser(Intent, … , UserHandle)</code>
    </li><li><code>Context.startServiceAsUser(Intent, …, UserHandle)
UserHandle</code> 可能是显式用户或是特殊句柄之一：<code>UserHandle.CURRENT</code> 或 <code>UserHandle.ALL</code>。<code>CURRENT</code> 表示当前处于前台的用户。如果您想向所有用户发送广播，则可以使用 <code>ALL</code>。
  </li></ul>
  </li><li>要与您自己应用中的组件通信，请使用：
<code>(INTERACT_ACROSS_USERS)</code>
要与其他应用中的组件通信，请使用：
<code>(INTERACT_ACROSS_USERS_FULL)</code>
  </li><li>您可能需要创建代理组件，这些代理组件在用户进程中运行，之后会访问用户 0 中的 <code>singleUser</code> 组件。
  </li><li>采用新的 <code>UserManager</code> 系统服务查询用户及其句柄：<ul>
    <li><code>UserManager.getUsers()</code>
    </li><li><code>UserManager.getUserInfo()</code>
    </li><li><code>UserManager.supportsMultipleUsers()</code>
    </li><li><code>UserManager.getUserSerialNumber(int userHandle)</code> - 与用户句柄对应的不可再循环数字。
    </li><li><code>UserManager.getUserHandle(int serialNumber)</code>
    </li><li><code>UserManager.getUserProfiles() </code>- 返回用户本人个人资料和托管个人资料的集合（如有）。
  </li></ul>
  </li><li>注册即可借助 ContentObserver、PackageMonitor 和 BroadcastReceiver 上的新 API 侦听特定或所有用户以及回调（可提供与回调发起用户相关的其他信息）。
</li></ol>

</body></html>