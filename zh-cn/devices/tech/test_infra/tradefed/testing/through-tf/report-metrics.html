<html devsite><head>

  <meta name="book_path" value="/_book.yaml"/>

  <meta name="project_path" value="/_project.yaml"/>
</head>
<body>
<!--
  Copyright 2019 The Android Open Source Project

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<h1 id="how_to_report_metrics_or_data_from_a_tradefed_test" class="page-title">如何报告 Tradefed 测试中的指标或数据</h1>

<p>本页介绍在 Tradefed 中编写测试时如何报告指标以及测试结果。</p>

<p>通过 Tradefed 管道进行日志记录的好处是您可以在函数式结果旁边找到相应指标。指标的记录可以在测试中非常自然地完成，这便于测试编写者添加更多插桩测试。</p>

<h2 id="devicetestcase_-_junit3_style">DeviceTestCase - JUnit3 型测试</h2>

<p>如果您的测试在 JUnit3 型测试中扩展 <a href="https://android.googlesource.com/platform/tools/tradefederation/+/refs/heads/master/src/com/android/tradefed/testtype/DeviceTestCase.java">DeviceTestCase</a>，那么您可以从任何测试用例内调用 <code>addTestMetric(String key, String value)</code> 方法来报告指标。只要键是唯一的，就可以多次调用此方法。</p>

<p>示例：</p>
<pre class="prettyprint lang-java"><code>    public static class TestMetricTestCase extends DeviceTestCase {

        public void testPass() {
            addTestMetric("key1", "metric1");
        }

        public void testPass2() {
            addTestMetric("key2", "metric2");
        }
    }
</code></pre>
<p>如果您要记录在 <code>result_reporters</code> 中可用的文件，那么您可以从任何测试用例内调用 <code>addTestLog(String dataName, LogDataType dataType, InputStreamSource dataStream)</code> 方法来报告要记录的文件。</p>

<p>示例：</p>
<pre class="prettyprint lang-java"><code>    public static class TestLogTestCase extends DeviceTestCase {

        public void testPass() {
            try (InputStreamSource source = getDevice().getScreenshot()) {
                addTestLog("screenshot", LogDataType.PNG, source);
            }
        }
    }
</code></pre>
<h2 id="testcase_-_regular_junit3_test">TestCase - 常规 JUnit3 测试</h2>

<p>如果您要通过某个常规 JUnit3 TestCase 类报告 Tradefed 内的指标，那么需要将该类转换为 <code>MetricTestCase</code>，它与 TestCase 类完全相同，只不过包含一种额外的方法：<code>addTestMetric(String key, String value)</code></p>

<h2 id="devicejunit4classrunner_-_junit4_style">DeviceJUnit4ClassRunner - JUnit4 型测试</h2>

<p>如果您使用 <a href="https://android.googlesource.com/platform/tools/tradefederation/+/refs/heads/master/src/com/android/tradefed/testtype/DeviceJUnit4ClassRunner.java">DeviceJUnit4ClassRunner</a> 来运行 JUnit4 型测试，那么您还可以记录测试用例中（在 @Test 内）要由 Tradefed 报告的指标。您需要使用 <code>TestMetrics</code> 规则来报告相应指标。</p>

<p>示例：</p>
<pre class="prettyprint lang-java"><code>    @RunWith(DeviceJUnit4ClassRunner.class)
    public static class Junit4TestClass {

        @Rule
        public TestMetrics metrics = new TestMetrics();

        @Test
        public void testPass5() {
            // test log through the rule.
            metrics.addTestMetric("key", "value");
        }

        @Test
        public void testPass6() {
            metrics.addTestMetric("key2", "value2");
        }
    }
</code></pre>
<p>要报告文件，您应使用 <code>TestLogData</code> 规则来报告。</p>

<p>示例：</p>
<pre class="prettyprint lang-java"><code>    @RunWith(DeviceJUnit4ClassRunner.class)
    public static class Junit4TestClass {

        @Rule
        public TestLogData logs = new TestLogData();

        @Test
        public void testPass5() {
            // test log through the rule.
            try (InputStreamSource source = getDevice().getScreenshot()) {
                logs.addTestLog("screenshot", LogDataType.PNG, source);
            }
        }
    }
</code></pre>
<h2 id="iremotetest_-_pure_tradefed_test">IRemoteTest - 纯 Tradefed 测试</h2>

<p>如果您要编写自己的 Tradefed 测试类或运行程序，那么应实现 <a href="https://android.googlesource.com/platform/tools/tradefederation/+/refs/heads/master/src/com/android/tradefed/testtype/IRemoteTest.java">IRemoteTest</a> 并通过 <code>run()</code> 方法获取 <code>ITestInvocationListener</code>。此监听器可用于记录指标，如下所示：</p>
<pre class="prettyprint lang-java"><code>    listener.testLog(String dataName, LogDataType type of data, InputStreamSource data);
</code></pre>
<h2 id="tradefed_metrics_collectors">Tradefed 指标收集器</h2>

<p>Tradefed 提供了一个专用的 <code>metrics_collector</code> 对象，用于在运行测试的同时收集指标。</p>

<h3 id="on_the_host_side">在主机端</h3>

<p>可以实现 <a href="https://android.googlesource.com/platform/tools/tradefederation/+/refs/heads/master/src/com/android/tradefed/device/metric/BaseDeviceMetricCollector.java">BaseDeviceMetricCollector</a> 以从主机端收集任意指标，并在测试调用过程中报告这些指标。许多通用收集器已经可用于不同的用例，但我们总是欢迎您做出新的贡献。</p>

<p>要指定要在 Tradefed 调用过程中使用的收集器，您只需将该对象添加到 Tradefed XML 配置：</p>

<p>示例：</p>
<pre class="prettyprint lang-xml"><code>  &lt;metrics_collector class="com.android.tradefed.device.metric.AtraceCollector"&gt;
      &lt;option name="categories" value="freq"/&gt;
  &lt;/metrics_collector&gt;
</code></pre>
<p>下面是一些现有的收集器：
*   <a href="https://android.googlesource.com/platform/tools/tradefederation/+/refs/heads/master/src/com/android/tradefed/device/metric/TemperatureCollector.java">TemperatureCollector</a>
在测试运行期间定期收集温度。
*   <a href="https://android.googlesource.com/platform/tools/tradefederation/+/refs/heads/master/src/com/android/tradefed/device/metric/AtraceCollector.java">AtraceCollector</a>
针对每个测试用例收集“atrace”的使用指标。</p>

<h3 id="on_the_device_side">在设备端</h3>

<p>在运行设备端测试（插桩测试、UIAutomator 测试等）时，让主机端的收集器异步收集指标可能并不是理想的做法。例如，异步截取的屏幕截图很可能会错过想要的屏幕，变得毫无用处。</p>

<p>为了满足这些用例的要求，我们提供了收集器的设备端版本，该版本可用于任何“AndroidJUnitRunner”插桩测试。
可以实现 <a href="https://android.googlesource.com/platform/platform_testing/+/refs/heads/master/libraries/device-collectors/src/main/java/android/device/collectors/BaseMetricListener.java">BaseMetricListener</a>，以便自动报告采用与 Tradefed 报告渠道完全兼容的方式收集的指标。</p>

<p>如果您使用的是 Tradefed 的“<a href="https://android.googlesource.com/platform/tools/tradefederation/+/refs/heads/master/src/com/android/tradefed/testtype/AndroidJUnitTest.java">AndroidJUnitTest</a>”运行程序，那么您可以直接指定以下命令行选项，让您的收集器与测试一起运行：</p>
<pre class="prettyprint lang-shell"><code>  --device-listeners android.device.collectors.ScreenshotListener
</code></pre>
<p>注意：为了能够在运行时解析收集器类，您的插桩测试 APK 很可能需要静态地包含这些类。为此，您可以将以下内容添加到 makefile：</p>
<pre class="prettyprint lang-shell"><code>  LOCAL_STATIC_JAVA_LIBRARIES += collector-device-lib
</code></pre>
<p>我们也欢迎您对设备端收集器做出贡献。</p>

<h3 id="special_consideration_for_suites">对套件的特别考虑</h3>

<p>在部分套件（如 CTS）中，顶级配置运行一些模块配置，对于此类套件，不需要在每个模块配置 (<code>AndroidTest.xml</code>) 中指定 <code>metrics_collector</code>。实际上禁止这样做。</p>

<p>要确保指标收集同样地应用于每个模块，只有顶级配置（例如 <code>cts.xml</code>）可以指定 <code>metrics_collector</code>，如上所述。这些收集器将针对套件的每个模块应用并运行。</p>

<h3 id="how_to_collect_device_log_files_from_a_module">如何从模块收集设备日志文件？</h3>

<p>为使设备端测试能够通知应收集某些文件，我们提供了相应设置。</p>

<p><code>AndroidTest.xml</code> 可以指定一个收集器，该收集器将在设备上查找文件并提取这些文件。</p>
<pre class="prettyprint lang-xml"><code>  &lt;metrics_collector class="com.android.tradefed.device.metric.FilePullerLogCollector"&gt;
      &lt;!-- repeatable: Pattern of key of a FILE we listen on that should be pulled --&gt;
      &lt;option name = "pull-pattern-keys" value = "ScreenshotListener_.*" /&gt;

      &lt;!-- repeatable: The key of the DIRECTORY to pull --&gt;
      &lt;option name = "directory-keys" value = "&lt;example-key: /sdcard/atrace_logs&gt;" /&gt;
  &lt;/metrics_collector&gt;
</code></pre>
<p>指定这些模式和键后，如果收集器发现相应键，将尝试提取并记录关联的文件。</p>

<p>为了生成这些键，设备端测试（插桩测试）应该指定应记录的文件。它的完成方式与主机端测试（如上所述）类似。</p>

<ol>
<li>将 <code>collector-device-lib</code> 添加到 makefile 中的测试 APK：</li>
</ol>
<pre class="prettyprint lang-shell"><code>  LOCAL_STATIC_JAVA_LIBRARIES += collector-device-lib
</code></pre>
<ol>
<li>使用我们提供的 @rule 来记录文件：</li>
</ol>
<pre class="prettyprint lang-java"><code>    @RunWith(AndroidJUnit4.class)
    public static class Junit4TestClass {

        @Rule
        public TestLogData logs = new TestLogData();

        @Test
        public void testPass5() {
            // test log through the rule.
            File logFile = new File("whatever");
            logs.addTestLog("KEY", logFile);
        }
    }
</code></pre>
<p>上例中的 <code>KEY</code> 名称是报告文件时将会使用的名称。您应在 <code>FilePullerDeviceMetricCollector</code> 中匹配此名称，以自动提取相应文件。它应该是一个唯一的名称。</p>

<p>注意：提取文件后，<code>FilePullerDeviceMetricCollector</code> 会自动将其从设备中清除。</p>

<h2 id="where_to_find_the_metrics">在哪里可以找到指标？</h2>

<p>这取决于在 XML 配置中指定的 <code>result_reporter</code>。</p>

</body></html>