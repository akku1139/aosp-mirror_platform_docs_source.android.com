<html devsite><head>
    <title>添加 ConfigStore 类和项</title>
    <meta name="project_path" value="/_project.yaml"/>
    <meta name="book_path" value="/_book.yaml"/>
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<p>您可以为现有接口类添加新的 ConfigStore 项（即接口方法）。如果您未定义接口类，则必须先添加一个新类，然后才能为该接口类添加 ConfigStore 项。本部分使用 <code>disableInitBlank</code> 配置项示例来演示将 <code>healthd</code> 添加到 <code>IChargerConfigs</code> 接口类的过程。</p>

<p class="note"><strong>注意</strong>：请务必先熟悉<a href="/devices/architecture/hidl/index.html">常规 HIDL 概念</a>、<a href="/devices/architecture/hidl-cpp/index.html">HIDL C++ 开发工作流程</a>、<a href="/devices/architecture/hidl/code-style.html">HIDL 代码样式</a>和 <a href="/devices/architecture/configstore/index.html">ConfigStore 设计</a>，然后再继续操作。</p>

<h2 id="add-class">添加接口类</h2>
<p>如果您没有为要添加的接口方法定义接口类，则必须先添加接口类，然后才能添加相关联的 ConfigStore 项。</p>

<ol>
<li>创建 HAL 接口文件。ConfigStore 版本为 1.0，因此请在 <code>hardware/interfaces/configstore/1.0</code> 中定义 ConfigStore 接口。例如，在 <strong><code>hardware/interfaces/configstore/1.0/IChargerConfigs.hal</code></strong> 中运行以下命令：<pre class="devsite-click-to-copy">
package android.hardware.configstore@1.0;

interface IChargerConfigs {
    // TO-BE-FILLED-BELOW
};
</pre></li>

<li>为 ConfigStore 共享库和标头文件更新 <code>Android.bp</code> 和 <code>Android.mk</code>，以包含新的接口 HAL。例如：

<pre class="devsite-click-to-copy">
<code class="devsite-terminal">hidl-gen -o hardware/interfaces/configstore/1.0/default -Lmakefile -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hardware.configstore@1.0::IChargerConfigs</code>
<code class="devsite-terminal">hidl-gen -o hardware/interfaces/configstore/1.0/default -Landroidbp -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hardware.configstore@1.0::IChargerConfigs</code>
</pre>
这些命令可在 <code>hardware/interfaces/configstore/1.0</code> 中更新 <code>Android.bp</code> 和 <code>Android.mk</code>。</li>

<li>生成用于实现服务器代码的 C++ 存根。例如：

<pre class="devsite-terminal devsite-click-to-copy">
hidl-gen -o hardware/interfaces/configstore/1.0/default -Lc++-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hardware.configstore@1.0::IChargerConfigs
</pre>此命令可在 <code>hardware/interfaces/configstore/1.0/default</code> 中创建两个文件：<code>ChargerConfigs.h</code> 和 <code>ChargerConfigs.cpp</code>。</li>

<li>打开 .h 和 .cpp 实现文件，并移除与函数 <code>HIDL_FETCH_<em>name</em></code>（例如 <code>HIDL_FETCH_IChargerConfigs</code>）相关的代码。这是 HIDL 直通模式所需的函数，ConfigStore 不使用该模式。</li>

<li>将实现注册为 ConfigStore 服务。例如，在 <strong><code>hardware/interfaces/configstore/1.0/default/service.cpp</code></strong> 中运行以下命令：

<pre class="devsite-click-to-copy">
#include &lt;android/hardware/configstore/1.0/IChargerConfigs.h&gt;
#include "ChargerConfigs.h"

using android::hardware::configstore::V1_0::IChargerConfigs;
using android::hardware::configstore::V1_0::implementation::ChargerConfigs;

int main() {
    ... // other code
    sp&lt;IChargerConfigs&gt; chargerConfigs = new ChargerConfigs;
    status = chargerConfigs-&gt;registerAsService();
    LOG_ALWAYS_FATAL_IF(status != OK, "Could not register IChargerConfigs");
    ... // other code
}
</pre></li>

<li>修改 <code>Android.mk</code> 文件，以便将实现文件 (<em></em>modulenameConfigs.cpp) 添加到 LOCAL_SRC_FILES 并将编译标记映射到宏定义中。例如，在 <strong><code>hardware/interfaces/configstore/1.0/default/Android.mk</code></strong> 中运行以下命令：

<pre class="devsite-click-to-copy">
LOCAL_SRC_FILES += ChargerConfigs.cpp

ifeq ($(strip $(BOARD_CHARGER_DISABLE_INIT_BLANK)),true)
LOCAL_CFLAGS += -DCHARGER_DISABLE_INIT_BLANK
endif
</pre></li>

<li>（可选）添加清单项。如果清单项不存在，则默认添加 ConfigStore 的“default”实例名称。例如，在 <strong><code>device/google/marlin/manifest.xml</code></strong> 中运行以下命令：

<pre class="devsite-click-to-copy">
    &lt;hal format="hidl"&gt;
        &lt;name&gt;android.hardware.configstore&lt;/name&gt;
        ...
        &lt;interface&gt;
            &lt;name&gt;IChargerConfigs&lt;/name&gt;
            &lt;instance&gt;default&lt;/instance&gt;
        &lt;/interface&gt;
    &lt;/hal&gt;
</pre></li>

<li>视需要（即，如果客户端没有向 <code>hal_configstore</code> 进行 hwbinder 调用的权限）添加 sepolicy 规则。例如，在 <strong><code>system/sepolicy/private/healthd.te</code></strong> 中运行以下命令：

<pre class="devsite-click-to-copy">
... // other rules
binder_call(healthd, hal_configstore)
</pre></li>
</ol>

<h2 id="add-item">添加新的 ConfigStore 项</h2>
<p>要添加新的 ConfigStore 项，请执行以下操作：</p>
<ol>
<li>打开 HAL 文件，并为该项添加所需的接口方法（ConfigStore 的 .hal 文件位于 <code>hardware/interfaces/configstore/1.0</code> 中）。例如，在 <strong><code>hardware/interfaces/configstore/1.0/IChargerConfigs.hal</code></strong> 中运行以下命令：

<pre class="devsite-click-to-copy">
package android.hardware.configstore@1.0;

interface IChargerConfigs {
    ... // Other interfaces
    disableInitBlank() generates(OptionalBool value);
};
</pre></li>

<li>在相应的接口 HAL 实现文件（.h 和 .cpp）中实现该方法。将默认实现放置在 <code>hardware/interfaces/configstore/1.0/default</code> 中。

<p class="note"><strong>注意</strong>：使用 <code>-Lc++-impl</code> 运行 <code>hidl-gen</code> 将为新添加的接口方法生成框架代码。不过，由于该方法也会覆盖所有现有接口方法的实现，因此请酌情使用 <code>-o</code> 选项。</p>

例如，在 <strong><code>hardware/interfaces/configstore/1.0/default/ChargerConfigs.h</code></strong> 中运行以下命令：

<pre class="devsite-click-to-copy">
struct ChargerConfigs : public IChargerConfigs {
    ... // Other interfaces
    Return&lt;void&gt; disableInitBlank(disableInitBlank_cb _hidl_cb) override;
};
</pre>

在 <strong><code>hardware/interfaces/configstore/1.0/default/ChargerConfigs.cpp</code></strong> 中运行以下命令：

<pre class="devsite-click-to-copy">
Return&lt;void&gt; ChargerConfigs::disableInitBlank(disableInitBlank_cb _hidl_cb) {
    bool value = false;
#ifdef CHARGER_DISABLE_INIT_BLANK
    value = true;
#endif
    _hidl_cb({true, value});
    return Void();
}
</pre></li>
</ol>

<h2 id="using">使用 ConfigStore 项</h2>
<p>要使用 ConfigStore 项，请执行以下操作：</p>

<ol>
<li>添加所需的标头文件。例如，在 <strong><code>system/core/healthd/healthd.cpp</code></strong> 中运行以下命令：

<pre class="devsite-click-to-copy">
#include &lt;android/hardware/configstore/1.0/IChargerConfigs.h&gt;
#include &lt;configstore/Utils.h&gt;
</pre></li>

<li>使用 <code>android.hardware.configstore-utils</code> 中相应的模板函数访问 ConfigStore 项。例如，在 <strong><code>system/core/healthd/healthd.cpp</code></strong> 中运行以下命令：

<pre class="devsite-click-to-copy">
using namespace android::hardware::configstore;
using namespace android::hardware::configstore::V1_0;

static int64_t disableInitBlank = getBool&lt;
        IChargerConfigs,
        &amp;IChargerConfigs::disableInitBlank&gt;(false);
</pre>
在本例中，系统检索了 ConfigStore 项 <code>disableInitBlank</code> 并将其存储到某个变量中（在需要多次访问该变量时，这样做非常有帮助）。从 ConfigStore 检索的值会缓存到实例化的模板函数内，这样系统就可以快速从缓存值中检索到该值，而无需与 ConfigStore 服务通信以便稍后调用实例化的模板函数。
</li>

<li>在 <code>Android.mk</code> 或 <code>Android.bp</code> 中添加对 ConfigStore 和 <code>configstore-utils</code> 库的依赖关系。例如，在 <strong><code>system/core/healthd/Android.mk</code></strong> 中运行以下命令：

<pre class="devsite-click-to-copy">
LOCAL_SHARED_LIBRARIES := \
    android.hardware.configstore@1.0 \
    android.hardware.configstore-utils \
    ... (other libraries) \
</pre></li>
</ol>

</body></html>