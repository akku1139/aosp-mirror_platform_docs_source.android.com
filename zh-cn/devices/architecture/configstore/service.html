<html devsite><head>
    <title>实现服务</title>
    <meta name="project_path" value="/_project.yaml"/>
    <meta name="book_path" value="/_book.yaml"/>
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<p>为了准备 HAL 实现，您可以先生成基本的 configstore 接口代码，然后再对其进行修改以满足自己的需求。</p>

<h2 id="generate-boilerplate">生成接口代码</h2>
<p>要为接口生成样板代码，请运行 <code>hidl-gen</code>。
例如，要为 <code>surfaceflinger</code> 生成代码，请运行以下命令：</p>

<pre class="devsite-terminal devsite-click-to-copy">
hidl-gen -o hardware/interfaces/configstore/1.0/default \
    -Lc++-impl \
    -randroid.hardware:hardware/interfaces \
    -randroid.hidl:system/libhidl/transport \
    android.hardware.config@1.0::ISurfaceFlingerConfigs
</pre>

<p class="note"><strong>注意</strong>：请勿使用 <code>-Landroidbp-impl</code> 运行 <code>hidl-gen</code>，因为这会生成 <code>Android.bp</code>。该模块必须通过 <code>Android.mk</code> 进行编译才能访问编译标记。</p>

<h2 id="modify-androidmk">修改 Android.mk</h2>
<p>接下来，请修改 <code>Android.mk</code> 文件，以便将实现文件 (<code>&lt;modulename&gt;Configs.cpp</code>) 添加到 <code>LOCAL_SRC_FILES</code> 并将编译标记映射到宏定义中。例如，您可以在 <strong><code>hardware/interface/configstore/1.0/default/Android.mk</code></strong> 中运行以下命令来修改 <code>surfaceflinger</code>：
</p>

<pre class="devsite-click-to-copy">
LOCAL_SRC_FILES += SurfaceFlingerConfigs.cpp
ifneq ($(NUM_FRAMEBUFFER_SURFACE_BUFFERS),)
    LOCAL_CFLAGS += -DNUM_FRAMEBUFFER_SURFACE_BUFFERS=$(NUM_FRAMEBUFFER_SURFACE_BUFFERS)
endif

ifeq ($(TARGET_RUNNING_WITHOUT_SYNC_FRAMEWORK),true)
    LOCAL_CFLAGS += -DRUNNING_WITHOUT_SYNC_FRAMEWORK
endif
</pre>

<p>如果 <code>Android.mk</code> 包含几个 <code>ifeq-endif</code> 块，请考虑将代码移动到新文件（即 <code>surfaceflinger.mk</code>）中，然后从 <code>Android.mk</code> 中引用该文件。</p>

<h2 id="implement-functions">实现函数</h2>
<p>要填充函数以实现 HAL，请以不同的值回调 <code>_hidl_cb</code> 函数（以编译标记为条件）。例如，您可以在 <strong><code>hardware/interfaces/configstore/1.0/default/SurfaceFlingerConfigs.cpp</code></strong> 中填充 <code>surfaceflinger</code> 的函数：</p>

<pre class="devsite-click-to-copy">
Return&lt;void&gt; SurfaceFlingerConfigs::numFramebufferSurfaceBuffers(
        numFramebufferSurfaceBuffers_cb _hidl_cb) {
    #if NUM_FRAMEBUFFER_SURFACE_BUFFERS 2
    _hidl_cb(NumBuffers.TWO);
    #else if NUM_FRAMEBUFFER_SURFACE_BUFFERS 3
    _hidl_cb(NumBuffers.THREE);
    #else
    _hidl_cb(NumBuffers.USE_DEFAULT);
    #endif
}

Return&lt;void&gt; SurfaceFlingerConfigs::runWithoutSyncFramework(
        runWithoutSyncFramework_cb _hidl_cb) {
    #ifdef RUNNING_WITHOUT_SYNC_FRAMEWORK
    _hidl_cb({true /* specified */, true /* value */});
    #else
    // when macro not defined, we can give any value to the second argument.
    // It will simply be ignored in the framework side.
    _hidl_cb({false /* specified */, false /* value */});
    #endif
}
</pre>

<p>请确保该实现不包含名为 <code>HIDL_FETCH_&lt;interface name&gt;</code> 的函数（例如 <code>HIDL_FETCH_ISurfaceFlingerConfigs</code>）。这是 HIDL 直通模式所需的函数，<code>configstore</code> 不使用（且被禁止使用）该函数。ConfigStore 必须始终在绑定模式下运行。</p>

<h2 id="register-service">注册为服务</h2>
<p>最后，将所有接口实现注册为 <code>configstore</code> 服务。例如，您可以在 <strong><code>hardware/interfaces/configstore/1.0/default/service.cpp</code></strong> 中注册 <code>surfaceflinger</code> 实现：
</p>

<pre class="devsite-click-to-copy">
configureRpcThreadpool(maxThreads, true);
sp&lt;ISurfaceFlingerConfigs&gt; surfaceFlingerConfigs = new SurfaceFlingerConfigs;
status_t status = surfaceFlingerConfigs-&gt;registerAsService();

sp&lt;IBluetoothConfigs&gt; bluetoothConfigs = new BluetoothConfigs;
status = bluetoothConfigs-&gt;registerAsService();

// register more interfaces here
joinRpcThreadpool();
</pre>

<h2 id="bootstrapping">确保可尽早访问</h2>
<p>为了确保框架模块可以尽早访问· HAL 服务，config HAL 服务应该在 <code>hwservicemanager</code> 准备就绪之后尽早启动。由于配置 HAL 服务不会读取外部文件，因此在启动之后预计很快就能准备就绪。</p>

</body></html>