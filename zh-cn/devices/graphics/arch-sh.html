<html devsite><head>
    <title>Surface 和 SurfaceHolder</title>
    <meta name="project_path" value="/_project.yaml"/>
    <meta name="book_path" value="/_book.yaml"/>
  </head>
  <body>

  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<p>Surface 对象使应用能够渲染要在屏幕上显示的图像。通过 SurfaceHolder 接口，应用可以编辑和控制 Surface。</p>

<h2 id="surface">Surface</h2>

<p><a href="https://developer.android.com/reference/android/view/Surface.html" class="external">Surface</a> 是一个接口，供生产方与消耗方交换缓冲区。</p>

<p>用于显示 Surface 的 BufferQueue 通常配置为三重缓冲。缓冲区是按需分配的，因此，如果生产方足够缓慢地生成缓冲区（例如在 60 fps 的显示屏上以 30 fps 的速度进行缓冲），队列中可能只有两个分配的缓冲区。按需分配缓冲区有助于最大限度地减少内存消耗。您可以看到与 <code>dumpsys SurfaceFlinger</code> 输出中每个层级相关的缓冲区的摘要。</p>

<p>大多数客户端使用 <a href="/devices/graphics/arch-egl-opengl">OpenGL ES</a> 或 <a href="/devices/graphics/arch-vulkan">Vulkan</a> 渲染到 Surface 上。但是，有些客户端使用画布渲染到 Surface 上。</p><p>

</p><h3 id="canvas">画布渲染</h3>

<p>画布实现由 <a href="https://skia.org/" class="external">Skia 图形库</a>提供。如果您要绘制一个矩形，可以调用 Canvas API，它会在缓冲区中适当地设置字节。为了确保两个客户端不会同时更新某个缓冲区，或者在该缓冲区正在被显示时写入该缓冲区，请锁定该缓冲区以进行访问。您可以使用以下命令处理画布锁：</p><ul>
  <li><a href="https://developer.android.com/reference/android/view/Surface.html#lockCanvas(android.graphics.Rect)" class="external"><code>lockCanvas()</code></a> 可锁定缓冲区以在 CPU 上渲染，并返回用于绘图的画布。</li>
  <li><a href="https://developer.android.com/reference/android/view/Surface.html#unlockCanvasAndPost(android.graphics.Canvas)" class="external"><code>unlockCanvasAndPost()</code></a> 可解锁缓冲区并将其发送到合成器。</li>
  <li><a href="https://developer.android.com/reference/android/view/Surface.html#lockHardwareCanvas()" class="external"><code>lockHardwareCanvas()</code></a> 可锁定缓冲区以在 GPU 上渲染，并返回用于绘图的画布。</li>
</ul>

<aside class="note"><strong>注意</strong>：当应用通过 <code>lockCanvas()</code> 锁定 Surface 时，所获得的画布从未获得硬件加速。</aside>

<aside class="caution"><strong>注意</strong>：如果您曾调用过 <code>lockCanvas()</code>，则无法使用 GLES 在 Surface 上绘图或从视频解码器向其发送帧。<code>lockCanvas()</code> 会将 CPU 渲染程序连接到 BufferQueue 的生产方，直到 Surface 被销毁时才会断开连接。与大多数生产方（如 GLES 或 Vulkan）不同，基于画布的 CPU 渲染程序无法断开连接并重新连接到 Surface。</aside>

<p>生产方首次从 BufferQueue 请求缓冲区时，缓冲区将被分配并初始化为零。必须进行初始化，以避免意外地在进程之间共享数据。但是，如果您重复使用缓冲区，以前的内容仍会存在。如果您反复调用 <code>lockCanvas()</code> 和 <code>unlockCanvasAndPost()</code> 而不绘制任何内容，则生产方会在先前渲染的帧之间循环。</p>

<p>Surface 锁定/解锁代码会保留对先前渲染的缓冲区的引用。如果在锁定 Surface 时指定了脏区域，那么它将从以前的缓冲区复制非脏像素。SurfaceFlinger 或 HWC 通常会处理缓冲区；但是由于我们只需从缓冲区中读取内容，因此无需等待独占访问。</p>

<h2 id="surfaceholder">SurfaceHolder</h2>

<p><a href="https://developer.android.com/reference/android/view/SurfaceHolder.html" class="external">SurfaceHolder</a> 是系统用于与应用共享 Surface 所有权的接口。与 Surface 配合使用的一些客户端需要 SurfaceHolder，因为用于获取和设置 Surface 参数的 API 是通过 SurfaceHolder 实现的。一个 <a href="/devices/graphics/arch-sv">SurfaceView</a> 包含一个 SurfaceHolder。</p>

<p>与 View 交互的大多数组件都涉及到 SurfaceHolder。一些其他 API（如 MediaCodec）将在 Surface 本身上运行。</p>

</body></html>