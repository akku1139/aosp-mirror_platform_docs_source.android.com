<html devsite><head>
    <title>OpenGLRenderer 配置</title>
    <meta name="project_path" value="/_project.yaml"/>
    <meta name="book_path" value="/_book.yaml"/>
  </head>
  <body>
  <!--
      Copyright 2017 The Android Open Source Project

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
  -->

<p>本文档介绍了以充分利用硬件为目标的性能调校。</p>

<p class="note"><strong>注意</strong>：在 Android 8.1 及更高版本中，只有 <code>ro.zygote.disable_gl_preload</code> 属性仍然适用。所有其他属性均已移除。</p>

<h2>OpenGLRenderer (libhwui) 属性</h2>
<p>本文档列出了您可以用来控制 Android 的 2D 硬件加速渲染管道的所有属性。将 <code>device.mk</code> 中的这些属性设为 <code>PRODUCT_PROPERTY_OVERRIDES</code>。</p>

<table>
<tbody><tr>
  <th>属性</th>
  <th>类型</th>
  <th>默认值</th>
  <th>说明</th>
</tr>

<tr>
  <td><code>ro.hwui.disable_scissor_opt</code></td>
  <td><code>boolean</code></td>
  <td><code>false</code></td>
  <td><p>用于启用或停用剪刀优化。接受的值为 true 和 false。如果启用剪刀优化，则 OpenGLRenderer 会尝试选择性启用和停用 GL 剪刀测试，以尽可能不使用剪刀。</p>
  <p>如果停用优化，则 OpenGLRenderer 会让 GL 剪刀测试保持启用状态，并根据需要更改剪刀矩形。当剪刀矩形的更改频率超过启用或停用剪刀测试的频率时，某些 GPU（例如 SGX 540）的性能会更好。</p>
  </td>
</tr>

<tr>

  <td><code>ro.hwui.texture_cache_size</code></td>
  <td><code>float</code></td>
  <td><code>24</code></td>
  <td>定义每个进程纹理缓存的大小（以兆字节为单位）。我们建议使用大容量的缓存，以足够容纳多个 32 位纹理的屏幕（例如，在 1280x800 显示屏上，一次全屏缓冲使用大约 4 MB 的内存，因此缓存应至少为 20 MB）。</td>
</tr>

<tr>
  <td><code>ro.hwui.layer_cache_size</code></td>
  <td><code>float</code></td>
  <td><code>16</code></td>
  <td>定义每个进程图层缓存的大小（以兆字节为单位）。我们建议使用大容量的缓存，以足够容纳 4 次 32 位屏幕。例如，在 1280x800 显示屏上，一次全屏缓冲使用大约 4 MB 的内存，因此缓存应至少为 16 MB。</td>
</tr>
<tr>
  <td><code>ro.hwui.gradient_cache_size</code></td>
  <td><code>0.5</code></td>
  <td><code>float</code></td>
  <td>定义每个进程渐变缓存的大小（以兆字节为单位）。单次渐变通常占用 1-4 KB 的内存。建议使用大容量的缓存，以足够容纳至少 12 次渐变。</td>
</tr>

<tr>
  <td><code>ro.hwui.patch_cache_size</code></td>
  <td><code>integer</code></td>
  <td><code>128</code></td>
  <td>定义每个进程中 9-patch 缓存的大小（以千字节为单位）。此缓存仅保留顶点数据，因此可以保持小容量。每个顶点由 4 个浮点数（即 16 个字节）组成。</td>
</tr>

<tr>
  <td><code>ro.hwui.path_cache_size</code></td>
  <td><code>float</code></td>
  <td><code>4</code></td>
  <td>定义每个进程路径缓存的大小（以兆字节为单位）。我们建议使用大容量缓存，以足够容纳至少一个 32 位纹理的屏幕。例如，在 1280x800 显示屏上，一次全屏缓冲使用大约 4 MB 的内存，因此缓存应至少为 4 MB。</td>
</tr>

<tr>
  <td><code>ro.hwui.shape_cache_size</code></td>
  <td><code>float</code></td>
  <td><code>1</code></td>
  <td>定义每个进程图形缓存的大小（以兆字节为单位）。该值由多个缓存（如圆形和圆角矩形）使用。我们建议使用大容量缓存，以足够容纳至少一个 8 位屏幕。例如，在 1280x800 显示屏上，一次全屏缓冲使用大约 1 MB 的内存，因此缓存应至少为 1 MB。</td>
</tr>
<tr>
  <td><code>ro.hwui.drop_shadow_cache_size</code></td>
  <td><code>float</code></td>
  <td><code>2</code></td>
  <td>定义每个进程文字阴影缓存的大小（以兆字节为单位）。我们建议使用大容量缓存，以足够容纳两个 8 位纹理的屏幕。例如，在 1280x800 显示屏上，一次全屏缓冲使用大约 1 MB 的内存，因此缓存应至少为 2 MB。</td>
</tr>
<tr>
  <td><code>ro.hwui.r_buffer_cache_size</code></td>
  <td><code>float</code></td>
  <td><code>2</code></td>
  <td>定义每个进程的渲染缓冲区缓存的大小（以兆字节为单位）。我们建议您使用大容量的缓存，以足够容纳 2 次 8 位的屏幕。例如，在 1280x800 显示屏上，一次全屏缓冲使用大约 1 MB 的内存，因此缓存应至少为 2 MB。如果设备支持 4 位或 1 位模板缓冲，则可以使用更小容量的缓存。</td>
</tr>
<tr>
  <td><code>ro.hwui.texture_cache_flush_rate</code></td>
  <td><code>float</code></td>
  <td><code>0.6</code></td>
  <td>定义内存清理之后保留的纹理缓存所占的比例。当系统需要回收所有应用的内存时，就会触发内存清理。我们建议在这种情况下释放大约 50% 的缓存。</td>
</tr>
<tr>
  <td><code>ro.hwui.text_small_cache_width</code></td>
  <td><code>integer</code></td>
  <td><code>1024</code></td>
  <td>定义默认字体缓存的宽度（以像素为单位）。上限取决于 GPU 上传纹理的速度。我们建议该宽度不低于 1024 像素、不超过 2048 像素。您还应该使用二次方值。</td>
</tr>
<tr>
  <td><code>ro.hwui.text_small_cache_height</code></td>
  <td><code>integer</code></td>
  <td><code>256</code></td>
  <td>定义默认字体缓存的高度（以像素为单位）。上限取决于 GPU 上传纹理的速度。我们建议该高度不低于 256 像素、不超过 1024 像素。</td>
</tr>
<tr>
  <td><code>ro.hwui.text_large_cache_width</code></td>
  <td><code>integer</code></td>
  <td><code>2048</code></td>
  <td>定义大号字体缓存的宽度（以像素为单位）。此缓存用于字形过大难以适应默认字体缓存的情形。上限取决于 GPU 上传纹理的速度。我们建议该宽度不低于 2048 像素、不超过 4096 像素。您还应该使用二次方值。</td>
</tr>

<tr>
  <td><code>ro.hwui.text_large_cache_height</code></td>
  <td><code>integer</code></td>
  <td><code>512</code></td>
  <td>定义大号字体缓存的高度（以像素为单位）。大号字体缓存用于字形过大难以适应默认字体缓存的情形。上限取决于 GPU 上传纹理的速度。我们建议该高度不低于 512 像素、不超过 2048 像素。您还应该使用二次方值。</td>
</tr>

<tr>
  <td><code>ro.zygote.disable_gl_preload</code></td>
  <td><code>boolean</code></td>
  <td><code>false</code></td>
  <td>用于在启动时启用/停用 Zygote 中的 EGL/GL 驱动程序预加载。当此属性设为 false 时，Zygote 将通过调用 eglGetDisplay(EGL_DEFAULT_DISPLAY) 来预加载 GL 驱动程序。
目标是加载 Zygote 中的动态库代码，以便与所有其他进程共享。如果驱动程序不支持共享，则将此属性设为 true。</td>
</tr>

<tr>
  <td><code>hwui.text_gamma_correction</code></td>
  <td><code>string</code></td>
  <td><code>lookup</code></td>
  <td>选择文字伽马校正方法。有以下四种方法可供选择：
  <ul>
   <li><code>lookup3</code>：基于查询表校正。伽马校正针对黑白文字的表现并不相同（请参见下方的阈值）。</li>

   <li><code>lookup</code>：基于单一查询表校正。</li>

    <li><code>shader3</code>：由 GLSL 着色器应用校正。伽马校正针对黑白文字的表现并不相同（请参见下方的阈值）。</li>

    <li><code>shader</code>：由 GLSL 着色器应用校正。</li>
  </ul>查询伽马校正在着色器数学受限的 GPU 上表现最出色。着色器伽马校正是节省内存的最佳选择。我们建议使用默认的 <code>lookup</code> 方法，它能够在质量、速度和内存使用方面提供理想的折中方案。
</td>
</tr>

<tr>
  <td><code>hwui.text_gamma</code></td>
  <td><code>float</code></td>
  <td><code>1.4</code></td>
  <td>定义用于文字伽马校正的伽马值。该值可以根据设备使用的显示屏进行调整。</td>
</tr>
<tr>
  <td><code>hwui.text_gamma.black_threshold</code></td>
  <td><code>integer</code></td>
  <td><code>64</code></td>
  <td>定义应用黑色伽马校正的亮度阈值上限。必须在 0-255 的范围内定义该值。</td>
</tr>
<tr>
  <td><code>hwui.text_gamma.white_threshold</code></td>
  <td><code>integer</code></td>
  <td><code>192</code></td>
  <td>定义应用白色伽马校正的亮度阈值下限。必须在 0-255 的范围内定义该值。</td>
</tr>
<tr>
  <td><code>hwui.use_gpu_pixel_buffers</code></td>
  <td><code>boolean</code></td>
  <td><code>true</code></td>
  <td>用于在 OpenGL ES 3.0 硬件上启用或停用 PBO。渲染器会使用 PBO 来执行异步纹理上传，尤其是字体缓存。该属性应始终保持启用状态，但如果使用 PBO 导致出现损坏或性能很低的情况，则可以在设备开发期间停用该属性。因此，该属性不是只读属性。</td>
</tr>
</tbody></table>

</body></html>